{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FarmDyn","text":""},{"location":"#a-dynamic-mixed-integer-bio-economic-farm-scale-model","title":"A dynamic mixed integer bio-economic farm scale model","text":"<p>FARMDYN provides a flexible, modular template to simulate different farming systems (dairy, mother cows, beef fattening, pig fattening, piglet production, arable farming, biogas plants) at single farm scale.</p> <p></p> <p>Universit\u00e4t Bonn Institute for Food and Resource Economics Economic Modeling of Agricultural Systems Group</p>"},{"location":"#main-characteristics","title":"Main characteristics","text":"<ul> <li>Multiple dynamics including comparative-static,     short run, or fully dynamic, with simulations covering several decades</li> <li>Integer variables capture indivisibilities in investments     (machinery, buildings) and labour use</li> <li>Selected farm management decisions (e.g. feeding, manure management,     labour use) depicted with a sub-annual temporal resolution,     partially bi-weekly  </li> <li>Farm labour, machinery and stable use are modelled in rich detail</li> <li>Highly detailed farm branch activities (e.g. intensities for arable and grass crops,     differentiated feeding schemes for all animal types accounting for lactation/feeding     phase, etc.)</li> <li>The machinery park is available in different mechanization levels</li> <li>Environmental accounting modules including the flow from different nitrogen compounds, CO2eq, phosphorus compounds</li> <li>A wide range of agri- and agrienvironmental policies including CAP, German implementation     of Nitrate Directive, agri-environmental schemes, etc.</li> <li>Multiple biodiversity indicators </li> <li>Parameterized for multiple countries besides Germany it includes Switzerland, Norway, Netherlands</li> <li>Deterministic or stochastic programming version. The latter         treats all variables as state dependent, allows for sceneario tree         reduction and covers different risk measures (value at risk, MOTAD         ...)</li> </ul> <p>For the German version, the model is parameterized  using highly detailed farm planning data provided by KTBL in combination with farm structural statistics. It offers a complementary approach to other farm scale models used in the institute such as the farm group models integrated in CAPRI or FADN based farm-scale progamming models which both are comparative-static, calibrated against observed farm programs with Positive Mathematical Programming while being far less detailed with regard to technology, and not comprising explicit investement decisions.</p> <p>The model is realized in GAMS, solved with the industry MIP solver CPLEX, linked to a Graphical User Interface realized in GGIG and hosted on a Software Versioning System. Design of experiments, building on R routines directly called from GAMS, can be used in combination with farm structural statistics to systematically simulate different farm realizations (assets, farm branches) and boundary conditions such as input and output prices or emisisons ceilings using a computing server to solve several instances in parallel. That approach has e.g. been used to estimate a statistical meta model for Marginal Abatement Costs of Green House Gases from dairy farms. Code development and testing follows agreed upon guidelines.</p>"},{"location":"Contact/contact/","title":"Contact","text":"<p>Institut f\u00fcr Lebensmittel und Ressourcen\u00f6konomik (ILR) Economic Modeling of Agricultural Systems Nussallee 19 D-53115 Bonn  </p> <p>E-Mail: FarmDyn@ilr.uni-bonn.de</p>"},{"location":"FarmDynDocumentation/DownloadDocumentation/","title":"Download Documentation","text":"<p>Information:</p> <p>The option to download the documentation as .pdf or .docx is currently not working</p>"},{"location":"FarmDynDocumentation/DownloadDocumentation/#download-documentation-as-pdf","title":"Download Documentation as .pdf","text":""},{"location":"FarmDynDocumentation/DownloadDocumentation/#download-documentation-as-docx","title":"Download Documentation as .docx","text":""},{"location":"FarmDynDocumentation/Data/Data_Collection/","title":"Data Collection","text":"<p>FarmDyn sources it's data from online databases, books and scientific literature. In the German version, it heavily relies on data for the agricultural sector from the \"Kuratorium f\u00fcr Technik und Bauwesen in der Landwirtschaft\" (KTBL) for:</p> <ul> <li> <p>Farm planning data: for example, work steps in crop production, feed ratios in animals based on the development stage, variable costs for all production activities, etc.</p> </li> <li> <p>Investment data: this includes prices and technical information on buildings and machinery.</p> </li> <li> <p>Prices: both input and output prices from KTBL are used in the default setting in FarmDyn, however, can be adjusted to each specific case study</p> </li> </ul> <p>In addition to the KTBL data, FarmDyn uses data from scientific literature and other publicly available policy briefs for:</p> <ul> <li> <p>Policy: relevant parameters for policy assessment such as, the CAP based greening, agri-environmental schemes, and the Fertilization Ordinance</p> </li> <li> <p>Emission factors: information on disaggregated GHG emissions as well as data on particulate matter, nitrate leaching, etc. for all farming activities.</p> </li> <li> <p>Biodiversity indicators: data from scientific literature to determine three different biodiversity indicator.</p> </li> </ul> <p>The exact data sources are mentioned and documented in the GAMS code such as seen below:</p> <pre><code>*--- Cattle, partial emission factor for NH3-N from housing (related to TAN) in kg kg-1\n*     Haenel et al. (2018), p. 108\n\n   $$iftheni.cattle \"%cattle%\"==\"true\"\n\n      p_EFSta(\"NH3\",\"LiquidCattle\")       = 0.197;\n</code></pre> <p>As most data is freely available online, there are no limitations in most configurations of the model. However, some of the data used in projects is under copyright protection and hence prevents the use of certain parts of modules.</p>"},{"location":"FarmDynDocumentation/Data/data_flow/","title":"Data flow","text":"<p>Abstract This section provides an overview over the general data flow within the model. It addresses all relevant information related to data sourcing/collection, data processing pre- and during the simulation and the structure of the database.</p> <p>Data in Farmdyn is primarily collected from books, literature and online databases. The collected data populates directly the exogenous parameters or is processed in order to be harmonized with data from other sources (figure 1). The parameters are stored in .gms or .gdx files, where each file deals with a specific domain of the farm. This includes, for example, cattle.gms, which stores data on all kind of information for dairy, beef and mothercow farms, or crops_de.gms which stores and processes information for crops and cropping activities. The database is not only domain specific but also country specific. The suffix _de in the name of crops_de.gms, for instance, indicate that the parameterization with this file would provide crop information for German conditions. For some domains, FarmDyn also contains information for the Netherlands, Norway, and Swizz. In line with the idea of modularity in FarmDyn, each data file in the database corresponds to a certain module. This allows to call only those data files which are necessary to run a simulation which was set-up in the GUI configurator. Parameters from the called database are then processed further in order to fit to the defined model configuration and can then be used in the simulation run.</p> <p> Figure 1: General data flow  in FarmDyn Source: Own illustration</p>"},{"location":"FarmDynDocumentation/Data/data_processing/","title":"Data processing","text":"<p>There are multiple stages in the modelling sequence where data is processed to fit the requirements of the model and the configuration of the user. Before the simulation phase, the collected data has to be harmonized in order to fulfil the requirements of the model with respect to e.g. time (yearly, monthly, bi-weekly), disaggregation of production stages of animals (calves, heifers, etc.), and many more. In addition, parts of the database can be selected in order to process non-used parts of the database. This pre-simulation processing is further described in the section Build data. During the simulation phase, the configuration made by the user in the Graphical User Interface triggers another data processing step, where the required data is retrieved from the databases and further processed. This is described in the section Coefficient generator.</p>"},{"location":"FarmDynDocumentation/Data/data_processing/#build-data-user-or-ktbl-defined-data-files","title":"Build data - User or KTBL defined data files","text":"<p>As a long term goal, the FarmDyn crew plans to develop a flexible construction of the database in order to facilitate the use of FarmDyn for external users. Thereby, FarmDyn can be more easily adapted to other countries with different price/cost and policy structures.</p> <p>Currently, FarmDyn provides the option to construct data sets for the arable crops. We differentiate here between the \"User defined\" and \"KTBL defined\" construction of the crop file. In the GUI you can find the different options to generate the data files as seen in the picture below:</p> <p> Figure 1: Build data in the GUI Source: Own illustration</p> <p>Each option to generate a new file for the database is presented in the following.</p>"},{"location":"FarmDynDocumentation/Data/data_processing/#user-defined-files","title":"User defined files","text":"<p>For each data file which is to be adapted to a certain region, the user can alter the default values given in the pre-set default file. For example, crops has the default data for Germany given in the file cropsData_DE_Default.gms, which can be copied and changed in order to fit to crop data from other countries/regions and their corresponding agronomic and policy related differences. This file is then used to generate a .gdx file, which can be chosen in the GUI to introduce the specific crops.</p> <p> Figure 1: User defined crop file Source: Own illustration</p>"},{"location":"FarmDynDocumentation/Data/data_processing/#ktbl-defined-files","title":"KTBL defined files","text":"<p>The KTBL database provides detailed data for 145 crops under conventional and organic production. To prevent large amounts of data from being included into FarmDyn, required crops can be selected within the build-data process. The file build_data_KTBL.gms first includes data for all crops available in the KTBL database (described in the section Database and model setup.) and thereafter generates subsets based on the crop selection. The corresponding data is stored in two .gdx files, which are later used in the model run.</p> <p> Figure 2: Crop selection for KTBL defined files Source: Own illustration</p>"},{"location":"FarmDynDocumentation/Data/data_processing/#coefficient-generator-concept-and-file-structure","title":"Coefficient generator - Concept and file structure","text":"<p>The coefficient generator comprises a number of small modules, realised in GAMS, which define the various exogenous parameters comprised in the template. It is designed such that it can generate from a few central characteristics of the farm (herd size, current milk yield, existing stables and their construction year, labour force and available land) and the realised crop yields a plausible set of coefficients for the template model. The coefficient generator can also be set-up to load parameters for a specific region.</p> <p>The coefficient generator is divided in:</p> <ul> <li> <p>Beef:: length of production, costs per year and animal,     and average age of animals to determine exact LU</p> </li> <li> <p>Buildings: includes bunker silos for silage maize and     potatoes.</p> </li> <li> <p>Calves:: length of production, costs per year and animal,     and average age of animals to determine exact LU</p> </li> <li> <p>Cows: cows, heifers and calves are defined that have different     milk yield potentials. Additionally, a maximum number of lactation     is defined. It depends on the milk output level of the lactating     cows (diminishes with increasing milk output potential).</p> </li> <li> <p>Credit: different credit types are defined. These vary by     interest rate and payback time.</p> </li> <li> <p>Cropping: defines different activities for cash-crop production     with specific restrictions concerning crop rotation, fertilizer     demand and yield potentials.</p> </li> <li> <p>Initial stables: Stable size and types, capacities and calculation     of required stables places.</p> </li> <li> <p>Environmental accounting: defines environmental impact due to     manure and fertiliser application.</p> </li> <li> <p>Farm constructor: the farm constructor defines the relationships     between benchmark data of the farms and production specific     endowments e.g. of land, stables and machinery in the initial     situation.</p> </li> <li> <p>Farm_Ini: Initialises the farms land endowment and plot     distribution</p> </li> <li> <p>Feeds: possible fodder compounds are listed with their specific     contents of ingredients (N, C, DM, XP,...).</p> </li> <li> <p>Fermenter_tech: includes all data regarding the technical     aspects of the biogas fermenter, the different inputs and their     related biogas yields.</p> </li> <li> <p>Fertilising: defines coefficients for various application     techniques for organic and synthetic fertilisers.</p> </li> <li> <p>Greening: Adds the restrictions of the CAP     Greening into the model.</p> </li> <li> <p>Ini_herds: it defines the initial herds of the farm.</p> </li> <li> <p>Labour: defines labour needs on a monthly basis for herds and     crops and wages for the off-farm work.</p> </li> <li> <p>Mach: defines the different types of machinery that are     available for the farmer and it quantifies the useful lifetime     (defined according to years or on hourly basis) as well as     investments and variable costs.</p> </li> <li> <p>Manure: quantifies amount of animal excreta with respect to     livestock category. For cows manure amount is controlled by yearly     milk output level. Furthermore, coefficients for different manure     storage and application types are derived by this module.</p> </li> <li> <p>Pigs: defines output coefficients, production lengths and other     variable costs for fatteners and sows.</p> </li> <li> <p>Prices: different default values are defined if prices for     variables are not defined by the GUI.</p> </li> <li> <p>Prices_eeg: contains the prices applied in the different EEGs     as well as investment prices for different biogas plant parts.</p> </li> <li> <p>Requ: definitions of requirement functions for lactating cows in     relation to their milk yield, live weight etc., as well as for     heifers and calves are included in this module.</p> </li> <li> <p>Silos: in this module the definition of different types of     surface reservoirs for liquid manure is set. It differentiates     concerning capacity and related investment costs. Furthermore,     additional costs of specific coverage types of the surface manure     reservoirs are defined for straw coverage and coverage with foil.</p> </li> <li> <p>Social_accounting:: conversion of animal output in calories and proteins</p> </li> <li> <p>Stables: stable types with stable places and required workload     for the respective stables for all herd types</p> </li> <li> <p>StochProg: defines the decision tree and further GAMS symbols     used in the stochastic programming version</p> </li> <li> <p>Tech: defines all machinery, crop specific operation     requirements and field working days.</p> </li> </ul>"},{"location":"FarmDynDocumentation/Data/database/","title":"Database","text":"<p>The database is located in the \\dat folder and contains all the relevant information used in FarmDyn. It contains country or region specific agronomic, policy or emission data, which are denominated with the suffix of the corresponding country. In the example below, you can see files denominated with a suffix _de for Germany (Deutschland) and _no for Norway. Further, most data files are written in the .gms files, however, some of the data is coming from pre-processing steps and are given by .gdx files.</p> <p>In addition to the data used in the agronomic, policy and emission domain of FarmDyn, the farm population can be generated in the file farmData_de.gms or any copy of it to generate a gdx file with the farm population.</p> <p> Figure 2: File structure with exemplary snippet Source: Own illustration</p>"},{"location":"FarmDynDocumentation/Data/database/#ktbl-database","title":"KTBL Database","text":"<p>The KTBL database reports detailed data for 145 crops, including for example main and catch crops under conventional and organic production and different tillage systems (till,mintill,notill). The data includes information on machine applications and related resource requirements, revenues and direct costs as well as agronomic information required in FarmDyn. A list of all crops and available combinations of crops, tillage and farming system (org,conv) are provided in the file c_s_t_i.gms. The KTBL database reports different implementations of a crop, which are associated with different machine requirements, revenues and costs (e.g. irrigated vs. non-irrigated cultivation, different processing and marketing options). In the file, a standard implementation is selected for each available combination of crop, tillage and farming system which can be adapted to specific needs.</p>"},{"location":"FarmDynDocumentation/Data/database/#revenues-and-direct-costs","title":"Revenues and direct costs","text":"<p>For each available combination of crops, tillage and farming system, detailed information on yields, prices as well as expenses for agricultural contractors and direct costs (e.g. planting materials, fertilizers and pesticides) are included in Revenue_directcosts/crops.gdx. The file revenues_directcosts.gms loads and processes the data to prepare its use in FarmDyn. The processed data is stored in gams/ktbl/revenues_directCosts.gdx and later accessed by the build-data processing (described in the section Data processing).</p>"},{"location":"FarmDynDocumentation/Data/database/#machine-applications-and-related-resource-requirements","title":"Machine applications and related resource requirements","text":"<p>The KTBL database reports for each crop required field operations (e.g. tillage, sowing) and related machine applications.  Data covers resource requirements and costs of machine applications, including, for instance, labor requirements, machinery depreciation and costs for maintenance, lubricants and fuel. All data are provided for each available combination of crops, farming and tillage system and are differentiated by mechanization levels, which reflect substitution possibilities between labor and capital and costs in crop production. Labor requirements and costs of machine applications are highly dependent on plot sizes and farm-plot distances. A regression model is implemented, expressing labor and resource requirements of machine applications as a function of plot sizes and farm-plot distances (Heinrichs et al 2021). Thereby, plot sizes of up to 40ha and farm-plot distances of up to 30km are considered. The data is stored in KTBL_to_FarmDyn\\KTBL_Data and processed by variable_machineCosts.gms. An overview of the structure of the machinery data is given in the file Summary_structure_KTBL_Data.xlsx.</p>"},{"location":"FarmDynDocumentation/Data/database/#agronomic-data","title":"Agronomic data","text":"<p>The data for each crop is supplemented by detailed agronomic information, including for example maximum rotational shares, feeding attributes and N fixation of legumes. The data is stored in multiple .gms files (e.g. biogas_data.gms, crop_dat_farmDyn.gms, feedContent_data.gms). The agronomic data is imported from online databases, books and scientific literature. The exact data sources are mentioned and documented in the GAMS code. All crops are further subdivided into multiple subsets (crops_subsets_FarmDyn.gms) to ease data processing in FarmDyn.</p>"},{"location":"FarmDynDocumentation/Data/database/#data-aggregation","title":"Data aggregation","text":"<p>Both, the agronomic data as well as the data related to machine applications is processed and summarized in the file ktbl_to_farmdyn.gms. The file generates a large .gdx file gams/ktbl/ktbl.gdx, containing relevant data for all crops. The file is later accessed by the build-data processing.</p>"},{"location":"FarmDynDocumentation/Data/database/#implementation-of-new-crops","title":"Implementation of new crops","text":"<p>The KTBL data can be adapted to individual requirements and new crops can be introduced using the file \"implement_new_crops.gms\". An example is presented. Thereby, it is important to introduce all relevant data for the new crop. The file is called by revenues_directCosts.gms and by ktbl_to_farmdyn.gms.</p>"},{"location":"FarmDynDocumentation/KeyFeatures/calibration/","title":"Calibration","text":""},{"location":"FarmDynDocumentation/KeyFeatures/calibration/#general-concept","title":"General concept","text":"<p>In order to generate a reasonable baseline for policy analysis, FarmDyn provides the option to calibrate the model to observed farms. The calibration is implemented as a bi-level optimization approach. The bi-level optimization approach is segmented in an upper and lower problem. The upper problem represents the minimization of the deviation between observed values and previously fixed values. These fixed values against which the model is calibrated against, can be set on the one hand by the user and on the other hand are taken from key parameters in FarmDyn. The user can define crop rotations and the number of animals. Data on  prices for both input and output, yields, labour coefficients, feeding coefficients are used and adapted to steer the FarmDyn model to reproduce the observed crop rotations and animal numbers. The lower problem of the bi-level optimization process is the FarmDyn model itself.</p> <p>For a general introduction of the calibration method in FarmDyn you can refer to:</p> <p>Britz, W. (2021): Automated Calibration of Farm-Sale Mixed Linear Programming Models using Bi-Level Programming, German Journal of Agricultural Economics, 70(3): 165-181.</p>"},{"location":"FarmDynDocumentation/KeyFeatures/calibration/#small-user-guide","title":"Small user guide","text":"<p>In the figure below you see the set-up of the calibration process. In the \"File with calibration bounds\" you can select your file in which the calibration targets for crop rotations and animal numbers are set. Further, you can set the calibration bounds for yields, output prices, costs, input prices, feed coefficients and labour coefficients. The values which can be steered by the user give a +/- percentage deviation of given FarmDyn parameters. Eventually, one can set the lower bound on the objective function. This is realized by using the overall farm profit from a \"normal\" solve, which then can be enables to define a lower bound on the objective function.</p> <p> Figure 1: GUI calibration options Source: Own illustration.</p> <p>The calibration results are stored in a .gdx container which can be called in the GUI to simulate the given farm.</p> <p> Figure 1: GUI calibration options Source: Own illustration.</p>"},{"location":"FarmDynDocumentation/KeyFeatures/dynamics/","title":"Dynamic Character of FarmDyn","text":"<p>Abstract FarmDyn can be run in multiple dynamics ranging from the myopic view of a short run/ comparative-static version where only one years is simulated to a fully dynamic version which optimizes over all years. The current version is only tested for the comparative static case</p>"},{"location":"FarmDynDocumentation/KeyFeatures/dynamics/#comparative-static-version-and-short-run","title":"Comparative Static Version and Short-Run","text":"<p>The short-run version considers only one year and does not comprise a liquidation of the enterprise. The comparative static version replaces the herd dynamics by a steady state model where, for example, the cows replaced in the current year are equal to the heifers in the current year, which in turn are equal to the calves raised in the current year. In the comparative static mode, the vintage model for investments in buildings and machinery is replaced by a setting in which the investment costs are related to one year. Nevertheless, the binary character can be maintained.</p>"},{"location":"FarmDynDocumentation/KeyFeatures/dynamics/#the-fully-dynamic-version","title":"The Fully Dynamic Version","text":"<p>The fully dynamic version optimises the farm production process over time in a fully dynamic setting, i.e. all time points are simultaneously considered. Connecting different modules over time (t1-tn) allows considering biologic and economic path dependencies.</p> <p>The temporal resolution varies across different parts of the template module. Cropping decisions are annually implemented, whereas the intra-year resolution of the herd size module can be flexibly chosen by the user with a minimal resolution of one month.</p> <p>Concerning fodder composition, decision points in each year are every three months. This provides the decision maker a more flexible adjustment to feed requirements of the herd (conditional on lactation phase), his resources and prices respectively availability of pasture, silage and concentrates. Furthermore, as stated in the manure module, the applications of manure or synthetic fertilisers, as well as the stored manure amounts on farm are implemented on monthly level.</p> <p>The optimal production plan over time is not simulated in a recursive fashion from year to year, but all variables of the planning horizon are optimised at once. Consequently, decisions at some point in time also influence decisions before and not only after that point. For instance, an increase in the herd at some point might require increased raising processes before.</p>"},{"location":"FarmDynDocumentation/KeyFeatures/modularity/","title":"Modularity","text":""},{"location":"FarmDynDocumentation/KeyFeatures/modularity/#modularity-concept-in-farmdyn","title":"Modularity Concept in FarmDyn","text":"<p>Russel (2012) describes the general idea of modularity as following: \"Modularity describes specific relationships between a whole system and its particular components. A modular system consists of smaller parts (modules) that fit together within a predefined system of architecture. Modules feature standardized interfaces, which facilitate their integration with the overarching system architecture. A key feature of each module is that it should encapsulate (or \u2018black box\u2019) its messy internal details [\u2026] to display only a consistent interface. The designers of modular systems are therefore able to swap modules in a \u2018plug-and-play\u2019 manner, which increases the system\u2019s flexibility.\u201d</p> <p>In line with this broad definition and the description of preferred generic and modular implementations of bio-economic farm-scale models (Britz et al. 2021), FarmDyn is structured as a modular system where each module comprises a block of equations and variables which can be activated depending on the user case. Practically, each module captures a specific farm management or methodology domain within a file. Further, the definition of parameters is either done in a module if it is only used in that specific file or is organized globally in the set and parameter declaration module, templ_decl.gms. Each module can be either a stand alone module or is linked to other modules and grouped together to build a specific aspect of the farm, e.g. the farm branch, or the core model. To illustrate the idea of the modular structure and the different groupings, we can look at the following graph:</p> <p> Figure 1: Depiction of the modular structure of a dairy farm which has to comply with the greening obligation and is able to use agri-environmental measures on-farm. Source: Own illustration.</p> <p>The core model is composed of three modules, which are always activated regardless of any other set-up option in the Graphical User Interface (GUI). The three modules build the base of almost all real-life farms with an economic module, also containing the objective function, the labour module for the simulation of on- and off-farm labour use, and the general cropping module, which determines the land use of arable and grassland on-farm.</p> <p>Other grouped modules build the basis for the different branches in FarmDyn. This includes the dairy branch, the mothercows branch, the beef branch, the sows branch, the fattners branch, and the biogas branch. Each of the branches is based on at least two modules, with some of the branches sharing a module, such as all livestock branches sharing the general herd module.</p> <p>Next to the grouped modules, there are stand-alone modules which comprise only a specific topic, such as the greening module or the agri-environmental scheme module.</p>"},{"location":"FarmDynDocumentation/KeyFeatures/modularity/#modularity-data-and-reporting-structure","title":"Modularity, Data and Reporting Structure","text":"<p>The modular structure does not only require domain separated variables and equations files, but has to be reflected in the data base/ processing as well as the reporting of simulation results. This is illustrated by the following modified figure, by Britz et al. (2021):</p> <p> Figure 2: Variable and equation part (core model) embedded in the data and reporting structure. Source: Taken and modified from Britz et al. (2021)</p> <p>The figure shows that each module or group of modules provides their own data set including the pre-processing of the data and additional options for the model set-up in the GUI. Further, in addition to the provided data set each module comes together with a result and reporting section to facilitate the result analysis.</p>"},{"location":"FarmDynDocumentation/KeyFeatures/modularity/#list-of-current-grouped-modules-and-the-individual-modules","title":"List of Current Grouped Modules and the Individual Modules","text":""},{"location":"FarmDynDocumentation/KeyFeatures/modularity/#grouped-modules","title":"Grouped Modules","text":"Name Type File/s Core Model templ.gms labour_module.gms general_cropping_module.gms Branch general_herd_module.gms cattle_module.gms manure_module.gms Branch general_herd_module.gms cattle_module.gms manure_module.gms Branch general_herd_module.gms cattle_module.gms manure_module.gms Branch general_herd_module.gms pig_module.gms manure_module.gms Branch general_herd_module.gms pig_module.gms manure_module.gms Branch biogas_module.gms manure_module.gms"},{"location":"FarmDynDocumentation/KeyFeatures/modularity/#individual-modules","title":"Individual Modules","text":"Module Name File Description templ.gms The template/economic module is the leading file to collect all other modules. In addition, the primary economic aspects of the model are defined in the module. This includes: (1) the objective function, (2) the cash flow structure, (3) the income tax calculation, (4) the premium payments, (5) the sales and production levels, (6) the variable cost structure, and (7) the investment costs. general_cropping_module.gms The cropping module optimises the cropping pattern subject to land availability, reflecting yields, prices, machinery and fertilising needs, and other variable costs for a selectable list of arable crops. The crops can be differentiated by production system (conventional, organic), tillage (plough, minimal tillage, no tillage) and intensity level (normal and reduced fertilisation in 20 % steps). Machinery use is linked to field working-day requirements depicted with a bi-weekly resolution during the relevant months. Crop rotational constraints can be either depicted by introducing crop rotations or by simple maximal shares. The model can capture plots which are differentiated by soil and land type (grassland, arable land and pasture), size and distance. labour_module.gms The labour module optimises work use on- and off-farm with a monthly resolution, depicting detailed labour needs for different farm operations, herds and stables, management requirements for each farm branch, and the farm as a whole. Off-farm work distinguishes between half- and full-time work (binaries) and working flexibly for a low wage rate. general_herd_module.gms The general herd module captures all facets of a herd which are not animal type specific: (1) It integrates the intra- and inter-year dynamic of the herd for all types of animals: dairy, mothercows, heifers, bulls, male and female calves, sows, fattners, and piglets. (2) It determines the required stable space based on the herd size and steers the buying decision and contains the stable inventory. (3) It implements the excretion quantities and their associated nutrient quantities for all animal types on a monthly basis. cattle_module.gms The cattle module is closely related to the general herd module. It describes the demographic relations between cattle types (dairy, mothercows, male and female calves, heifers, young bulls) on the farm. The cattle feed requirements are calculated considering the animals performance and the lactation phase of cows. The requirements can be met via a mix from own produced and purchased fodder, concentrates and grazing from pastures. pig_module.gms The pig module captures the feeding activities for all pig types (piglets, sows, fattners) based on their production phase. It considers both purchased and own produced fodders. It further calculates the number of new piglets at the start of the simulation based on the number of sows. manure_module.gns The manure module captures all relevant movements of organic fertiliser and their nutrients after excretion. This includes the investment in storage, the type of storage (subfloor storage or silo), the storage capacity for all organic fertiliser sources (cattle, pigs, biogas plant, imports), their respective nutrients, losses of nutrients due to emissions, and exporting organic fertiliser. biogas_module.gms The biogas module defines the economic and technological relations between components of a biogas plant with a monthly resolution, as well as links to the farm. Thereby, it includes the statutory payment structure and their respective restrictions according to the German Renewable Energy Acts (EEGs) from 2004 up to 2014. The biogas module differentiates between three different sizes of biogas plants and accounts for three different life spans of investments connected to the biogas plant. Data for the technological and economic parameters used in the model are derived from KTBL (2013) and FNR (2013). The equations within the template model related to the biogas module are presented in the following section. env_acc_module_de.gms The environmental accounting module utilises commonly applied methodology for the quantification of methane (CH4), ammonia (NH3), nitrous dioxide (N2O), nitrogen oxides (NOx) and elemental nitrogen (N2), as well as particulate matter formation (PM10 and PM2.5), as laid down in IPCC (2019) and EMEP (2013, 2016). N and P lost through erosion, run-off and leaching are calculated using methodology from Richner et al. (2014) and Prasuhn (2006). Upstream emissions from the provision of mayor farm inputs and services can be included via the ecoinvent database c. Emissions are characterised at midpoint level using characterisation factors from Huijbregts et al. (2016). fertord_module.gms The fertilisation ordinance (FO) module integrates the national implementation of the Nitrates Directive into Farmdyn. It covers the most prominent measures of the FO, namely: (1) the nutrient balance restrictions, (2) an organic nitrogen application threshold, (3) the binding fertiliser planning, (4) the required manure storage capacities, (5) the banning periods for fertiliser application, (6) the restriction of fertiliser application in autumn, (7) the low-emission manure application techniques and (8) the obligatory catch crop cultivation. fin_cashflow.gms The financial cash flow captures all types of credits, repayments, interest payments and received interests. It is only active in a fully dynamic version. social_acc_module.gms The social accounting module contains information about the protein and calorie production on-farm both used for feeding and also as human edible quantitiy. greening_module.gms The greening module captures the greening requirements of the Common Agricultural Policy of the European Union (CAP). It integrates the key measures crop diversification (considering multiple requirement tiers based on arable and grass land endowment) and ecological focus areas (mainly legumes) into FarmDyn. aes_module_de.gms The agri-environmental scheme (AES) module contains optional measures for farmers from the CAP Pillar II. The AES design in FarmDyn follows the structure of the German state of North Rhine-Westphalia including (1) diverse crop rotation options, (2) payments for flower strips and (3) catch crop cultivation. stochprog_module.gms"},{"location":"FarmDynDocumentation/KeyFeatures/popsimu/","title":"Farm population","text":""},{"location":"FarmDynDocumentation/KeyFeatures/popsimu/#introduction-to-the-simulation-of-farm-populations","title":"Introduction to the simulation of farm populations","text":"<p>FarmDyn is a single-farm level model. This provides an ideal option to assess certain policies or technologies given a few suitable case study farms. However, often the research question at hand wants to answer questions related to certain populations or want to examines the effect on many heterogenous farms. In research questions such as that, case study farms are not capable to capture all relevant aspects. In order to address exactly this heterogenous effect of different farms within a population or the population as a whole, FarmDyn offers to simulate farm populations. Farm populations are introduced as single farms with each one distinct from another. The relevant characteristics which distinguish each of the farms are the:</p> <ul> <li>Farm type</li> <li>Output levels (crop yields and animal outputs)</li> <li>Number of labor units on farms</li> <li>Arable- and grasland endowments</li> <li>Number of animals</li> <li>Initial inventory of stables</li> </ul>"},{"location":"FarmDynDocumentation/KeyFeatures/popsimu/#implementation-in-the-model","title":"Implementation in the model","text":"<p>The file to generate a farm population can be found under /dat with an farm population example in the file farmData_de.gms. In that file you can adjust the number of farms your populations has and assign values to the parameters from the list above. After filling in all relevant information in the file you can run the file to generate a .gdx container which can be used as the farm population in FarmDyn.</p> <p>In a second step you can call upon the generated farm population in the GUI as seen in the figure below. You can choose here your relevant Farm sample file which opens up the option to choose certain farms to simulate or to automatically run all farms sequentially. Note, that you have to set the FarmDyn task from Single farm run to Farm sample run on the left hand side of the GUI.   </p> <p> Figure 1: GUI Farm sample options Source: Own illustration.</p>"},{"location":"FarmDynDocumentation/KeyFeatures/risk/","title":"Dealing with risk and risk behaviour: deterministic versus stochastic model versions","text":"<p>Prototype feature</p> <p>This feature has not been thoroughly tested and should be used with caution.</p> <p>Abstract The default layout of the model maximises the net present value (NPV) over the simulation horizon in a deterministic setting. The stochastic programming extension introduces decision trees based on mean reverting processes for the output and input price levels and renders all variable state contingents, calculating the option value of full flexibility in management and investment decisions over the simulation horizon. An experimental extension allows rendering additionally yields stochastic. A tree reduction algorithm allows exploiting the outcome of large-scale Monte-Carlo simulations while avoiding the curse of dimensionality. Besides risk neutral maximisation of the expected NPV, different types of risk behaviour such as MOTAD, Target MOTAD or value at risk can be used in conjunction with the stochastic programming extension.</p>"},{"location":"FarmDynDocumentation/KeyFeatures/risk/#overview","title":"Overview","text":"<p>The FarmDyn model comprises since the first versions optionally stochastic components. In the current version, two set-ups are possible: 1.  A deterministic version 2.  A fully stochastic programming version where all variables are state contingent and unbalanced stochastic trees are used. In the deterministic version, no parameter is stochastic and hence no variable state contingent. The equations, variables and certain parameter carry nevertheless indices for nodes in the decision tree and state of nature (SON), but these refer in any year to a deterministic singleton. In the partly stochastic simulation version of the FarmDyn model, farm management and investment characters with a longer-term character are not state contingent and hence must allow managing all SONs in any year. For example, in case of machine depreciation based on use, the investment decisions must ensure the maximum use in any year and SON. The fully stochastic programming (SP) version of the model introduces scenario trees and renders all variables in the model stage contingent to yield a fully dynamic stochastic approach. That is only feasible in conjunction with a tree reduction approach: even if we would only allow for two different states of nature in each year (= decision nodes), we would end up after twenty years with 210 \\ ~ 1 million leaves in the trees. Given the number of variables and equations in any year, the resulting model would be impossible to generate and solve. In the following, we briefly discuss the changes to model structure and how the decision tree and the related random variable(s) are constructed. The SP version of the model can be combined with a number of risk behavioural models to maximise the expected utility or an implementation of prospect theory. Given the complex character of the remaining modules in the model, only such behavioral models were chosen which can be implemented in a MIP framework, hence, non-linear approaches such as an E-V approach are not considered. The available risk models (value at risk (var), conditional value at risk, MOTAD and target MOTAD) are discussed in the risk behaviour section.</p>"},{"location":"FarmDynDocumentation/KeyFeatures/risk/#objective-function-in-the-deterministic-version","title":"Objective Function in the deterministic version","text":"<p>In the deterministic version of the model, we consider a maximisation of the NPV of the farm household income under a given discount rate. The farm is assumed to be liquidated at the end of the planning horizon, i.e. the cow herd, machinery and land are sold and loans are paid back. Any remaining equity is discounted to its NPV; therefore, a definition close to the flow-to-equity approach is used:</p> <pre><code>OBJE_           ..\n*\n       v_obje =L=\n                v_objeMean\n*\n*       --- penalty for negative deviation from mean NPV (similar MOTAD) or target MOTAD / ES\n*\n      + [ 0\n\n$ifi %stochProg%==true - v_expNegDevNPV * p_negDevPen  $ (not p_expShortFall)\n$ifi %stochProg%==true - v_expShortFall * p_negDevPen  $ (not p_expShortFall)\n$ifi %stochProg%==true + v_expShortFall * p_negDevPen  $ p_expShortFall\n        ] $ sum(t_n(tCur,nCur) $  (v_hasFarm.up(tCur,nCur) ne 0),1)\n    ;\n</code></pre> <p>Further on, the fully dynamic optimisation assumes that the decision maker is fully informed about the deterministic future such that the economically optimal farm plan over the chosen planning horizon is simulated.</p>"},{"location":"FarmDynDocumentation/KeyFeatures/risk/#the-stochastic-programming-version-with-full-stage-contingency","title":"The Stochastic Programming version with full stage contingency","text":"<p>As opposed to the deterministic version, in the SP version all variables are state contingent. The stochastic version considers different future developments over time, currently implemented for selected output and input prices, i.e. price paths, and crops yields. These paths do not need to have equal probability. The simulated paths can be mapped back into a distribution for a comparative-static stochastic experiment.</p> <p>The SP approach includes a decision tree that reflects decision nodes where each node can have multiple leaves with different probabilities of occurrence. All decisions are contingent on the SON in the current year, and decisions in subsequent years depend on decisions made on previous nodes (=stages) on the path to a final leave. In the SP, all production and investment decisions in any year are hence depicted as state-contingent, i.e. they reflect at that time point the different futures which lay ahead, including future management flexibility. Also the timing of investments is hence state contingent.</p> <p>All variables and equations carry the index nCur, which indicates the current node in the decision tree. Equally, the node needs to be linked to the correct year, which is achieved by a dollar operator and the t_n set, for instance as in the following equation which was already shown above. Whereas in the deterministic version, there is just one dummy node for each year, in the stochastic version, potentially different states and thus nodes are found for decision variables and equations in any one year. The revised objective function maximises the probability weighted average of the final liquidity for each final leave in the decision tree:</p> <pre><code>OBJE_           ..\n*\n       v_obje =L=\n                v_objeMean\n</code></pre> <p>The number of uncompressed scenarios to start with and the desired number of leaves in the final reduced tree are defined via the graphical user interface (GUI) if the SP module is switched on:</p> <p></p> <p></p> <p>That information enters the declarations in model\\templ_decl.gms. If the SP extension is switched off, there is only one node (which is indicated by a blank space, \" \") and the model collapses to a deterministic one:</p> <pre><code>$iftheni.sp not \"%stochProg%\"==\"true\"\n*\n*  --- dummy implementation of SP frameworK\n*      there is one universal node, i.e. that is the deterministic version\n*\n\n   set n \"Decision nodes in tree\" / \" \" /;\n   set t_n(t,n) \"Link betwen year and decision node\";\n   t_n(t,\" \") = YES;\n\n   set anc(n,n) \"Is the second node the node before first one?\";\n   anc(\" \",\" \") = YES;\n\n   set isNodeBefore(n,n) \"Is the second node before first one?\";\n   isNodeBefore(\" \",\" \") = YES;\n\n   set sameScen(n,n) \"The two nodes belong to the same scenario\";\n   sameScen(\" \",\" \") = YES;\n\n   set leaves(n) / \" \" /;\n\n\n   parameter p_probN(n);\n   p_probN(\" \") = 1;\n</code></pre> <p>The changes in the listing are minimal compared to the previous version without the SP extension, only one point more in each variable or equation name is included, which indicates the blank common node (between the dots), for example as following:</p> <p></p> <p>With the SP extension, information is needed about ancestor nodes and nodes before the current one:</p> <pre><code>$else.sp\n\n   $$evalglobal nt %lastYear%-%firstYear%+1\n   $$ifi \"%dynamics%\" == \"Comparative-static\" $setglobal nt 20\n   $$evalGlobal nNode (%nt%-1) * %nOriScen% + 1\n*\n*  --- sets and parameters are population in coeffgen/stochProg.gms\n*\n   set n /n1*n%nNode%/;\n   set t_n(t,n) \"Link betwen year and decision node\";\n   set anc(n,n) \"Is the second node the node before first one?\";\n   set isNodeBefore(n,n) \"Is the second node before first one?\";\n   set sameScen(n,n) \"The two nodes belong to the same scenario\";\n   set leaves(n);\n   parameter p_probN(n);\n\n$endif.sp\n</code></pre>"},{"location":"FarmDynDocumentation/KeyFeatures/risk/#generating-random-variables-and-the-decision-tree","title":"Generating Random Variable(s) and the decision tree","text":"<p>The generation of decision tree and related random variable(s) consists of three major steps:</p> <ol> <li> <p>Generation of a predefined number of scenarios which describe equally probable future developments for the random variables considered. In the resulting uncondensed tree, the probabilities of each node and of the resulting scenarios are identical.</p> </li> <li> <p>Generating a reduced decision tree from all possible scenarios where most of the nodes are dropped and the remaining representative nodes receive different probabilities.</p> </li> <li> <p>Defining the symbols in GAMS according to step 1 and 2.</p> </li> </ol> <p>As GAMS can become quite slow with complex loops, the first step is implemented in Java. Currently, two random variables (one for output and one for input price changes) are generated based on two independent logarithmic mean-reverting processes (MRPs), the log is introduced to avoid negative outcomes. The variance and speed of reversion are defined on the GUI as shown above, under an expected mean of unity. The starting price multiplier is also set to unity. Each path of input and output prices are simulated once in the SP. To these price developments, draws from yield distribution can be added. The Java program is called from GAMS to pass the information on the number of decision nodes (= simulated time points) and the desired number of scenarios to the program:</p> <pre><code>$iftheni.stochPrices not \"%StochPricesOutputs%\"==\"None\"\n    execute \"java -Djava.library.path=..\\gui\\jars -jar ..\\gui\\mrpfan.jar %nt% %nOriScen% %scrdir%\\\\mrp.gdx 1 1 %varOutputs% %lambdaOutputs% 2&gt;1\"\n    execute_load \"%scrdir%\\\\mrp.gdx\" p_randVar,tn,anc;\n    p_randVar(\"priceOutputs\",n) = p_randVar(\"P1\",n);\n$endif.stochPrices\n</code></pre> <pre><code>$iftheni.stochPrices not \"%StochPricesInputs%\"==\"None\"\n    execute \"java -Djava.library.path=..\\gui\\jars -jar ..\\gui\\mrpfan.jar %nt% %nOriScen% %scrdir%\\\\mrp.gdx 1 1 %varInputs% %lambdaInputs% 2&gt;1\"\n    execute_loadpoint \"%scrdir%\\\\mrp.gdx\" p_randVar,tn,anc;\n    p_randVar(\"priceInputs\",n) = p_randVar(\"P1\",n);\n$endif.stochPrices\n</code></pre> <p>The Java process stores the generated random developments along with the ancestor matrix in a GDX file. The following figure shows an example of a decision tree as generated by the Java program for five years and four scenarios, illustrated as a fan. The common root node 1, the only one in the first year, is on the left side of the Figure. The nodes 2, 5, 8, 11, 14 are in the second year. Each second year node has its own set of followers, and all nodes besides 1 have the same probability, here 20% as five nodes are present in any year.</p> <p></p> <p>:   Figure 8: Example of an input decision tree organised as a fan.     Source: Own illustration</p> <p>Increasing the number of years leads to a proportional increase in the number of nodes. For complex stochastic processes such as MRPs, many paths are needed, each reflecting a Monte-Carlo experiment, to properly capture the properties of the stochastic process. This leads to the curse of dimensionality, as the number of variables and equations in the model increases quadratic with the number of years and number of Monte-Carlo experiments. As MIP models are NP-hard to solve, that quickly leads to models which cannot be solved in any reasonable time. Hence, in a next step, the tree must be reduced to avoid that curse of dimensionality, achieved by using the SCENRED2 utility comprised in GAMS (Heitsch &amp; R\u00f6misch 2008, 2009). The algorithm deletes nodes from the tree and adds the probability of dropped nodes to a neighboring remaining one. The example in the Figure 2 below depicts a hypothetical tree after application of the tree reduction algorithm with four final leaves generated from the tree given in Figure 1. Each scenario starts with the same root node, 1, for which the information is assumed to be known for certain, i.e. the probability for this root node N1, which falls in the first year, is equal to unity and ends with one of the final leaves, 7, 10, 13 or 16. In the second year two nodes are kept in the example, each depicting possible states of nature with their specific followers while potentially differing in their probabilities. Node number 8 has a probability of 60% as it represents in the reduced tree three original nodes while node 11 has one of 40%. The strategy chosen for each of these nodes depends simultaneously on the possible future development beyond that node while being conditioned on the decisions in the root node (which itself depends on all follow up scenarios).</p> <p>:   Figure 9: Example of a reduced tree. Source: Own illustration</p> <p>The example can also help to understand better some core symbols used in the code and relations in the SP extension. The nodes remaining in the reduced tree are stored in the set nCur. The set t_n would match the first year with the first node, the second year with the nodes 8 and 11 etc. For the node 15, the ancestor set anc would be set to anc (n15, n11) to indicate that node 11 is the node before 15 on the scenario ending with leave 16. Isbefore (n16, x) would be true for x=16, 15, 11 and 1 and comprises the complete scenario ending with the final leave 16. The probabilities for node 8 and 11 must add up to unity as they relate to the same time point. The same holds for the node set (6, 9, 12, 15) for the third year. Hence, the decision at the root node 1 influences all subsequent scenarios, whereas the stage contingent decisions at node 8 influence directly the scenarios ending with leaves 7 and 10. The root node reflects all scenarios simultaneously and consequently an indirect influence between all nodes exists. Furthermore, in a programming context no backward or forward recursion solution tactic is possible to find the best strategy as the number of strategies is normally not countable (the solution space is bounded, but there exist typically an infinite number of possible feasible solutions). Finding the optimal (or a nearly optimal) a solution is further complicated by the fact that a larger number of variables have an integer or binary character. MIP problems are NP-hard, i.e. the solution time increases dramatically in the number of integers. This makes it especially important to find an efficient way to reduce the number of nodes considered to keep the solution time in an acceptable range. In the current implementation, the tree size which also determines the overall model size is steered by setting exogenously the number of final nodes.</p> <pre><code>$setglobal sr2prefix test\n$setglobal treeGen on\n$iftheni.runSR2 %treeGen%==on\n*\n*  --- scenario tree construction from fan\n*\n   $$libinclude scenRed2\n*\n*  --- information for SCENRED: option file and options from interface\n*\n   ScenredParms('sroption')       = 1;\n   ScenredParms('num_time_steps') = %nt%;\n   ScenredParms('num_nodes')      = card(n);\n   ScenredParms('num_random')     = %MRP%;\n   ScenredParms('num_leaves')     = %nOriScen%;\n   ScenredParms('visual_red')     = 1;\n   $$libinclude runScenRed2 %sr2Prefix% tree_con n anc p_probN ancRed p_probRed p_randVar\n\n$endif.runSr2\n\n   ;\n*\n*  --- load information from ScenRed2\n*\n   execute_load 'sr2%sr2Prefix%_out.gdx' ancRed=red_ancestor,p_probRed=red_prob;\n</code></pre> <p>Based on the information returned from the scenario reduction utility, the set of active nodes, nCur, is determined:</p> <pre><code>*  --- actives nodes are those which have an updated probability\n*\n   option kill=nCur;\n   nCur(n) $ p_probRed(n) = YES;\n*\n*  --- cleanse link between time points and nodes from unused nodes\n*\n   tn(tnum,n) $ (not nCur(n)) = no;\n*\n*  --- map into year set used by model\n*\n   $$iftheni.dyn \"%dynamics%\" == \"Comparative-static\"\n\n      option kill=t_n;\n\n      t_n(tCur,nCur) $ sum(tn(tnum,nCur) $ (tnum.pos eq %nt%),1) = YES;\n      alias(nCur,nCur1);\n      nCur(nCur1) $ (not sum(t_n(tCur,nCur1),1)) = no;\n\n      p_probN(nCur) = p_probN(nCur) * 1 / sum(nCur1, p_probN(nCur1));\n\n      option kill=anc;\n      sameScen(nCur,nCur) = YES;\n      anc(nCur,nCur)     = YES;\n      isNodeBefore(nCur,nCur) = YES;\n      leaves(nCur) $ t_n(\"%lastYearCalc%\",nCur) = YES;\n\n      $$setglobal nt 1\n\n   $$else.dyn\n\n      t_n(tCur,nCur) $ sum(tn(tnum,nCur) $ (tnum.pos eq tCur.pos),1) = YES;\n      t_n(tBefore,\"n1\") = YES;\n\n*\n*     --- take over cleansed ancestor matrix and probabilities\n*\n      option kill=anc;\n      anc(nCur,nCur1) = ancRed(nCur,nCur1);\n      anc(\"n1\",\"n1\")    = YES;\n      p_probN(n)  = p_probRed(n);\n</code></pre> <p>A little bit trickier is to efficiently find all nodes that are before a given node in the same scenario (these are often nodes shared with other scenarios such as the root node, see Figure 9 above). This is achieved by an implicit backward recursion over a year loop:</p> <pre><code>loop(tCur,\n         loop(anc(nCur,nCur1),\n           isNodeBefore(nCur,nCur2) $ isNodeBefore(nCur1,nCur2) = YES;\n         );\n</code></pre> <p>As indicated above, the set anc (nCur, nCur1) indicates that decision node nCur1 is the node before the node nCur, i.e. they belong to the same scenario. That is used in lag and lead operators, e.g.:</p> <pre><code>hasFarmOrder_(tCur(t),nCur) $ (tCur(t-1) $ t_n(t,nCur)) ..\n\n       v_hasFarm(t,nCur) =L= sum(t_n(t-1,nCur1) $ anc(nCur,nCur1), v_hasFarm(t-1,nCur1));\n</code></pre> <p>The isNodeBefore(nCur,nCur1) relation depicts all nodes, nCur1, before node nCur in the same scenario, including the node nCur itself. An example gives:</p> <pre><code>*         --- steady state: starting herds before the first fully simulated year are equal to that one\n*\n      sum(t_n(tBefore,nCur1) $ sameScen(nCur1,nCur),v_herdStart(herds,breeds,tBefore,nCur1,m))\n              =E=  v_herdStart(herds,breeds,t,nCur,m);\n</code></pre> <p>Important Aspects to remember! </p> <p>1. Even if the program scales the drawn price changes such that their mean is equal to unity, this does not guarantee that the model, even without stage contingency, would perfectly replicate the deterministic version as the timing of the changes is also relevant (discounting, dynamic effects on liquidity etc.).          </p> <p>2. The normal case is that the objective value increases when considering stage contingency under risk neutrality. This is due to the effect that profits increase over-proportionally in output prices under profit maximisation.                                                   </p> <p>3. The solution time of the model can be expected to increase substantially with the SP extension switched on. MIP models are non-convex and NP-hard problems. To our knowledge there is no existing polynomial-time algorithm for MIP problem, which means that the solution time to optimality increases typically dramatically in the number of considered integers. Even small problems can take quite long to be solved even towards moderate optimality tolerances and not towards full optimality. This holds especially if the economic signal to choose between one of the two branches of a binary variable is weak, i.e. if the underlying different strategies yield similar objective values. This is unfortunately exactly the case where the SP programming approach is most interesting. If there is one clearly dominating strategy rather independent e.g. of a reasonable range of output prices, considering different futures inside that reasonable range is not necessary.      </p> <p>The interface allows to define the parameters of the logarithmic mean reverting processes with an expected mean and start value of log(1):</p> <p></p>"},{"location":"FarmDynDocumentation/KeyFeatures/risk/#introduction-of-the-random-variables","title":"Introduction of the Random Variable(s)","text":"<p>The notion random variable only implies that the variable has an underlying probability distribution and not that it is a decision variable in our problem. Consequently, the random variables are parameters in GAMS and are not declared as variables. As mentioned in the section above, the MRPs in the SP version of the model are simulated in Java and generate deviations around unity, i.e. we can multiply a given mean price level for an output and/or an input (e.g. defined by user on the interface) with the node specific simulated random price multiplier. If two MRPs are used, they are currently assumed to be uncorrelated. One path from the root to a final leave thus depicts a time series of input and output price deviations from the mean of the stochastic version.</p> <p>The random variable can impact either revenue, salRev_, by introducing state specific output price(s) and/or cost for buying inputs, buyCost_, by state specific input price(s):</p> <pre><code>salRev_(curSys(sys),t_n(tCur,nCur))   ..\n*\n       v_salRev(sys,tCur,nCur)  =e= sum(  (curProds(prodsYearly)) $ (v_saleQuant.up(prodsYearly,sys,tCur,nCur) ne 0),\n                                                v_salRevProds(curProds,sys,tCur,nCur));\n</code></pre> <pre><code>buyCost_(curInputs(inputs),curSys(sys),t_n(tCur(t),nCur)) $ (p_inputprice%l%(inputs,sys,t) $ (v_buy.up(inputs,sys,t,nCur)  ne 0))  ..\n\n       v_buyCost(inputs,sys,t,nCur) =e= p_inputprice(inputs,sys,t)\n$iftheni.sp %stochProg%==true\n      * ( 1 + (p_randVar(\"priceInputs\",nCur)-1) $ randProbs(inputs) )\n$endif.sp\n                                      * v_buy(inputs,sys,t,nCur);\n</code></pre> <p>The decision whether prices are treated as random variables is steered via the interface:</p> <p></p> <p></p> <p>In the case where neither input nor output prices are random a run time error will occur. The core branches are defined in coeffgen\\stochprog.gms:</p> <pre><code>$iftheni.stochPrices \"%StochPricesOutputs%\"==\"Core branch outputs\"\n*\n   $$ifi \"%farmBranchArable%\" == \"on\"   randProbs(set_crop_prods)  = yes;\n   $$ifi \"%pigHerd%\"          == \"true\" randProbs(set_pig_prods)   = yes;\n   $$ifi \"%farmBranchDairy%\"  == \"on\"   randProbs(set_dairy_prods) = yes;\n   $$ifi \"%farmBranchBeef%\"   == \"on\"   randProbs(allBeef_outputs)  = yes;\n\n$endif.stochPrices\n</code></pre> <p>That means that dairy production takes precedence over other branches and pigs over arable cropping, assuming that arable crops are typically not the core farm branch in mixed enterprises.</p>"},{"location":"FarmDynDocumentation/KeyFeatures/risk/#risk-behaviour","title":"Risk Behaviour","text":"<p>The model allows introducing four different risk behaviour options in the SP version in addition to risk neutral behaviour (None):</p> <p></p> <p>All risk measures relate to the distribution of the NPV, i.e. changes in expected returns aggregated over the full simulation horizon, and do not take fluctuations of the cash flow for individual years into account. This is reasonable as the farmer is assumed to have access to credits which can be used to overcome short-term cash constraints. The cost of using credits as a risk management option is considered endogenously in the model as farmers have to pay interest on these credits which reduces the NPV. Still, considering that risk is accessed here with regard to changes in accumulated final wealth over a long planning horizon is crucial when comparing the approach and results to risk analysis based e.g. on a comparative static analysis of yearly variance of gross margins.</p>"},{"location":"FarmDynDocumentation/KeyFeatures/risk/#motad-for-negative-deviations-against-npv","title":"MOTAD for Negative Deviations against NPV","text":"<p>The first and simplest risk model modifies the objective function, only: it maximises a linear combination of the expected NPV and the expected mean negative deviation from the NPV.</p> <p></p> <p>The formulation builds on MOTAD (Minimization of Total Absolute Deviations) as a linear approximation of the quadratic E-V model proposed by Hazell 1971. The approach was developed at a time where quadratic programming was still not considered feasible for even medium sized problems. Under normality, it can be shown that the absolute deviations and the variance show approximately a linear relationship, the factor between the two depends however in a non-linear way on the number of observations. Mean absolute deviations can also be understood as a robust estimate for the variance.</p> <p>Our approach builds on an often used modification by only considering down-side risk, i.e. only negative deviations from the simulated mean are taken into account:</p> <pre><code>negDevNPV_(nCur) $ t_n(\"%lastYearCalc%\",nCur) ..\n\n        v_objeN(nCur) + v_negDevNPV(nCur)  =G= v_objeMean;\n</code></pre> <p>This approach is especially relevant if the deviation above and below the objective function are not by definition symmetric. As the distribution of income itself is determined in our stage contingent approach endogenously, symmetry makes limited sense. The expected mean deviation is calculated as:</p> <pre><code>expNegDevNPV_ ..\n\n        v_expNegDevNPV =E= sum(nCur $ t_n(\"%lastYearCalc%\",nCur), v_negDevNPV(nCur)*p_probN(nCur));\n</code></pre> <p>And subtracted from the objective function (see equation OBJE_):</p> <pre><code>*       --- penalty for negative deviation from mean NPV (similar MOTAD) or target MOTAD / ES\n*\n      + [ 0\n\n$ifi %stochProg%==true - v_expNegDevNPV * p_negDevPen  $ (not p_expShortFall)\n$ifi %stochProg%==true - v_expShortFall * p_negDevPen  $ (not p_expShortFall)\n$ifi %stochProg%==true + v_expShortFall * p_negDevPen  $ p_expShortFall\n        ] $ sum(t_n(tCur,nCur) $  (v_hasFarm.up(tCur,nCur) ne 0),1)\n    ;\n</code></pre> <p>The reader should note that the standard MOTAD approach by Hazell and described in text books is based on expected gross margins and deviations thereof, whereas in this model an approach in the context of dynamic stochastic programming approach is used. The expected mean returns for each activity and related (co)variances are not known beforehand in our model such that an E-V approach would be numerically demanding. This holds especially for our large-scale MIP problem, such that avoiding quadratic formulations, as required by an E-V approach, has its merits. Finally, it should be noted that these equations are always active for information purposes. The weight in the objective is set to a very small number when other types of risk behaviour are simulated.</p>"},{"location":"FarmDynDocumentation/KeyFeatures/risk/#motad-for-negative-deviations-against-target","title":"MOTAD for Negative Deviations against Target","text":"<p>The only difference to the MOTAD against NPV option described before is that negative deviations are defined against a target set by the user. That target is based on a relative threshold multiplied with the simulated objective value in the case of no farming activity, therefore, income is only drawn from off-farm work, decoupled payments and interest. This income level is used as the absolute benchmark level which can be modified by the user with the percentage multiplier entered in the GUI. This effects the following equation:</p> <pre><code>shortFall_(nCur) $ (t_n(\"%lastYearCalc%\",nCur) $ (p_npvAtRiskLim gt 1))  ..\n\n        v_objeN(nCur) + v_shortFall(nCur) =G= p_npvAtRiskLim;\n</code></pre> <p>Using this information the expected shortfall is defined:</p> <pre><code>expShortFall_ $ ( p_expShortFall or p_maxShortFall ) ..\n\n        v_expShortFall =E= sum(nCur $ t_n(\"%lastYearCalc%\",nCur), v_shortFall(nCur)*p_probN(nCur));\n</code></pre> <p>The expected shortfall then enters the objective function.</p>"},{"location":"FarmDynDocumentation/KeyFeatures/risk/#target-motad","title":"Target MOTAD","text":"<p>The second option is what is called Target MOTAD in programming modeling. It has some relation to MOTAD as it also takes negative deviation from a pre-defined threshold into account, p_npvAtRiskLim*.</p> <p>The difference to the approach above is that the expected shortfall below the predefined threshold does not enter the objective function, but acts as an upper bound. Hence, the shortfall of NPV cannot be lower than certain level:</p> <pre><code>maxShortFall_  $ ( (p_npvAtRiskLim gt 1) $ (p_maxShortFall gt 0) ) ..\n\n        sum(nCur $ t_n(\"%lastYearCalc%\",nCur), v_shortFall(nCur)*p_probN(nCur))\n                                                   =L= p_maxShortFall*p_npvAtRiskLim;\n</code></pre>"},{"location":"FarmDynDocumentation/KeyFeatures/risk/#value-at-risk-approach","title":"Value at Risk Approach","text":"<p>Contrary to the MOTAD approaches discussed before, the Value at Risk (VaR) and conditional value at risk (CVaR) approaches (see next section) require additional binary variables and thus are numerically more demanding. The value (NPV) at risk approach introduces a fixed lower quantile (i.e., introduced as parameter and determined by the user) for the NPV as shown in following illustration. It requires the following user input:</p> <p></p> <p>The second parameter defines the maximal allowed probability for simulated objective values to fall below the resulting threshold. The reader should be aware of the fact that only undercutting matters, not by how much income drops below the given threshold. For the conditional value at risk at approach which takes this into account, see next section. If the maximal probability is set to zero, the threshold acts as a binding constraint in any SON, i.e. the NPV at any leaf cannot fall below it. The NPV at risk approach does thus not change the equation for the objective function, but introduces additional constraints. The first one drives a binary indicator variable, v_npvAtRisk, which is equal to one if the objective value at a final leaf falls below the threshold:</p> <pre><code>npvAtRisk_(nCur) $ (t_n(\"%lastYearCalc%\",nCur) $ (p_npvAtRiskLim gt 1))  ..\n\n       v_objeN(nCur) =G= p_npvAtRiskLim - v_npvAtRisk(nCur) * p_npvAtRiskLim;\n</code></pre> <p>If v_npvAtRisk is zero, the objective value (LHS) for each final leave must exceed the given threshold p_npvAtRiskLim. The second constraint, shown below, adds up the probabilities for those final nodes which undercut the threshold (LHS) and ensures that their sum is below the given maximal probability:</p> <pre><code>maxProbNpvAtRisk_ $ ( ( (p_npvAtRiskLim gt 1) or p_expShortFall) $ p_npvAtRiskmaxProb) ..\n\n      sum(t_n(\"%lastYearCalc%\",nCur), v_npvAtRisk(nCur) * p_probN(nCur)) =L= p_npvAtRiskmaxProb;\n</code></pre> <p>As long as off-farm income is considered deterministic and the relative threshold is below 100%, a solution where only off-farm income is generated should always be a feasible.</p>"},{"location":"FarmDynDocumentation/KeyFeatures/risk/#conditional-value-at-risk","title":"Conditional Value at Risk","text":"<p>The conditional value at risk approach is also referred to as the expected or mean shortfall. It is the most complex and numerically demanding of the options available and it can be seen as the combination of the VaR approach and target MOTAD with an endogenously determined limit. The decision taker defines hence a quantile, say 10% as in the screen shot below, and the model calculates endogenously the expected shortfall for the lowest 10% of the scenarios. The objective function in the model maximises a linear combination of the expected NPV and the endogenous mean shortfall, subject to the predefined lower quantile:</p> <p></p> <p>A first constraint, which is also used for the VaR option, ensures that the sum of the considered cases does not fall below the now endogenously defined limit (this equation was already shown above in the section on the Value at Risk Approach):</p> <pre><code>maxProbNpvAtRisk_ $ ( ( (p_npvAtRiskLim gt 1) or p_expShortFall) $ p_npvAtRiskmaxProb) ..\n\n      sum(t_n(\"%lastYearCalc%\",nCur), v_npvAtRisk(nCur) * p_probN(nCur)) =L= p_npvAtRiskmaxProb;\n</code></pre> <p>Additionally, the expected shortfall for any of the final nodes which do not contribute to an active lower quantile must be zero, based on a so-called BIGM formulation, i.e. the binary variable v_npvAtRisk is multiplied with a very large number, here with 1.E+7. If v_npvAtRisk for that final leave is zero (= it does not belong to the leaves with the worst NPVs), the shortfall for that leave is actually positive and can become arbitrarily large as the RHS value of 1.E+7 in the case of v_npvAtRisk equal unity never becomes binding.</p> <pre><code>shortFallTrigger1_(nCur) $ ( t_n(\"%lastYearCalc%\",nCur) $ p_expShortFall ) ..\n\n        v_shortFall(nCur) =L= p_objeRmip * v_npvAtRisk(nCur);\n</code></pre> <p>Besides this, any leaves which is not in worst cases set (v_npvAtRisk = 0) must at least generate a NPV which exceeds the best of the worst cases:</p> <pre><code>shortFallBound_(nCur)  $ ( t_n(\"%lastYearCalc%\",nCur) $ p_expShortFall  ) ..\n\n        v_objeN(nCur)     =G= v_bestShortFall+1 - v_npvAtRisk(nCur) * p_objeRmip;\n</code></pre> <p>For cases at or below the quantile which contribute towards the expected mean shortfall, both the own expected NPV and the best NPV act simultaneously as lower bounds:</p> <pre><code>shortFallTrigger2_(nCur) $ ( t_n(\"%lastYearCalc%\",nCur) $ p_expShortFall ) ..\n\n        v_slackNPV(nCur)  =L= p_objeRmip * (1-v_npvAtRisk(nCur));\n</code></pre> <pre><code>shortFallTrigger3_(nCur) $ ( t_n(\"%lastYearCalc%\",nCur) $ p_expShortFall ) ..\n\n        v_shortFall(nCur) + v_slackNPV(nCur) =E= v_objeN(nCur);\n</code></pre> <p>Accordingly, the v_bestShortFall splits the expected NPVs in those below and above the relevant quantile. The cases below that bound define the expected shortfall:</p> <pre><code>expShortFall_ $ ( p_expShortFall or p_maxShortFall ) ..\n\n        v_expShortFall =E= sum(nCur $ t_n(\"%lastYearCalc%\",nCur), v_shortFall(nCur)*p_probN(nCur));\n</code></pre> <p>The expected shortfall adds to the objective (in opposite to target MOTAD). The objective function is hence a trade-off between a higher expected mean NPV and the expected shortfall of cases x% relative to that endogenous mean.</p>"},{"location":"FarmDynDocumentation/KeyFeatures/systematic_sensitivity_analysis/","title":"Systematic sensitivity analysis based on Design of Experiments","text":"<p>FarmDyn offers the option to perform a systematic sensitivity analysis based on Design of Experiments. To execute a sensitivity analysis one has to generate a large number of farm instances to either analyze distributions of key indicators or to develop a meta-model. In the past, this feature was used intensively for publications including  e.g. Lengers et al. (2014), Kuhn et al. (2019), Seidel et al. (2020). In order to establish a meta-model such as used in the aforementioned papers, one has to follow the following steps:</p> <ol> <li> <p>Setting up of appropriate sensitivity experiments which cover the distribution of farm attributes in an appropriate sample (such as     the farm structure survey for North-Rhine-Westphalia). Consequently, this requires the use of an efficient and space filling random sampling design to lower the necessary sample size for the derivation of a meta-model. At the same time, it has to be ensured that the randomised factor level combinations are smoothly distributed over the range of factor level permutations. 1</p> </li> <li> <p>Running the single farm model on these experiments and collecting key results.</p> </li> <li> <p>Deriving a meta model from these experiments.</p> </li> </ol> <p>In the following the technical aspects and their implementation are presented.</p> <p>The overall strategy consists of combining a Java based package for interface generation and result exploitation which also comprises a machine learning package with GAMS code. For the definition of representative sensitivity experiments a sampling routine, lhs_0.10 implemented in R version 2.6.1, is combined with the GAMS code to generate sample farms under recognition of correlations between factors.</p> <p>The GAMS code (gams\\scen_gen.gms) modifies settings entered via the interface to define attributes for each experiment. A single farm run is then executed as a child process with these settings. The user is able to define upper and lower bounds for single factors to define a solution room in which factor levels can vary between scenarios for different production specific attributes of the farm. The interface also allows defining if correlations between selected variables should be recognized during the sample randomization procedure. Furthermore, depending on the number of draws and the complexity of the assumed correlation matrix a maximum number of sampling repetitions can be selected 2.</p> <p>Only the factors for which the selected maximum value differs from the minimum value are varied between model runs. Hence, the user is able to fix factor levels for single factors over all experiments by defining the minimum and maximum factor level. The upper and lower bounds of the variables define the solution space of possible factor level combinations of different factors. If the chosen minimum and maximum values are equal, the factor level of the specific attribute is holding constant during the scenario definitions. For the definition of wage rates and prices for concentrates, the user is able to select constant differences to the full time wage rate or the concentrate type 1.</p> <p>With increasing number of factors that can vary between scenarios and increasing possible factor levels per factor, the number of possible scenarios (factor level permutations) will increase exponentially (up to a few thousands). Hence, to create model outputs representative for all admissible scenarios, a large number of scenario runs would have to be processed to get reliable outputs for the derivation of a meta-model.</p> <p>As this would cause long computing time also on a multi-core processor (several days), the number of scenario runs have to be restricted to a manageable number while at the same time being representative for the real life distribution of farm attributes.</p> <p>Therefore, the scenario definition is done by Latin Hypercube Sampling (LHS) to create an efficient sample with a small sample size (to lower computing time) while guaranteeing a space filling sample design over the full range of admissible scenarios (McKay et al. 1979, Iman and Conover 1980). This is done, using a bridge from GAMS to the statistical software R. Therefore the LHS package of R has to be installed for being able to create LHS samples for a defined number of draws n and factors k (in our case taking the command \"improvedLHS(n,k)\"). LHS sampling creates a sample matrix of size n*k incorporating random values between 0 and 1, which are interpretable as percentages. These are drawn assuming an uniform distribution between 0 and 1. Further on, LHS sampling outputs ensure orthogonality of the output matrix and that factor level combinations evenly distributed over the possible permutation area.</p> <p>The GAMS side of the technical implementation is shown in the following:</p> <pre><code>* Use R to define the DOE\n*\n*------------------------------------------------------------------------------\n*\n file rIncFile / \"%curDir%/rBridge/incFile.r\" /;\n put rIncFile;\n $$setglobal outputFileD  \"%scrdir%/fromR\"\n $$setglobal inputFile    \"%scrdirR%/toR.gdx\"\n\n put ' plotFile    &lt;- \"%resdirR%/scenGen/lhs_%scenDes%.pdf\"; '/;\n put ' outputFile  &lt;- \"%outputFile%\"; '/;\n put ' inputFile   &lt;- \"%inputFile%\"; '/;\n put ' useCorr     &lt;- \"%useCorr%\"; '/;\n put ' useColors   &lt;- \"true\"; '/;\n put ' maxRunTime  &lt;- %maxRunTime%; '/;\n    putclose;\n</code></pre> <p>The maximal run time for finding a sample can be defined, maxRunTime. If correlations between variables are known and should be recognised within the sampling procedure, the command useCorr has to be set to \"true\". Then the correlation matrix can be defined specifically.</p> <pre><code>*    --- set correlation matrix\n*\n*        correlation coefficients are derived from data collections from AMI for prices and\n*        from LWK-NRW (Milchviehreport NRW, verschiedene Jahrg\ufffdnge, 2007 bis 2011)as well as\n*        a data collection of the LKV-NRW in 2012 for 5000 dairy farms in NRW. Correlation between\n*        nCows and CowsPerAK stem from the Forschungsdatenzentrum des Bundes und der L\ufffdnder after\n*        analysis on the \"Landwirtschaftsz\ufffdhlung 2010\", results were aligned with results derived\n*        from KTBL (2010,p.541).\n\n     table p_cor1(*,*)\n\n                          WinterCerePrice SummerCerePrice MaizCornPrice WinterRapePrice SummerBeansPrice SummerPeasPrice PotatoesPrice SugarBeetPrice SummerTriticalePrice\n     WinterCerePrice                            0.8            0.7            0.5            0.5                0.5          0.5             0.5             0.7\n     SummerCerePrice                                           0.7            0.5            0.5                0.5          0.5             0.5             0.8\n     MaizCornPrice                                                            0.5            0.5                0.5          0.5             0.5             0.7\n     WinterRapePrice                                                                         0.5                0.5          0.5             0.5             0.5\n     SummerBeansPrice                                                                                           0.7          0.5             0.5             0.5\n     SummerPeasPrice                                                                                                         0.5             0.5             0.5\n     PotatoesPrice                                                                                                                           0.5             0.5\n     SugarBeetPrice                                                                                                                                          0.5\n     SummerTriticalePrice\n     ;\n</code></pre> <p>The names of the set of varying factors, the factor names, the scenario name, the desired number of draws and, if activated, also the correlation matrix are send to R. Then the R file \"rbridge\\lhs.r\" is executed.</p> <pre><code>set factor_name(*,*) / name.factors /;\n     set scen_name(*,*) / name.\"%scendes%\"/;\n\n     execute_unload \"%inputFile%\" p_n,factor_name,scen_name,factors,p_cor;\n     $$setglobal rFile \"%curDir%/rbridge/lhs.r\"\n\n     $$if exist \"%outputFileD%_doe.gdx\" execute \"rm %outputFileD%_doe.gdx\"\n     $$batinclude 'util/title.gms' \"'execute %rexe% %rFile%'\";\n     $$if exist %rexe% execute \"%rexe% %rFile% %curDir%/rBridge/incFile.r\";\n\n$endif.onlyCollect\n\n*\n* --- read output from LHS sampling provided by R\n*\n parameter p_doe(*,*);\n execute_load \"%outputFile%_doe\" p_doe;\n if ( card(p_doe) eq 0, abort \"Error generating doe, no data found\";);\n display p_doe;\n\n parameter p_testDoe \"Check for mean of draws\";\n p_testDoe(factors) = sum(draws, p_doe(draws,factors))/card(draws);\n display p_testDoe;\n</code></pre> <p>The R-bridge is hence activated (R side). Therefore, several packages are installed in R from the R library to be able to do the LHS sampling:</p> <pre><code>#install.packages(\"d:\\r\\R-2.15.1\\library\\mc2d_0.1-13.zip\",repos=NULL);\n#install.packages(\"d:\\r\\R-2.15.1\\library\\mvtnorm_0.9-9992.zip\",repos=NULL);\n#install.packages(\"d:\\r\\R-2.15.1\\library\\lhs_0.10.zip\",repos=NULL);\n#install.packages(\"d:\\\\temp\\\\gclus_1.3.1.zip\",repos=NULL);\n# install.packages(\"t:\\\\britz\\\\gdxrrw_0.0-2.zip\",repos=NULL);\n# install.packages(\"D:\\\\temp\\\\gdxrrw_1.0.2.zip\", repos = NULL, type=\"source\");\n library(lhs);\n library(gdxrrw);\n igdx(\"N:/soft/gams24.7new/24.7\");\n library(mc2d);\n library(mvtnorm);\n library(Matrix);\n library(gclus);\n library(reshape2);\n</code></pre> <p>The parameter p_n denotes the number of draws defined via the GUI which is equivalent to the number of scenarios resulting from the sampling routine. Sys.getenv(....) asks for commands or information given by the environment (for example if correlations have to be recognised or not).</p> <pre><code>#useCorr    &lt;- Sys.getenv(\"useCorr\")\n#useColors  &lt;- Sys.getenv(\"useColors\")\n#inputFile  &lt;- Sys.getenv(\"inputFile\");\n#plotFile   &lt;- Sys.getenv(\"plotFile\")\n#outputFile &lt;- Sys.getenv(\"outputFile\");\n#maxRunTime &lt;- as.numeric(Sys.getenv(\"maxRunTime\"))\n</code></pre> <p>We decided to use the \"improvedLHS\" type for randomisation 3 which produces a sample matrix of n rows and k columns (n = number of draws, k = number of factors). This leads to a quite efficient sample generation in R:</p> <pre><code>out1 &lt;- improvedLHS(n,k);\n</code></pre> <p>Usually, input variables for sensitivity analysis in computer models are assumed to be independent from each other (Iman et al., 1981a;b). LHS sampling was also designed to create a sample of factor level combinations for different factors avoiding correlations between factors in random draws to ensure a space filling output. But, for our purposes, it is important to incorporate as much information about the multivariate input distribution as possible to get more realistic sample scenarios and exclude factor combinations which are rather impossible in reality. Hence, following Iman and Conover (1982:p.331-332) correlation structure information among input variables should be recognised within the sampling process, if available. Otherwise \"the theoretical properties of the statistics formed from the output may no longer be valid.\" (Iman and Conover 1982:p.331)</p> <p>To also incorporate information about dependencies between interesting variables during the sampling procedure we expanded the sampling method by an approach of Iman and Conover (1982) designing a swapping algorithm which shuffles observations for single factors between the draws to mimic given k*k correlation matrix (therefore the R package MC2d including the routine cornode is necessary).</p> <pre><code>#   --- load correlation matrix from GAMS\n#\n    t &lt;- rgdx.param(inputFile,\"p_cor\",names=c(\"f1\",\"f2\"),compress=\"true\");\n    t\n    t&lt;-acast(t, f1~f2, value.var=\"value\")\n    t&lt;-as.matrix(t);\n</code></pre> <p>To increase the possibility to randomise a sample which offers a correlation matrix of factors near the proposed one, the routine allows to repeat the random sampling of demanded n draws (yielding n experiment scenarios) for a maximal given computing time (\"maxRunTime\" e.g. 300 seconds.). The sample (incorporating n draws for k factors) with the smallest mean percentage deviation (meanDev) between the given and the randomised correlation matrix is then selected and send back to GAMS as the random sample representing the possible population. Alternatively, the repetition of n draws (n x k sampling matrix) will be stopped by a threshold value (if meanDev \\&lt; 1) for the deviation between the assumed and the randomised sample correlation matrix.</p> <pre><code>bestFit &lt;- 10;\n    iDraw &lt;- 0;\n\n\n    while( runTime &lt; maxRunTime ){\n\n       iDraw &lt;- iDraw + 1;\n\n       if ( LHSType == \"optimumLHS\" ) {\n          out1 &lt;- optimumLHS(n,k,2,0.01);\n\n          print(\"shit\");\n\n       } else {\n          out1 &lt;- improvedLHS(n,k);\n       }\n</code></pre> <pre><code># --- use cornode to apply Iman &amp; conover 1982 to impose correlation\n#     t on the LHS matrix out\n#\n       out1  &lt;- cornode(out1,target=t)\n       c &lt;- cor(out1);\n\n       fit = 0;\n       for ( i in 1:k )\n            for ( j in 1:k )\n                if ( fit &lt; bestFit )\n\n       if ( fit &lt; bestFit )\n       {\n          out     &lt;-out1;\n          bestFit &lt;-fit;\n\n          meanDev = sqrt(fit/k)*100;\n       };\n\n       if ( iDraw %% reportDraws == 0){\n          curTime &lt;- as.numeric(Sys.time(),units=\"seconds\");\n          runTime &lt;- curTime - begTime;\n          print(paste(\" draw :\",iDraw,\" runTime \",round(runTime),\" of \",maxRunTime,\"seconds, mean sqrt of squared diff between given corr and best draw: \",round(meanDev,2),\"%\"));\n       }\n</code></pre> <p>For the case that the correlations between factors are given by the user, leading to an undefined correlation matrix, the program adjusts the correlation matrix to the nearest one possible:</p> <pre><code>#   --- find nearest positive definite matrix\n#\n\n    t1&lt;-nearPD(t);\n\n    t &lt;- as.matrix(t1$mat);\n</code></pre> <p>As mentioned above the LHS sampling defines random value combinations between all factors in each single draw. Therefore, uniform distributed random values between 0 and 1 are drawn. The total set of draws defines one random sample of n single experiments (factor level combinations (in this stage of the sampling still between 0 and 1)). The routine implemented into the LHS-module now tries to find the best fitting sample which corresponds to the demanded correlation matrix most properly. Sampling outputs of the LHS draws show efficiency characteristics, also under recognition of correlations. This means that the mean of drawn random values is still 0.5 (as LHS draws lie between 0 and 1). And if the number of draws is large enough (greater than 30), quantiles as well as the mean of the distribution of LHS random values show that we are still consistent with the assumption of an uniform distribution function of the random draws (between 0 and 1), as necessary for efficient LHS outputs, also under recognition of factor correlations. The best fitting sample with the minimal average percentage deviation of correlations between the defined and the randomised correlation matrix is then selected and stored by the program and automatically printed as a PDF-document for visualisation. The PDF gives also information about average percentage bias of the randomised correlation matrix as well as the number of total draws which define the number of resulting sample experiments:</p> <p> :   Figure 12: Scatter plot matrices for different LHS     samples. With and without the recognition of factor correlations</p> <p>On the left hand side one can see the scatter plot matrix without any correlations between factors. In contrast, a clear difference in sampled values is visualised by the right hand side matrix. For example, a correlation between nCows and milkYield was assumed to be 0.8. The best fitting matrix lead to the same correlation between these two factors. The correlation coefficients within brackets are the correlations predefined by the operator. The values in front of the brackets are the correlation coefficients fitted by the sampling matrix. The average mean percentage deviation of the randomised correlation matrix and the assumed correlation matrix is quantified by 7.34 %, meaning, that on average, the randomised correlations deviate by 7.34 % from the predefined ones. The distribution function in the diagonal shows that the sampled values of each factor still  ensure a uniform distribution.</p> <p>The random values for the scenarios are transformed by GAMS to the real factor levels following the distribution functions of single variables. A uniform distribution of factor levels for the relevant variables is assumed. These are easily to define by the minimal value a and the maximum value b. A uniform distribution function can be defined by the following density function (left graph, Figure 13):</p> <p>(1) \\(f(x) = \\frac{1}{b-a},a \\leq b\\)</p> <p>Values below a or above b have a probability of 0. The anti-derivative expresses the cumulative distribution function of the random variable whose values lie within the interval \\([0; 1]\\) (right graph, Figure 13):</p> <p>(2) \\(f(x) = \\frac{x-a}{b-a},a \\leq x \\leq b\\)</p> <p> :   Figure 13: Density function and cumulative     distribution function of an uniform distributed variable</p> <p>From the left hand side density function one can easily derive the right hand side cumulative distribution function. The y value of the distribution function equals the integral \\(\\int_a^x f(x)\\) below the density function (cumulative probabilities below x).</p> <p>The given random values of the R-routine (F(x)) enable the allocation of corresponding factor levels (between a and b) to this random percentage values from the cumulative distribution function. A random cumulative probability value y corresponds to the factor level x which lies within the real value domain of the interesting factor. Hence this random sampling procedure produces random values by transforming uniform distributed random percentages (between 0 and 1) to factor levels which are conform to the assumed distribution function of the variable. So far a uniform distribution function is assumed for the real factor levels (this can be adjusted to other functions if, for example, a known population has to be simulated).</p> <p>For an assumed uniform distribution function of factor levels this is done following the formula:</p> <p>(3) \\(f(x) \\cdot (b-a) + a = x\\)</p> <p>The randomised value y is transformed to the factor level room concerning the given distribution function of the factor. Hence, for each single random draw a value is generated for the interesting variable corresponding to its assumed probability distribution. If a different distribution is assumed, formula 3 changes.</p> <p>In GAMS code the formula (3) has to be applied for each factor to calculate the sample values whereat p_doe(draws,\"factor\") is equivalent to F(x). The random percentage p_doe(*,*) has to be multiplied by the difference between the possible maximum and minimum value of the factor (%factorMax% - %factorMin%). Afterwards the min value (%factorMin%) has to be added to the product to yield the factor level x for the specific factor and scenario. This is illustrated for some parameters in the following.</p> <pre><code>* --- result related declaration\n*\n  PARAMETER p_res(*,*,*,*,*,*)\n           p_meta;\n  set resItems / mac,mean,cows,levl,margArab,margGras,margLand,herdRand,cropRand,ProfitDiff,manExportVol,profit/;\n\n\n  parameter p_scenParam(draws,allFactors) \"Numerical values for the scenario specific items\";\n\n*\n* --- standard setting for aks\n*\n  p_scenParam(draws,\"Aks\") = %aks%;\n*\n* --- general mapping from DOE to factor ranges as defined on interface\n*\n  p_scenParam(draws,factors)   = p_doe(draws,factors) * (p_ranges(factors,\"max\")-p_ranges(factors,\"min\"))+p_ranges(factors,\"min\");\n\n$iftheni.obDist %useObsDistr% == true\n</code></pre> <p>p_scenParam(draws,factor) gives the scenario parameter one factor defined by the random values given by the LHS sampling routine. The combination of factor levels of the different factors for one single draw defines one single sensitivity scenario.</p> <p>The set scenItems defines which settings are (possibly) defined specificly for each scenario:</p> <pre><code>file scenFile / \"incgen/curScen.gms\" /;\n</code></pre> <pre><code>alias(scenItems,allFactors);\n</code></pre> <p>Nevertheless, correlations between factors are able to be recognised during the sample generation to avoid factor level combinations within scenarios which conflict with common statistical knowledge. The model code enables the user to specifically exclude factor level combinations which seem to be implausible - for example high labour input per cow and low milk yield levels or high numbers of cows per farm and only very low yielding phenotypes.</p> <p></p> <p>These scenario settings must be stored in a GAMS file which is then picked up by the child processes. To keep the system extendable, firstly, all settings inputted via the GUI are copied over to the specific scenario:</p> <pre><code>*  --- copy content of current scen file into new one\n*      via OS command\n*\n   execute \"cp %curDir%/incgen/expinc.gms %curDir%/incgen/curScen.gms\"\n</code></pre> <p>Secondly, the modifications defining the specific sensitivity experiment, i.e. the scenario, are appended with GAMS file output commands (see gams\\scenGen\\gen_inc_file.gms):</p> <pre><code>*  --- put statements will append to the new scen file\n*      and overwrite standard setting\n*\n   put scenFile;\n</code></pre> <p>Finally, the content is copied to a specific scenario input file:</p> <pre><code>put_utility batch 'shell' / \"cp %curDir%/incgen/curScen.gms %curDir%/incgen/\"scen.tl\".gms\";\n</code></pre> <p>The code to build and optimise the single farm model is realised in GAMS and uses CPLEX 12.6 in parallel mode as the MIP solver. Automatic tuning is used to let CPLEX use appropriate solver setting on the problem. The model instances are set up to avoid any conflicts with I/O operations to allow for parallel execution.</p> <p>A single instance has a load of about 1.8 cores on average. In a multi-core machine it seems promising to execute several such processes in parallel. This is realised by a GAMS program which starts each model on its own set of input parameters:</p> <pre><code>*     --- execute exp_starter as a seperate program, no wait, program will delete a flag at the end to signal that it is ready\n*\n\n      put_utility  batch  'msglog'  / '%GAMSPATH%/gams.exe %CURDIR%/exp_starter.gms --scen='allScen.tl\n                           ' --iScen='iLoop:0:0' -maxProcDir=255 -output='allScen.tl'.lst'\n                          ' --seed=',uniform(0,1000):0:0,\n                          ' -maxProcDir=255 -output='allScen.tl:0'.lst %gamsarg% lo=3'\n                          ' --pgmName=\"'allScen.tl' (',iLoop:0:0,' of ',card(allScen):0:0,')\"';\n</code></pre> <p>The name of the scenario, allScen.tl is passed as an argument to the process which will lead a specific include file comprising the definition of the scenario.</p> <p>The GAMS process will use its own commando processors and run asynchronously to the GAMS thread which has started it. The calling mother process has to wait until all child processes have terminated. That is achieved by generating a child process specific flag file before starting the child process:</p> <pre><code>put_utility batch 'shell'    / ' %GAMSPATH%gbin/rm  -f \"../results/expFarms/res_',scen.tl,'_until_' p_scenParam(scen,\"lastYear\"):0:0,'.gdx\"';\n      put_utility batch 'shell'    / ' %GAMSPATH%gbin/rm  -f \"%curdir%/incgen/'scen.tl'.gms\"';\n      put_utility batch 'shell'    / ' %GAMSPATH%gbin/rm  -f \"%curdir%/'scen.tl'.lst\"';\n</code></pre> <p>This flag file will be deleted by the child process when it finalises:</p> <p></p> <p>A simple DOS script waits until all flags are deleted:</p> <pre><code>set /a _trys=0\n:again\nIF %_Mode% EXIST %_FlagFiles% (\n  set /a _trys+=1\n  if %_trys%.==%_MaxTrys%. goto errorexit\n  sleep.exe %_seconds%\n  goto again\n)\n</code></pre> <p>Using that set-up would spawn for each scenario a GAMS process which would then execute all in parallel. The mother process would wait until all child processes have deleted their flag files before collecting their results. As several dozen or even hundredth of scenarios might be executed, that might easily block the machine completely, e.g. by exceeding the available memory.</p> <p>It is hence necessary to expand the set-up by a mechanism which ensures that only a pre-defined number of child processes are active in parallel. This is established by a second simple DOS script which waits until the number of flag files drops below a predefined threshold:</p> <pre><code>set /a _trys=0\n:again\n\nset _count=1\n\nfor %%x in (%_FlagFiles%) do set /a _count+=1\n\nREM @echo %_count% %_nFiles% &gt;&gt; d:\\temp\\test.txt\n\nif %_count% gtr %_nFiles% (\n\n  set /a _trys+=1\n\n  if %_trys%.==%_MaxTrys%. goto errorexit\n\nREM @echo %_trys% %_maxTrys% %_seconds% &gt;&gt; d:\\temp\\test.txt\n\n\n  sleep.exe %_seconds%\n\n  goto again\n\n)\n</code></pre> <p>Finally, the results from individual runs are collected and stored. A GAMS facility is used to define the name of a GDX file to read at run time:</p> <pre><code>put_utilities batch 'gdxin' / ' ../results/expFarms/res_',scen.tl,'_until_' p_scenParam(scen,\"lastYear\"):0:0,'.gdx';\n</code></pre> <p>We now transformed all MAC estimates which are 0 due to an exit decision of a farm to be able to select these cases for our meta-modeling estimation (Heckman two-stage selection, described in the technical documentation: \"R routine to estimate Heckman two stage regression procedure on marginal abatement costs of dairy farms, based on large scale outputs of the model DAIRYDYN\" by Britz and Lengers (2012)).</p> <pre><code>*        --- load the result\n*\n              execute_load p_res;\n              p_dummy = sleep(.01);\n              if ( execerror eq 0,\n*\n*               --- filter out results of interest (so far only macs, avAcs and totACs)\n*\n                $$ifi \"%scentype%\"==\"MAC\"     $include 'scengen/scen_load_res_mac.gms'\n\n                $$ifi \"%scentype%\"==\"PROFITS\" $include 'scengen/scen_load_res_profits.gms'\n                $$ifi \"%scentype%\"==\"Fertilizer directive\" $include 'scengen/scen_load_res_profits.gms'\n         $$ifi \"%scentype%\"==\"Multi indicator\" $include 'scengen/scen_load_res_multi_indicator.gms'\n\n             );\n</code></pre> <p>Further on, the scenario specific settings which can be used as explanatory variables for later regressions are stored, see for example:</p> <pre><code>*     --- add scen variables to store explanatory vars\n*\n      p_meta(actInds,redLevl,scenItems,actInds1,scen)\n       $ sum(redlevl1, p_res(actInds,redLevl1,\"mac\",actInds1,\"mean\")) = p_scenParam(scen,scenItems);\n\n      p_meta(actInds,redLevl,actInds,actInds1,scen)\n       $ sum(redlevl1, p_res(actInds,redLevl1,\"mac\",actInds1,\"mean\")) = 1;\n\n      p_meta(actInds,redLevl,\"redLevl\",actInds1,scen)\n       $ sum(redlevl1, p_res(actInds,redLevl1,\"mac\",actInds1,\"mean\")) =\n                                                                         p_res(actInds,redLevl,\"redlevl\",actInds1,\"mean\");\n</code></pre> <p>In a next step, the results are stored in a GDX container</p> <pre><code>*   --- Store to disk\n*\n    execute_unload '../results/scenGen/meta_%scenDes%.gdx' s_meta,p_meta=p_res;\n</code></pre> <p>The major challenge consists in ensuring that the child processes do not execute write operation on shared files. In the given example, that relates to the GAMS listing, the GDX container with the results and the option files generated by the CPLEX tuning step. For the latter, two options are available: (1) set up child specific directory, copy the option files into it and use the optdir setting in GAMS, or (2) label the option files accordingly. That latter option was chosen which restricts the number of scenarios to 450:</p> <p>^Comment:# (N:/em/work1/Pahmeyer/FarmDyn/FarmDynDoku/FarmDyn_Docu/model/def_run.gms GAMS /*.*?opt3/ /$else.iScen/)</p> <pre><code>* --- opt3 file will by replaced by ###\n*     that allows for 300 parallel threads\n*\n$iftheni.iScen not \"%iScen%\"==\"\"\n\n$evalGlobal op3 round(%iScen%+100)\n$evalGlobal op4 round(%iScen%+400)\n$evalGlobal op5 round(%iScen%+700)\n\n\n$setglobal scenWithoutIncgen  %scen%\n$set       scen  incgen/%scen%\n\n$else.iScen\n</code></pre> <p>In the case of normal single farm run, the standard option files will be used.</p>"},{"location":"FarmDynDocumentation/KeyFeatures/systematic_sensitivity_analysis/#references","title":"References","text":"<p>LENGERS, B., BRITZ, W., HOLM-M\u00dcLLER, K. (2014): What drives marginal abatement costs of greenhouse gases on dairy farms? A meta-modeling approach, Journal of Agricultural Economics 65(3): 579\u2013599.</p> <p>KUHN, T., SCH\u00c4FER, D., HOLM-M\u00dcLLER, K., BRITZ, W. (2019): On-farm compliance costs with the EU-Nitrates Directive: A modelling approach for specialized livestock production in northwest Germany, Agricultural Systems 173: 233-243.</p> <p>SEIDEL, C., BRITZ, W. (2020): Estimating a Dual Value Function as a Meta-Model of a Detailed Dynamic Mathematical Programming Model, Bio-Based and Applied Economics, 8(1), 75-99.</p> <ol> <li> <p>This assures also under the restricted number of random values for each factor the components are still represented in a fully stratified manner over the entire range, each variable has the opportunity to show up as important, if it indeed is important (Iman, 2008).\u00a0\u21a9</p> </li> <li> <p>This is necessary to restrict sampling time but also guarantees to find a random sample that appropriately implies the correlation structure as proposed by the user (more detailed explanation of this later in this paper)\u00a0\u21a9</p> </li> <li> <p>Another possible routine for LHS sampling is \"optimumLHS(***)\". But during our test runs it did not lead to more smooth space filling random draws, but increased the runtime of the sampling process. For optimal-LHS see also Park (1994).\u00a0\u21a9</p> </li> </ol>"},{"location":"FarmDynDocumentation/ModelDescription/AnimalProduction/cattle/","title":"Cattle Module","text":"<p>Abstract The cattle module is closely related to the general herd module. It describes the demographic relations between cattle types (dairy cows, mother cows, male and female calves, heifers, young bulls) on the farm. The cattle feed requirements are calculated considering the animals performance and the lactation phase of cows. The requirements can be met via a mix from own produced and purchased fodder, concentrates and grazing from pastures.</p> <p>The set phase lists the different phases and the month during the year they are in.</p> <p>set phase \"lactation phase / dry / general / months in year\" /     LC30_1,LC92_1,LC213_1,LC305_1,dry_1,     LC30_2,LC92_2,LC213_2,LC305_2,dry_2,     LC30_3,LC92_3,LC213_3,LC305_3,dry_3,     LC30_4,LC92_4,LC213_4,LC305_4,dry_4,     LC30_5,LC92_5,LC213_5,LC305_5,dry_5,     LC30_6,LC92_6,LC213_6,LC305_6,dry_6,     GEN,0_2,3_/;</p> <p>The set reqsPhase lists the different rquirement phases. The \"LC\" labeled elements are the requirement phases for different lactation phases, the element \"dry\" refers to the dry period where cows are not lactating, the element \"gen\" is for heifers and bulls that are not lactating and the elements \"0_2\" and \"3_\" are for calves.</p> <p>set reqsPhase / LC30,LC92,LC213,LC305,dry,GEN,0_2,3_/;</p> <p>The cross-set phase_reqsPhase links the monthly  phases to the general requirement phases.</p> <p>set phase_reqsPhase(phase,reqsPhase) /</p> <pre><code>(LC30_1,LC30_2,LC30_3,LC30_4,LC30_5,LC30_6).LC30\n(LC92_1,LC92_2,LC92_3,LC92_4,LC92_5,LC92_6).LC92\n(LC213_1,LC213_2,LC213_3,LC213_4,LC213_5,LC213_6).LC213\n(LC305_1,LC305_2,LC305_3,LC305_4,LC305_5,LC305_6).LC305\n(dry_1,dry_2,dry_3,dry_4,dry_5,dry_6).dry\nGEN.GEN,\n</code></pre> <p>* *     -- for calves raising processes, first two months and rest *     0_2.0_2,3_.3_</p> <p>/; The set phase_startPhase lists the starting monthly  phases to the general requirement phases.</p> <p>set phase_startPhase(phase,reqsPhase) /       (LC30_1).LC30       (LC92_1).LC92       (LC213_1).LC213       (LC305_1).LC305       (dry_1).dry /;</p>"},{"location":"FarmDynDocumentation/ModelDescription/AnimalProduction/cattle/#cattle-feeding","title":"Cattle feeding","text":"<p>The feeding of cattle consists of two major elements:</p> <ol> <li> <p>Requirement functions and related constraints in the model     template</p> </li> <li> <p>Feeding activities, which ensure that requirements are covered     and link the animal to the cropping sector as well as to purchases     of concentrates</p> </li> </ol> <p>The requirements are defined in coeffgen\\requ.gms. Requirements for dairy cows are differentiated by annual milk yield and by lactation period. The model differentiates 5 lactation periods with different lengths (30 - 70 - 100 - 105 - 60 days, where the last 60 days are the dry period). The periods are labelled according to their last day, e.g. LC200 is the period from day 101 to day 200, LC305 is the period from the 201st to the 305th day and dry denotes the last 60 days of lactation.</p> Excurse - Computation of Output Coefficients for each Lactation Phase <p>This excurse describes the derivation of the output coefficient for each lactation phase, hence how much of yearly milk yield is produced by each cow on one day.</p> <p> :   Figure 3: Lactation Curves of Different Yearly Milk Yield Potentials and               Average Milk Yield in Different Lactation Phases. :   Remark: Calculation based on Huth (1995, pp.224-226). :   Source: Own illustration.  </p> <p>Using the above shown lactation functions, the daily fraction of the yearly milk yield in each lactation phase can be derived. The mean over the four milk yield potentials of the coefficients are shown in Table 1.</p> <p>Table 1: Daily Fraction of Whole Lactation Milk Yield in Different Lactation Phases.</p> LC30 LC100 LC200 LC3005 Dry Daily fraction 0.00356 0.0043 0.00333 0.00233 0 <p>Remark: Own calculation based on Huth (1995, pp.224-226).</p> <p>Following these outputs, e.g. on each of the first 30 days of lactation, the cow produces 0.356 % of the yearly milk yield (e.g. 28 kg per day for a cow which produces 8000 kg per year). In a next step, these coefficients are used to calculate the sum of milk output in each lactation phase to further calculate feed requirements stemming from the herds in each phase.</p> <p>The daily milk yield in each period is based on the following statements which define milk yield in ton per year, stored on the general output coefficient parameter p_OCoeff. The coefficient is scaled to match total yearly milk yield.</p> <pre><code>p_mlkPerDay(dcows,curBreeds,\"LC30\")  $ herds_breeds(dcows,curBreeds) = 0.003555556 * sum(t $ (t.pos eq 1), p_OCoeff(dcows,\"milk\",curBreeds,t) * 1000);\np_mlkPerDay(dcows,curBreeds,\"LC92\")  $ herds_breeds(dcows,curBreeds) = 0.004333333 * sum(t $ (t.pos eq 1), p_OCoeff(dcows,\"milk\",curBreeds,t) * 1000);\np_mlkPerDay(dcows,curBreeds,\"LC213\") $ herds_breeds(dcows,curBreeds) = 0.003333333 * sum(t $ (t.pos eq 1), p_OCoeff(dcows,\"milk\",curBreeds,t) * 1000);\np_mlkPerDay(dcows,curBreeds,\"LC305\") $ herds_breeds(dcows,curBreeds) = 0.002333333 * sum(t $ (t.pos eq 1), p_OCoeff(dcows,\"milk\",curBreeds,t) * 1000);\n</code></pre> <pre><code>p_mlkPerDay(dcows,curBreeds,\"LC30\")  $ herds_breeds(dcows,curBreeds) = 0.003555556 * sum(t $ (t.pos eq 1), p_OCoeff(dcows,\"milk\",curBreeds,t) * 1000);\np_mlkPerDay(dcows,curBreeds,\"LC92\")  $ herds_breeds(dcows,curBreeds) = 0.004333333 * sum(t $ (t.pos eq 1), p_OCoeff(dcows,\"milk\",curBreeds,t) * 1000);\np_mlkPerDay(dcows,curBreeds,\"LC213\") $ herds_breeds(dcows,curBreeds) = 0.003333333 * sum(t $ (t.pos eq 1), p_OCoeff(dcows,\"milk\",curBreeds,t) * 1000);\np_mlkPerDay(dcows,curBreeds,\"LC305\") $ herds_breeds(dcows,curBreeds) = 0.002333333 * sum(t $ (t.pos eq 1), p_OCoeff(dcows,\"milk\",curBreeds,t) * 1000);\n</code></pre> <p>The model differentiates between requirements for energy in net-energy for lactation, raw protein and maximum dry matter. The feeding requirements are described by the parameter <code>p_reqsPhase</code> for each herd and a certain requirement phase. As described earlier, the requirement phases of cows are differentiated into specific, fixed stages during lactation. For bulls, heifers, and calves, the amount of feeding/requirement phases are defined over the GUI. For each feeding phase, the daily requirements during the production process are identical.</p> <p>The requirement functions account for differing start and final weights, as well as daily weight gains of the animals. The underlying regression models were kindly provided by the Institut f\u00fcr Tierern\u00e4hrung und Futterwirtschaft of the Bayerische Landesandstalt f\u00fcr Landwirtschaft (LfL)1.</p> <p>The requirements per requirement phase <code>p_reqsPhase</code> are subsequently converted into values per month, in order to ensure that the animals are correctly fed throughout the requirement period.</p> <pre><code>p_reqsPhaseMonths(herds,curBreeds,feedRegime,reqsPhase,reqs) $ p_reqsPhaseLength(herds,curBreeds,reqsPhase)\n      = p_reqsPhase(herds,curBreeds,reqsPhase,reqs)/p_reqsPhaseLength(herds,curBreeds,reqsPhase) * 30.5;\n</code></pre> <p>The monthly requirements per planning period, <code>p_reqsPhaseMonths</code>, enter the equation structure of the model. The equations are differentiated by herd, year, planning period and state-of-nature (SON), and ensure the requirements are covered by an appropriate feed mix made out of different feeding stuff. The composition of the feed mix is determined endogenously. The total feed requirements for a farm in the different intra-yearly planning periods depend on the distribution of calving dates in the cow herd, therefore, cows of the same milk yield potential can be in different lactation phases during the year. The requirements of tons of feed, v_feeding, are differentiated by herd, breed, planning period (lactation phase of cow), SON and year, if the requirement phases are not defined for specific time spans after the herd start:</p> <pre><code>reqs_(actHerds(possHerds,breeds,feedRegime,tCur(t),m),reqsPhase,reqs,nCur)\n        $ (    p_reqsPhaseLengthMonths(possHerds,breeds,\"gen\")\n             $ p_reqsPhaseMonths(possHerds,breeds,feedRegime,reqsphase,reqs)\n             $ t_n(t,nCur)) ..\n*\n*      --- herd size times requirements per head, minus year and SON specific reduction in milk yield\n\n\n         v_herdSize(possHerds,breeds,feedRegime,t,nCur,m)\n                 * p_reqsPhaseMonths(possHerds,breeds,feedRegime,reqsPhase,reqs)\n*\n*                       --- these corrections are endogenous during automatic calibration, otherwise fixed to\n*                           loaded calibration results or equal to unity\n*\n                        *(   v_reqsCorr(possHerds,breeds,\"Ener\") $ (sameas(reqs,\"NEL\") or sameas(reqs,\"ME\"))\n                           + v_reqsCorr(possHerds,breeds,\"Prot\") $ (sameas(reqs,\"XP\")  or sameas(reqs,\"nXP\"))\n                           + v_reqsCorr(possHerds,breeds,\"Rest\") $ (not (    sameas(reqs,\"XP\")  or sameas(reqs,\"nXP\")\n                                                                          or sameas(reqs,\"NEL\") or sameas(reqs,\"ME\")))\n                         )\n*\n*      --- must be covered by feeding times the content of the feed stuff\n*\n          =L=   sum( feedRegime_feeds(feedRegime,curFeeds(feeds)) $ actHerdsF(possHerds,breeds,feedRegime,reqsPhase,m),\n                   v_feeding(possHerds,breeds,feedRegime,reqsPhase,m,feeds,t,nCur) * p_feedContFMton(feeds,reqs))\n             ;\n</code></pre> <p>Alternatively, requirements can be linked to the start point of an animal process to break down the total requirement during the length of the production processes in phases. The equation is only switched on if the parameter <code>p_reqsPhaseLength</code> is non-zero:</p> <pre><code>reqsPhase_(possHerds,breeds,feedRegime,reqs,reqsPhase,m,t_n(tCur(t),nCur))\n             $ ( actHerds(possHerds,breeds,feedRegime,t,m)\n                  $ (not p_reqsPhaseLengthMonths(possHerds,breeds,\"gen\"))\n                  $ p_reqsPhase(possHerds,breeds,reqsPhase,reqs)) ..\n*\n*         --- herds which started in the months before the production length\n*\n*                   -- number of months that herd in that requirement phase during that period\n*                      multiplied with monthly requirements\n*\n              sum(actHerds(possHerds,breeds,feedRegime,t,m) $ p_reqsPhaseMonths(possHerds,breeds,feedRegime,reqsPhase,reqs),\n                     v_herdsReqsPhase(possHerds,breeds,feedRegime,reqsphase,m,t,nCur)\n                       * p_reqsPhaseMonths(possHerds,breeds,feedRegime,reqsPhase,reqs)\n\n*\n*                       --- these corrections are endogenous during automatic calibration, otherwise fixed to\n*                           loaded calibration results or equal to unity\n*\n                        *(   v_reqsCorr(possHerds,breeds,\"Ener\") $ (sameas(reqs,\"NEL\") or sameas(reqs,\"ME\"))\n                           + v_reqsCorr(possHerds,breeds,\"Prot\") $ (sameas(reqs,\"XP\")  or sameas(reqs,\"nXP\"))\n                           + v_reqsCorr(possHerds,breeds,\"Rest\") $ (not (    sameas(reqs,\"XP\")  or sameas(reqs,\"nXP\")\n                                                                          or sameas(reqs,\"NEL\") or sameas(reqs,\"ME\")))\n                         ))\n*\n*      --- must be covered by feeding times the content of the feed stuff\n*\n          =L=   sum((actHerdsF(possHerds,breeds,feedRegime,reqsPhase,m),feedRegime_feeds(feedRegime,curFeeds(feeds))),\n                   v_feeding(possHerds,breeds,feedRegime,reqsPhase,m,feeds,t,nCur) * p_feedContFMton(feeds,reqs))\n          ;\n</code></pre> <p>In a next step feeding amounts are aggregated to total feed use, v_feeduse, per each product and for each year, feed and planning period.</p> <pre><code>feedUse_(curFeeds(feedsY),t_n(tCur(t),nCur))  ..\n\n       v_feedUse(feedsY,t,nCur)\n\n           =e= sum(actHerdsF(possHerds,breeds,feedRegime,reqsPhase,m) $ feedRegime_feeds(feedRegime,feedsY),\n                            v_feeding(possHerds,breeds,feedRegime,reqsPhase,m,feedsY,t,nCur));\n</code></pre> <p>For own produced feed which is not storable and shows a variable availability over the year, such as grass from pasture, an aggregation to the intra-year periods is done.</p> <pre><code>feedUseM_(curFeeds(feedsM),m,t_n(tCur(t),nCur)) $ sum(actHerdsF(possHerds,breeds,feedRegime,reqsPhase,m),1) ..\n\n       v_feedUseM(feedsM,m,t,nCur)\n\n           =e= sum( actHerdsF(possHerds,breeds,feedRegime,reqsPhase,m) $ feedRegime_feeds(feedRegime,feedsM),\n                                           v_feeding(possHerds,breeds,feedRegime,reqsPhase,m,feedsM,t,nCur));\n</code></pre> <p>Feed is further differentiated into bought- (v_feedUseBuy) and self-produced (v_feedUseProds) feed. * * ---- Adding up the bought and own produced feed for cattle *      feedUseSource_(curFeeds(feedsY),t_n(tCur(t),nCur)) ..          v_feedUse(feedsY,t,nCur)   =E=                                           v_feedUseProds(feedsY,t,nCur) $ (sum(sameas(prodsYearly,feedsY),1))                                         + v_feedUseBuy(feedsY,t,nCur)   $ (sum(sameas(curInputs,feedsY),1)) ;</p> <p>In sumReqs_ the total requirements v_sumReqs are linked to the total feed as in v_feeduse and v_feedUseM.                                       * *   --- add requirements over herds, total and bought ones *     sumReqs_(reqs,t_n(tCur(t),nCur)) ..</p> <pre><code>     v_sumReqs(reqs,t,nCur)*1000 =E=\n                          sum( curFeeds(feedsY),     v_feedUse(feedsY,t,nCur)   * p_feedContFMton(feedsY,reqs))\n                        + sum( (curFeeds(feedsM),m), v_feedUseM(feedsM,m,t,nCur)* p_feedContFMton(feedsM,reqs));\n</code></pre> <p>In sumReqsBought_ the links the total requirements from bought feedstuff, v_sumReqsBought, are summed up.                                      </p> <pre><code>sumReqsBought_(reqs,t_n(tCur(t),nCur)) ..\n\n     v_sumReqsBought(reqs,t,nCur)*1000\n           =E= sum( (sameas(feedsY,curInputs),sys) $ (p_inputprice%l%(curInputs,sys,t) $ curFeeds(feedsY)),\n                               v_buy(curInputs,sys,t,nCur)*p_feedContFMton(feedsY,reqs));\n</code></pre> <p>herdsByFeedRegime_ distributes the herds as in v_herdSize to the requirement phases in v_herdsReqsPhase.                                     </p> <pre><code>herdsByFeedRegime_(possHerds,curBreeds,feedRegime,t_n(tCur(t),nCur),m)\n       $ (actHerds(possHerds,curBreeds,feedRegime,t,m)\n            $ sum(reqsPhase $ (not sameas(reqsPhase,\"gen\")), p_reqsPhaseLengthMonths(possHerds,curBreeds,reqsPhase))) ..\n\n    v_herdSize(possHerds,curBreeds,feedRegime,t,nCur,m)\n\n         =E= sum(reqsPhase $ p_reqsPhase(possHerds,curBreeds,reqsPhase,\"DMMX\"),\n                v_herdsReqsPhase(possHerds,curBreeds,feedRegime,reqsphase,m,t,nCur)\n                );\n</code></pre> <p>herdsReqsPhase_ determines the herds  in a current time point (v_herdstart) and maps them to their current requirement phase and there current production cycle v_herdsReqsPhase (e.g. dry cows in second lactation).</p> <pre><code>herdsReqsPhase_(possHerds,breeds,reqsPhase,m,t_n(tCur,nCur))\n     $ ( (not p_reqsPhaseLengthMonths(possHerds,breeds,\"gen\"))\n           $ sum(feedRegime, actHerds(possHerds,breeds,feedRegime,tCur,m))\n             $ p_reqsPhase(possHerds,breeds,reqsPhase,\"DMMX\")  ) ..\n\n      sum(actHerds(possHerds,breeds,feedRegime,tCur,m),\n            v_herdsReqsPhase(possHerds,breeds,feedRegime,reqsphase,m,tCur,nCur))\n</code></pre> <ul> <li>--- herds which started in the months before the production length, in case for piglets a separate construct is used         =E=           sum(phase_reqsPhase(phase,reqsPhase) $ p_reqsPhaseStart(possHerds,breeds,phase),             sum( (t1,nCur1,m1) $ ( t_n(t1,nCur1) $ isNodeBefore(nCur,nCur1)                               $ [ (     ( -p_mDist(tCur,m,t1,m1)+1-p_reqsPhaseStart(possHerds,breeds,phase)       ge 0)                                    $    ( -p_mDist(tCur,m,t1,m1)+1-p_reqsPhaseStart(possHerds,breeds,phase)                                       - p_reqsPhaseLengthMonths(possHerds,breeds,reqsPhase) lt 0) $ (p_mDist(tCur,m,t1,m1) le 0)<pre><code>                           $    (-p_mDist(tCur,m,t1,m1) le (p_prodLength(possHerds,breeds)-1))\n\n                          )\n\n                      or  (\n                               ( -p_mDist(tCur,m,t1,m1)+13-p_reqsPhaseStart(possHerds,breeds,phase)    ge 0)\n                           $   ( -p_mDist(tCur,m,t1,m1)+13-p_reqsPhaseStart(possHerds,breeds,phase)\n                                  - p_reqsPhaseLengthMonths(possHerds,breeds,reqsPhase) lt 0)    )   $ p_compStatHerd\n                         ]\n                        $ sum(feedRegime,actHerds(possHerds,breeds,feedRegime,t1,m1))\n                       ),\n\n            v_herdStart(possHerds,breeds,t1,nCur1,m1)\n</code></pre> <p>* *                   --- minus, in case of cows, slaughtered before reaching the final age *                -sum( (slgtCows,cows) $ (sum(feedRegime, actHerds(slgtCows,breeds,feedRegime,t1,m1))                     $ sameas(cows,possHerds) $ (slgtCows.pos eq cows.pos)),                          v_herdStart(slgtCows,breeds,t1,nCur1,m1))        ));</p> </li> </ul> <p>In feedUseHerds_ the monthly feeding v_feeding is summed up to yearly feeding v_feedUseHerds</p> <pre><code>feedUseHerds_(possHerds,curFeeds(feeds),t_n(tCur(t),nCur)) $ sum(actHerdsF(possHerds,breeds,feedRegime,reqsPhase,m),1) ..\n\n   v_feedUseHerds(possHerds,feeds,t,nCur)\n\n       =e= sum(actHerdsF(possHerds,breeds,feedRegime,reqsPhase,m)$ feedRegime_feeds(feedRegime,feeds),\n                             v_feeding(possHerds,breeds,feedRegime,reqsPhase,m,feeds,t,nCur));\n</code></pre> <p>maxChlorella_ restricts the maximum dry-matter intake of animals in the form of chlorella-algae to 10% of the total dry matter intake.</p> <p>maxChlorella_(possHerds,t_n(tCur(t),nCur)) $ (curFeeds(\"Chlorella\")            $ sum(actHerdsF(possHerds,breeds,feedRegime,reqsPhase,m),1)) ..</p> <pre><code>v_feedUseHerds(possHerds,\"Chlorella\",t,nCur) =L=\n  0.1 * sum((actHerdsF(possHerds,breeds,feedRegime,reqsPhase,m),feeds)$ feedRegime_feeds(feedRegime,feeds),\n                        v_feeding(possHerds,breeds,feedRegime,reqsPhase,m,feeds,t,nCur));\n</code></pre> <p>In sumHerdsYY_ calculates the yearly herd-size by summing up v_herdSize over feedRegime and month.</p> <p>sumHerdsYY_(sumHerdsY,breeds,t_n(t,nCur)) $ ( (tCur(t) or tBefore(t))                                      $  sum(actHerds(sumHerdsY,breeds,feedRegime,t,m),1)) ..</p> <pre><code>   v_sumherd(sumHerdsY,breeds,t,nCur)\n      =e= sum((feedRegime,m) $ actHerds(sumHerdsY,breeds,feedRegime,t,m),\n                           v_herdSize(sumHerdsY,breeds,feedRegime,t,nCur,m));\n</code></pre> <p>The equation avgLactations_ orders the herdsize times the pre-determined average lactation length from the GUI, p_nLactations, into a linear combination of integer lactation lenghts as in p_nLac.</p> <p>* *   --- recover average lactations (e.g. 3.7) from short (e.g. 3 lactations) and long (e.g. 4 lactations) cows *     avgLactations_(breeds,t_n(t,nCur)) $ sum((feedRegime,m), actHerds(\"cows\",breeds,feedRegime,t,m)) ..</p> <pre><code>     sum( (dCows,feedRegime,m) $ actHerds(dCows,breeds,feedRegime,t,m),\n           v_herdSize(dCows,breeds,feedRegime,t,nCur,m)*p_nLactations)\n    =E=\n\n      sum( (dCows,feedRegime,m) $ actHerds(dCows,breeds,feedRegime,t,m),\n           v_herdSize(dcows,breeds,feedRegime,t,nCur,m)*p_nLac(dCows));\n</code></pre> <p>The number of new calves v_herdStart is differentiated by gender and breed, in a year t, and specific month m, and depends on the herd size of cows of each breed and a specific calving coefficient. The left hand side adds up all male and female calves, if cross-breeding is switched on, adding the cross-breeds. ActHerds is a flag set to define which herds might enter the solution for a specific year.</p> <pre><code>newCalves_(dairyBreeds,t,nCur,m) $ ( sum( (calvs,feedRegime), actHerds(calvs,dairyBreeds,feedRegime,t,m))\n                        $ (p_Year(t) le p_year(\"%lastYear%\")) $ t_n(t,nCur) $ (not sameas(dairyBreeds,\"%crossBreed%\"))) ..\n*\n*      --- new born calves (for females by genetic potential for milk yield) are born\n*          from the current herd of cows\n*\n                  v_herdStartBornCalvsRais(\"fCalvsRais\",dairyBreeds,t,nCur,m)  $ sum(feedRegime,actHerds(\"fCalvsRais\",dairyBreeds,feedRegime,t,m))\n                + v_herdStart(\"fCalvsSold\",dairyBreeds,t,nCur,m)  $ sum(feedRegime,actHerds(\"fCalvsSold\",dairyBreeds,feedRegime,t,m))\n                + v_herdStart(\"mCalvsSold\",dairyBreeds,t,nCur,m)  $ sum(feedRegime,actHerds(\"mCalvsSold\",dairyBreeds,feedRegime,t,m))\n                + v_herdStartBornCalvsRais(\"mCalvsRais\",dairyBreeds,t,nCur,m)  $ sum(feedRegime,actHerds(\"mCalvsRais\",dairyBreeds,feedRegime,t,m))\n              $$iftheni.crossBreed \"%crossBreeding%\"==\"true\"\n                + v_herdStartBornCalvsRais(\"fCalvsRais\",\"%crossBreed%\",t,nCur,m) $ (sum(feedRegime,actHerds(\"fCalvsRais\",\"%crossBreed%\",feedRegime,t,m)) $ sameas(dairyBreeds,\"%crossBreedBase%\"))\n                + v_herdStart(\"fCalvsSold\",\"%crossBreed%\",t,nCur,m) $ (sum(feedRegime,actHerds(\"fCalvsSold\",\"%crossBreed%\",feedRegime,t,m)) $ sameas(dairyBreeds,\"%crossBreedBase%\"))\n                + v_herdStart(\"mCalvsSold\",\"%crossBreed%\",t,nCur,m) $ (sum(feedRegime,actHerds(\"mCalvsSold\",\"%crossBreed%\",feedRegime,t,m)) $ sameas(dairyBreeds,\"%crossBreedBase%\"))\n                + v_herdStartBornCalvsRais(\"mCalvsRais\",\"%crossBreed%\",t,nCur,m) $ (sum(feedRegime,actHerds(\"mCalvsRais\",\"%crossBreed%\",feedRegime,t,m)) $ sameas(dairyBreeds,\"%crossBreedBase%\"))\n             $$endif.crossBreed\n\n          =e= sum( (cows,t1,nCur1,m1,mDist) $ (sum(feedRegime,actHerds(cows,dairyBreeds,feedRegime,t1,m1))\n                  $ (      (mDist.pos  eq -p_mDist(t,m,t1,m1))\n                         or (mDist.pos eq -p_mDist(t,m,t1,m1)+12) $ p_compStatHerd)\n                       $ t_n(t1,nCur1) $ herds_breeds(cows,dairyBreeds) $ sameScen(nCur,nCur1)),\n                         ( v_herdStart(cows,dairyBreeds,t1,nCur1,m1)\n                          -sum(slgtCows $((cows.pos eq slgtCows.pos) $ sum(feedRegime,actHerds(slgtcows,dairyBreeds,feedRegime,t1,m1))),\n                                           v_herdStart(slgtCows,dairyBreeds,t1,nCur1,m1)))\n                           * p_calvCoeff(cows,dairyBreeds,mDist))\n;\n</code></pre> <p>The calving coefficients are defined in the Cows tab of the Graphical User Interface (GUI). Here, the amount of births per lactation, living calves per birth, calf losses, and days between births can be set for the different breeds Holstein-Friesian (HF), Simmental (SI, which stands a placeholder for the individual breed defined in the GUI), and mother cows. The values are stored in the parameter p_calvAttr.</p> <p>The amount of calves born in a given month is derived from the information entered in the GUI with the help of an entropy estimator. For the sake of simplicity, but without loss of generality, it is assumed that birth is equally likely in the two months surrounding the average calving interval.</p> <pre><code>set curCycleLength / l11*l15 /;\n*\n*  --- entropy estimator\n*\n   variable v_ent \"Entropy\";\n   positive variables         v_prob(cowTypes,curCycleLength)\n\n   parameter p_cycleLength(curCycleLength);\n   p_cycleLength(curCycleLength) = 10 + curCycleLength.pos;\n\n\n   equation e_ent                    \"Entropy definition\"\n            e_daysBetweenBirths      \"Recover given information on inter calving interval\"\n            e_sumUnity               \"Probs add up to unity\"\n   ;\n\n   e_ent .. -v_ent =E=  sum( (cowTypes,curCycleLength),v_prob(cowTypes,curCycleLength)\n                                 * log(v_prob(cowTypes,curCycleLength)/card(curCycleLength)));\n\n   e_daysBetweenBirths(cowTypes) ..\n        p_calvAttr(cowTypes,\"daysBetweenBirths\")/30.5\n                 =E=  sum(curCycleLength, v_prob(cowTypes,curCycleLength)* p_CycleLength(curCycleLength));\n\n   e_sumUnity(cowTypes) $ (not sameas(cowTypes,\" \")) ..  sum(curCycleLength, v_prob(cowTypes,CurCycleLength)) =E= 1;\n\n   v_prob.up(cowTypes,curCycleLength) = 1;\n   v_prob.lo(cowTypes,curCycleLength) = 1.E-5;\n\n   v_prob.fx(cowTypes,curCycleLength) $ (p_calvAttr(cowTypes,\"daysBetweenBirths\")/30.5 lt p_CycleLength(curCycleLength)-1) = 1.E-6;\n   v_prob.fx(cowTypes,curCycleLength) $ (p_calvAttr(cowTypes,\"daysBetweenBirths\")/30.5 gt p_CycleLength(curCycleLength)+1) = 1.E-6;\n\n   v_prob.l(cowTypes,CurCycleLength)  = 1/card(CurCycleLength);\n\n   model m_ent / e_ent,e_daysBetweenBirths,e_sumUnity /;\n   m_ent.solprint = 2;\n$ifi \"%debugOutput%\"==\"true\" m_ent.solprint = 1;\n\n   solve m_ent maximizing v_ent using NLP;\n</code></pre> <p>The calving probabilities are then mapped to the actual endogenous calving distribution in the parameter p_calvCoeff which is subsequently used in the herdStart_ equation.  </p> <p>^Comment:# (N:/em/work1/Pahmeyer/FarmDyn/FarmDynDoku/FarmDyn_Docu/gams/coeffgen/ini_herds.gms GAMS /p_calvCoeff\\(dCows,\"%basBreed%\",mDist\\)/ /;/)</p> <pre><code>p_calvCoeff(dCows,\"%basBreed%\",mDist)\n     $ ( (mDist.pos ge 12)\n          $ (mDist.pos/12 le (ceil(p_nlac(dcows)))*p_calvAttr(\"%cowType%\",\"daysBetweenBirths\")/365))\n            = sum( curCycleLength $ (mod(mDist.pos-1,curCycleLength.pos+11) eq 0),\n                p_livingCalvesPerYear(dCows,\"%basBreed%\") * v_prob.l(\"%cowType%\",curCycleLength)  );\n</code></pre> <p>For a cow with a lifespan of four lactations, the calving distribution is depicted in the following figure. Notice how the distribution widens with increasing amounts of lactations.</p> <p> :    Figure 2: Calving Distribution of a Cow with Four Lactations, according to the Endogenous Calculation. :    Source: Own representation.</p> <p>The equation calvesRaisBal_ adds the possibility to buy calves for raising from the market (v_herdStart(calvesBought)) besides the own produced calves (v_herdStartBornCalvsRais) by adding them to the herd of raised calves as in v_herdStart</p> <pre><code>calvesRaisBal_(calvsRais,dairyBreeds,t_n(t,nCur),m)\n      $ ( sum(actHerds(calvs,dairyBreeds,feedRegime,t,m),1) $ (p_Year(t) le p_year(\"%lastYear%\"))) ..\n\n    v_herdStart(calvsRais,dairyBreeds,t,nCur,m)\n\n       =E=\n\n          v_herdStartBornCalvsRais(calvsRais,dairyBreeds,t,nCur,m)\n\n        + sum(calvesBought $ ((calvsRais.pos eq calvesBought.pos) $ actHerds(calvesBought,dairyBreeds,\"\",t,m)),\n            v_herdStart(calvesBought,dairyBreeds,t,nCur,m))  $ (not sameas(dairyBreeds,\"%crossBreed%\"))\n;\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/AnimalProduction/cattle/#sexing","title":"Sexing","text":"<p>The GUI allows the use of sexing. To do this, the corresponding fields must be clicked on in the Cows tab under Breeding and costs must be specified. Sexing changes the male-female balance equation (see gams\\model\\cattle_module.gms):</p> <pre><code>maleFemaleRel_(breeds, t_n(t,nCur),m) $ (sum(actHerds(calvs,breeds,feedRegime,t,m),1)\n                                                        $ (p_Year(t) le p_year(\"%lastYear%\"))) ..\n\n                 [\n                   v_herdStartBornCalvsRais(\"fCalvsRais\",breeds,t,nCur,m) $ sum(feedRegime,actHerds(\"fCalvsRais\",breeds,feedRegime,t,m))\n                 + v_herdStart(\"fCalvsSold\",breeds,t,nCur,m) $ sum(feedRegime,actHerds(\"fCalvsSold\",breeds,feedRegime,t,m))\n                 ] /0.495\n\n                 - v_sexingF(breeds,t,nCur,m)*0.5\n                 + v_sexingM(breeds,t,nCur,m)*0.5\n\n             =E=\n                 + v_sexingF(breeds,t,nCur,m)*0.5\n                 - v_sexingM(breeds,t,nCur,m)*0.5\n\n             +[\n                   v_herdStartBornCalvsRais(\"mCalvsRais\",breeds,t,nCur,m) $ sum(feedRegime,actHerds(\"mCalvsRais\",breeds,feedRegime,t,m))\n                 + v_herdStart(\"mCalvsSold\",breeds,t,nCur,m) $ sum(feedRegime,actHerds(\"mCalvsSold\",breeds,feedRegime,t,m))\n              ] / 0.505;\n</code></pre> <p>If sexing is switched off, the number of female siblings (LHS) must be (approximately) equal to the males ones (RHS). Sexing an insemination to male will take 0.5 female out and increase the number of males of 0.5. Female sexing leads to the opposite effect.</p>"},{"location":"FarmDynDocumentation/ModelDescription/AnimalProduction/cattle/#grassland","title":"Grassland","text":"<p>One of the particularities of cattle is the utilization of grassland for production. Through the process of enteric fermentation cattle, like other ruminants, is able to utilize cellulose as feed. Because grasslandis specific to cattle some of the related equations that depict grasslands in the model are part of the cattle module. In the model, grasslands  can be harvested and stored as silage or hay that then can be fed over the year or it can be used as pasture where the harvested material has to be consumed by the grazing herd directly.  The total annual amount of grazed material is calculated in prodsMY_. v_prodsIntr is the monthly sum of the  output from grazing.</p> <p>* *   --- production of non-marketable feed per intra-year planning period *     prodsMY_(curProds(prodsMonthly),t_n(tCur(t),nCur),m) $ sum( (c_p_t_i(curCrops(crops),plot,till,intens))                                                         $ (v_cropHa.up(crops,plot,till,intens,tCur,nCur) ne 0),                                                           sum(plot_soil(plot,soil),p_OCoeffM%l%(crops,soil,till,intens,prodsMonthly,m,t))                                                          $ curProds(prodsMonthly)) ..</p> <pre><code>   v_prodsIntr(prodsMonthly,t,nCur,m)\n     =e= sum( c_p_t_i(curCrops(crops),plot,till,intens),\n                  v_cropHa(crops,plot,till,intens,t,nCur)\n                     * sum(plot_soil(plot,soil) $ p_OCoeffM%l%(crops,soil,till,intens,prodsMonthly,m,t),\n                                    p_OCoeffM(crops,soil,till,intens,prodsMonthly,m,t)));\n</code></pre> <p>The monthly grazing output v_prodsIntr has to be completely used as feed, v_feedUseM.    </p> <p>* *   --- these products must be exhausted by feed use *     prodsM_(curProds(prodsMonthly),m,t_n(tCur(t),nCur)) ..</p> <pre><code>   sum(sameas(prodsMonthly,curFeeds(feedsM)),v_feedUseM(feedsM,m,t,nCur))\n\n     =e=\n</code></pre> <ul> <li>--- crop output            v_prodsIntr(prodsMonthly,t,nCur,m) $ sum( c_p_t_i(curCrops(crops),plot,till,intens)                 $ (v_cropHa.up(crops,plot,till,intens,t,nCur) ne 0),                   sum(plot_soil(plot,soil),p_OCoeffM%l%(crops,soil,till,intens,prodsMonthly,m,t))) ;</li> </ul> <p>In herdExcrPast_ the grazing herds are distributed to the grazing types based on their daily time on the pasture. The grazing regime \"fullGraz\" corresponds to the animals staying the whole day on pasture while partGraz corresponds to the animals staying half the day on pasture. This is considered trough the multipliers 1 and 0.5, respectively. Which herd grazes on which plot at which time is finally depicted in the variable v_herdExcrPast.   </p> <p>* *   -- distribute grazing herds to grazing plots *      (nutrient balancing equation in templ.gms should lead to a reasonable allocation) *     herdExcrPast_(possHerds,grazRegime,t_n(tCur(t),nCur),m) $ (sum(grasscrops $ (p_grazMonth(grassCrops,m)&gt;0),1)                                                                 $ sum(actHerds(possHerds,breeds,grazRegime,t,m)                                                                    $ sum(nut2,p_nutExcreDueV(possHerds,grazRegime,nut2)),1)) ..</p> <pre><code>    sum(c_p_t_i(curCrops(pastcrops),plot,till,intens)$(p_grazMonth(pastCrops,m)&gt;0),\n       v_herdExcrPast(curCrops,plot,till,intens,possHerds,grazRegime,tCur,nCur,m)) =e=\n\n                   sum(actHerds(possHerds,breeds,grazRegime,t,m)\n                          $ sum(nut2,p_nutExcreDueV(possHerds,grazRegime,nut2)),\n                             v_herdSize(possHerds,breeds,grazRegime,t,nCur,m)\n\n                               * (     1   $ sameas(grazRegime,\"fullGraz\")\n                                     + 0.5 $ sameas(grazRegime,\"partGraz\")));\n</code></pre> <p>Based on the herds grazign for each grazing type the aoccrding nutrient excretion is calculated in nut2ManurePast_. The number of animals grazing on each grazign type in the variable v_herdExcrPast is multiplied by the animal specific nutrient excretion in p_nutExcreDueV. The nutrients excreted on each type are shown in the variable v_nut2ManurePast.                   </p> <p>* * --- derive for each plot the resulting nutrient excretion *    nut2ManurePast_(c_p_t_i(curCrops(pastcrops),plot,till,intens),allNut,t_n(tCur(t),nCur),m)                                                 $ ( (p_grazMonth(pastCrops,m)&gt;0)                                                     $ sum(actHerds(possHerds,breeds,grazRegime,t,m),1)) ..</p> <pre><code> v_nut2ManurePast(pastcrops,plot,till,intens,allNut,t,nCur,m)\n    =E=  sum((possHerds,grazRegime) $ sum(actHerds(possHerds,breeds,grazRegime,t,m),1),\n                   v_herdExcrPast(pastcrops,plot,till,intens,possHerds,grazRegime,t,nCur,m)\n                                              * p_nutExcreDueV(possHerds,grazRegime,allNut)) * 1/card(m);\n</code></pre> <p>The total amount of excreted nutrients on pastures is summarized in the variable v_nutExcrPast</p> <p>* *  --- add up over excretion allocated to individual grazing activities *    nutExcrPast_(allNut,t_n(tCur(t),nCur),m)$(  sum(pastcrops $(p_grazMonth(pastCrops,m)&gt;0),1)                                                 $ sum(actHerds(possHerds,breeds,grazRegime,t,m),1)) ..</p> <pre><code>   v_nutExcrPast(allNut,t,nCur,m) =e= sum(c_p_t_i(curCrops(pastcrops),plot,till,intens)\n                                               $ ((p_grazMonth(pastCrops,m)&gt;0)\n                                               $ sum(actHerds(possHerds,breeds,grazRegime,t,m),1)),\n                                           v_Nut2ManurePast(pastcrops,plot,till,intens,allNut,t,nCur,m));\n</code></pre> <p>For the calculation of methane emissions from pasture the physical amount of excreta is calculated in manQuantPast_. The calculation is analogue to the nutrient calculation in nut2ManurePast_.</p> <p>* *   --- manure quantity excreted on pasture for emission calculation *</p> <pre><code>manQuantPast_(pastcrops,plot,till,intens,curManChain(manChain),t_n(tCur(t),nCur),m)\n      $ (c_p_t_i(pastcrops,plot,till,intens) $ (p_grazMonth(pastCrops,m)&gt;0) ) ..\n\n    v_manQuantPast(pastcrops,plot,till,intens,manChain,t,nCur,m)  =e=\n\n             sum((possHerds,grazRegime) $ (sum(actHerds(possHerds,breeds,grazRegime,t,m),1)\n                                              $ manChain_herd(curManChain,possHerds)\n                                              $c_p_t_i(pastcrops,plot,till,intens)),\n                             v_herdExcrPast(pastcrops,plot,till,intens,possHerds,grazRegime,t,nCur,m)\n                                                        * p_manQuantMonth(possHerds,curManChain)) * 1/card(m);\n</code></pre> <p>Grasslands are a distinct landuse-type in the model. Therefore, per default they are exempted from arable lands by limiting their acreage in v_cropHa to the endowment of grasslands given by the number of plots v_buyPlot and their respective size p_buyPlotSize. If chosen via the interface, grassland maybe used as cut grasland for hay and silage can be grown on arable lands. In that case only grazing use of grassland is limited to the endowment of grassland.</p> <p>* *  --- Equation to ensure that there is no gras on arable land *    fixGrasLand_(t_n(tCur(t),nCur)) ..</p> <pre><code>  $$iftheni.grasOnArab \"%grasOnArab%\"==\"true\"\n</code></pre> <p>*          --- grasslands for cutting allowed on arable land: exclude that pasture use exceed available *             land equipped with fences *           sum( c_p_t_i(grassCrops(curCrops),plot,till,intens) $ (past(curCrops) or mixPast(curCrops)), v_cropHa(curCrops,plot,till,intens,t,nCur)  )       $$else.grasOnArab           sum( c_p_t_i(grassCrops(curCrops),plot,till,intens), v_cropHa(curCrops,plot,till,intens,t,nCur)  )       $$endif.grasOnArab                                 =l=           sum(plot $ (not plot_landType(plot,\"arab\")), p_plotSize(plot)              + sum( (t1,nCur1) $ (t_n(t1,nCur1) $ tcur(t1) $ isNodeBefore(nCur,nCur1) $ (ord(t1) le ord(t))), v_buyPlot(plot,t1,nCur1)p_buyPlotSize))              ;</p> <p>A further differentiation of grasslands are pastures that are non-machineable meaning they can only be used through grazing animals. ???</p> <p>* *  --- Equation to ensure no cut grasland on pastureland *    fixPastLand_(t_n(tCur(t),nCur))  ..</p> <pre><code>   sum( c_p_t_i(curCrops,plot,till,intens) $ (gras(curCrops) or mixPast(curCrops)), v_cropHa(curCrops,plot,till,intens,t,nCur)  )\n                            =l=\n  $$iftheni.grasOnArab \"%grasOnArab%\"==\"true\"\n      sum(plot $ (not plot_landType(plot,\"past\")), p_plotSize(plot)\n         + sum( (t1,nCur1) $ (t_n(t1,nCur1) $ tcur(t1) $ isNodeBefore(nCur,nCur1) $ (ord(t1) le ord(t))), v_buyPlot(plot,t1,nCur1)*p_buyPlotSize))\n  $$else.grasOnArab\n      sum(plot_landType(plot,\"gras\") $ (not plot_landType(plot,\"past\")), p_plotSize(plot)\n         + sum((t1,nCur1) $ (t_n(t1,nCur1) $ tcur(t1) $ isNodeBefore(nCur,nCur1) $ (ord(t1) le ord(t))), v_buyPlot(plot,t1,nCur1)*p_buyPlotSize)\n      )\n  $$endif.grasOnArab\n   ;\n</code></pre> <p>The helper equations hasHerdOrderDairy_ and hasHerdOrderMotherCows_ make sure that if no herd is present in year t-1, no herd is there in the current year.</p> <p>* *   --- if no herd in t-1, then also no herd in the current year *       (for dairy and mother cows) * $iftheni.dh %dairyherd%==true     hasHerdOrderDairy_(tCur(t),nCur) $ (tCur(t-1) $ t_n(t,nCur)) ..</p> <pre><code>   v_HasBranch(\"dairy\",t,nCur) =L= sum(t_n(t-1,nCur1) $ anc(nCur,nCur1), v_hasBranch(\"dairy\",t-1,nCur1));\n</code></pre> <p>$endif.dh</p> <p>$iftheni.mc \"%farmBranchMotherCows%\"==\"on\"     hasHerdOrderMotherCows_(tCur(t),nCur) $ (tCur(t-1) $ t_n(t,nCur)) ..</p> <pre><code>   v_HasBranch(\"motherCows\",t,nCur) =L= sum(t_n(t-1,nCur1) $ anc(nCur,nCur1), v_hasBranch(\"motherCows\",t-1,nCur1));\n</code></pre> <p>$endif.mc</p> <p>Further helper equations make sure that the initial cattle herd that is build up in pre-runs is equal to the herds in the starting year of the simulation. Therefore, the first simulated year is determined depending on the model dynamics in the following:</p> <p>* *   --- steady state before the actual simulation starts * $iftheni.compStat \"%Dynamics%\"==\"Comparative-static\"</p> <p>$eval firstYear1 %firstYear%</p> <p>$elseifi.compStat \"%Dynamics%\"==\"Short run\"</p> <p>$eval firstYear1 %firstYear%</p> <p>$else.compStat</p> <p>$eval firstYear1 %firstYear%+1</p> <p>$endif.compStat</p> <p>The equations herdsBefore_ and herdsStartBefore_ then force the herd-size of the pre-run into the first year of the simulation.</p> <pre><code>herdsBefore_(possHerds(herds),breeds,feedRegime,tbefore,t,nCur,m) $ (  actHerds(herds,breeds,feedRegime,tBefore,m)\n                                                          $ actHerds(herds,breeds,feedRegime,t,m)\n                     $ (sameas(t,\"%firstYear%\") $ t_n(t,nCur))\n                                               $ (\n   $$iftheni %cowherd%==true\n                                                       sameas(herds,\"cows\")\n                                                   or  sum(sameas(herds,heifs),1)\n                                                   or  sameas(herds,\"slgtCows\")\n                                                   or  sameas(herds,\"remonte\")\n                                                   or  sameas(herds,\"motherCow\")\n\n\n                                                   or  remonte(herds)\n                                                   or  sameas(herds,\"fCalvsRais\")\n                                                   or  sameas(herds,\"mCalvsRais\")\n                                                   or  sameas(herds,\"fCalvsSold\")\n                                                   or  sameas(herds,\"mCalvsSold\")\n\n        $$ifi \"%farmBranchBeef%\"==\"on\"             or\n   $$endif\n\n   $$ifi \"%farmBranchBeef%\"==\"on\"                      sum(sameas(herds,bulls),1)\n   $$ifi \"%farmBranchBeef%\"==\"on\"                  or  sameas(herds,\"bullsSold\")\n   $$ifi \"%farmBranchBeef%\"==\"on\"                  or  sameas(herds,\"bullsBought\")\n   $$ifi \"%farmBranchMotherCows%\"==\"on\"            or sum(sameas(herds,bulls),1)\n                                           )) ..\n\n\n\n  sum(t_n(tBefore,nCur1) $ sameScen(nCur1,nCur) ,v_herdSize(herds,breeds,feedRegime,tBefore,nCur1,m))\n      =E= v_herdSize(herds,breeds,feedRegime,t,nCur,m);\n\nherdsStartBefore_(possHerds(herds),breeds,tbefore,t,nCur,m) $ (sum(feedRegime,actHerds(herds,breeds,feedRegime,tBefore,m))\n                            $ (sameas(t,\"%firstYear%\") or sameas(t,\"%firstYear1%\")) $ t_n(t,nCur)\n                                               $  (\n                                                        sameas(herds,\"MotherCow\")\n                                   $$ifi defined heifs  or sum(sameas(herds,heifs),1)\n                                   $$ifi defined bulls  or sum(sameas(herds,bulls),1)\n                                                     or sameas(herds,\"remonteMotherCows\")\n                                                  )\n                                               ) ..\n</code></pre> <ul> <li>--- steady state: starting herds before the first fully simulated year are equal to that one *       sum(t_n(tBefore,nCur1) $ sameScen(nCur1,nCur),v_herdStart(herds,breeds,tBefore,nCur1,m))               =E=  v_herdStart(herds,breeds,t,nCur,m);</li> </ul>"},{"location":"FarmDynDocumentation/ModelDescription/AnimalProduction/cattle/#references","title":"References","text":"<p>Huth, F.W. (1995): Die Laktation des Rindes -- Analyse, Einflu\u00df, Korrektur. Eugen Ulmer GmbH &amp; Co. Stuttgart</p> <ol> <li> <p>The regression models originate from the \"Zifo2\" Target-value fodder optimization program of the LfL Bayern.\u00a0\u21a9</p> </li> </ol>"},{"location":"FarmDynDocumentation/ModelDescription/AnimalProduction/herd_dynamics/","title":"Herd Dynamics","text":"<p>Abstract The herd dynamics describe the dynamic character of the stock of a certain animal herd. This includes economic activities of selling and buying and natural dynamics such as birth or moving into another age-stage within the same animal group. Further, herds are differentiated by gender, breeds, production objectives and month in each year.</p> <p>The model uses two different variables to describe herds: v_herdStart describes the number of animals by type which enter a production process at a certain time, while v_herdSize describes the number of animals by type at the farm at a specific time. More precisely the standing herd, v_herdSize, can be described as animals which joint the herd since the beginning of the production process, v_herdStart, minus sold and slaughtered ones, as can be seen in the following equation. The parameter p_mDist in this equation describes the difference in months between two time points defined by year, t, t1, and month, m, m1. The parameter p_prodLength depicts the length of the production process in months.</p> <pre><code>herdSize_(herds,breeds,tCur(t),nCur,m)\n    $ (sum(FeedRegime,actHerds(herds,breeds,feedRegime,t,m))\n    $  sum((t_n(t1,nCur1),feedRegime,m1)\n            $ (((-p_mDist(t,m,t1,m1) le (p_prodLength(herds,breeds)-1) $ (p_mDist(t,m,t1,m1) le 0))\n               or\n               ((abs(p_mDist(t,m,t1,m1)-12) le (p_prodLength(herds,breeds)-1)) $ (p_mDist(t,m,t1,m1)-12 le 0)) $ p_compStatHerd\n               )\n              $ actHerds(herds,breeds,feedRegime,t1,m1)\n              $ (balherds(herds)\n              $$ifi defined remonte or remonte(herds) or sameas(\"remonte\",herds)\n              )\n              $ t_n(t,nCur) $ isNodeBefore(nCur,nCur1)),\n        1)\n     ) ..\n\n  sum(feedRegime $ actHerds(herds,breeds,feedRegime,t,m),\n    v_herdSize(herds,breeds,feedRegime,t,nCur,m))\n  =E=\n*\n*         --- herds which started in the months before the production length, in case for piglets a separate construct is used\n*\n  sum((t_n(t1,nCur1),m1)\n    $ ((((-p_mDist(t,m,t1,m1) le (p_prodLength(herds,breeds)-1))\n        $ (p_mDist(t,m,t1,m1) le 0))\n        or\n        ((abs(p_mDist(t,m,t1,m1)-12) le (p_prodLength(herds,breeds)-1))\n        $ (p_mDist(t,m,t1,m1)-12 le 0)) $ p_compStatHerd\n       )\n       $ sum(feedRegime,actHerds(herds,breeds,feedRegime,t1,m1))\n       $ isNodeBefore(nCur,nCur1)\n       $$iftheni.sows \"%farmBranchSows%\" == \"on\"\n         $(not sameas(herds,\"piglets\"))\n       $$endif.sows\n     ),\n      v_herdStart(herds,breeds,t1,nCur1,m1)\n\n      $$iftheni.ch %cowHerd%==true\n*\n*       --- minus, in case of cows, slaughtered before reaching the final age\n*\n        -sum( (slgtCows,cows)\n          $ (sum(feedRegime, actHerds(slgtCows,breeds,feedRegime,t1,m1))\n            $ sameas(cows,herds) $ (slgtCows.pos eq cows.pos)),\n          v_herdStart(slgtCows,breeds,t1,nCur,m1))\n      $$endif.ch\n    )\n*\n*  --- add herds multiple times if their process length is longer than 12\n*\n\n  +  sum((t_n(t1,nCur1),m1)\n      $ (((-p_mDist(t,m,t1,m1) le (p_prodLength(herds,breeds)-1))\n          $\n          (   (abs(p_mDist(t,m,t1,m1)-12) le (p_prodLength(herds,breeds)-1))$ (p_mDist(t,m,t1,m1) le 0)\n          or  (abs(p_mDist(t,m,t1,m1)-24) le (p_prodLength(herds,breeds)-1))$ (p_mDist(t,m,t1,m1) ge 0)\n          ) $ p_compStatHerd $\n                                  $$ifi defined cows (not cows(herds) $ (p_prodLength(herds,breeds) gt 12))\n                                  $$ifi not defined cows (1 eq 1)\n         )\n         $ sum(feedRegime,actHerds(herds,breeds,feedRegime,t1,m1))\n         $ isNodeBefore(nCur,nCur1)\n         $$iftheni.sows \"%farmBranchSows%\" == \"on\"\n           $(not sameas(herds,\"piglets\"))\n         $$endif.sows\n      ),\n         v_herdStart(herds,breeds,t1,nCur1,m1)\n*\n*       --- minus, in case of cows, slaughtered before reaching the final age\n*\n      $$iftheni.ch %cowHerd%==true\n        -sum( (slgtCows,cows)\n          $ (sum(feedRegime, actHerds(slgtCows,breeds,feedRegime,t1,m1))\n            $ sameas(cows,herds) $ (slgtCows.pos eq cows.pos)),\n          v_herdStart(slgtCows,breeds,t1,nCur,m1))\n      $$endif.ch\n         )\n*\n*         --- Herd size dynamic for piglets separately to depict a correct transfer from year t to year t1 as well as account for temporal resolution adjustments\n*\n\n  $$iftheni.sows \"%farmBranchSows%\" == \"on\"\n    +  sum( (t_n(t1,nCur1),m1)\n      $ ((abs(p_mDist(t,m,t1,m1)) le (p_prodLengthB(herds,breeds) -1\n        $ (p_prodLengthB(herds,breeds) eq 1)))\n      $ (p_mDist(t,m,t1,m1) le 0)\n      $ isNodeBefore(nCur,nCur1)\n      $ sum(feedRegime,actHerds(herds,breeds,feedRegime,t1,m1))\n      $ (sameas(herds,\"youngPiglets\") or sameas(herds,\"piglets\"))\n      $ {\n        (sameas(t,t1) $ (not sameas(m  - p_prodLengthB(herds,breeds),m1)))\n        or ((not sameas(t,t1)) $ (sameas(\"Jan\",m))$ (sameas( m + 11, m1)))\n      }\n      ),\n         v_herdStart(herds,\"\",t1,nCur1,m1))\n  $$endif.sows\n;\n</code></pre> <p>The definition of the number of animals being added to the herd, v_herdStart, is described in the equation herdBal_. In the simplest case, where a 1:1 relation between a delivery and a use process exists, the number of new animals entering the different use processes balherds is equal to the number of new animals of the delivery process herds. This relation is depicted by the set herds_from_herds.</p> <p>One possible extension is that animals entering the herd can be alternatively bought from the market, defined by the set bought_to_herds. The symmetric case is when the raised/fattened animals are sold which is described by the sold_from_herds set.</p> <p>For the case where several delivering processes are available, for example heifers of a different process length replacing cows, the set herds_from_herds describes a 1:n relation. A similar case exists if one type of animal, say a raised female calve, can be used for different processes such as replacement or slaughter. In this case, the expression turns into a n:1 relation captured by the second additive expression in the equation herdBal_.</p> <p>In comparative static mode p_compStatHerd, all lags are removed such that a steady-state herd model is described.</p> <pre><code>herdsBal_(balHerds,breeds,tCur(t),nCur,m) $ (  sum(feedRegime,actherds(balHerds,breeds,feedRegime,t,m)) $ t_n(t,nCur)\n*\n     $ (p_Year(t) le p_year(\"%lastYear%\"))\n     $ (sum( (herds_from_herds(balHerds,herds,breeds),t1,m1)\n                   $ (( -p_mDist(t,m,t1,m1) eq round(p_prodLengthB(herds,breeds)))\n                           $  sum(feedRegime,actHerds(herds,breeds,feedRegime,t1,m1))),1)\n       $$iftheni.compStat \"%dynamics%\" == \"comparative-static\"\n         or (sum( (herds_from_herds(balHerds,herds,breeds),t1,m1)\n                   $ (( -p_mDist(t,m,t1,m1)+12 eq round(p_prodLengthB(herds,breeds)))\n                           $  sum(feedRegime,actHerds(herds,breeds,feedRegime,t1,m1))),1))\n       $$endif.compStat\n                           or sum((bought_to_herds(herds,breeds,balherds),feedRegime) $ actherds(herds,breeds,feedRegime,t,m),1)\n                           or sum((sold_comp_herds(herds,breeds,balherds),feedRegime) $ actherds(herds,breeds,feedRegime,t,m),1)  )\n                        ) ..\n*\n*      --- herd starting at current time point\n*\n          v_herdStart(balHerds,breeds,t,nCur,m)/p_herdYearScaler(balHerds,breeds)\n*\n*      --- plus herd starting at current time point which compete for the same input herds\n*\n     + sum( herds1 $ [ (sum(herds_from_herds(herds1,herds,breeds)\n                                      $ herds_from_herds(balHerds,herds,breeds),1)\n                    or sum(bought_to_herds(herds,breeds,herds1)\n                            $ bought_to_herds(herds,breeds,balherds),1))\n                    $ (not sameas(balHerds,herds1)) $  sum(feedRegime,actherds(herds1,breeds,feedRegime,t,m))],\n          v_herdStart(herds1,breeds,t,nCur,m)/p_herdYearScaler(herds1,breeds))\n\n         =e=\n*\n*      --- equal to the starting herd of the process wich generates these herds\n*\n     + sum( (herds_from_herds(balHerds,herds,breeds),t_n(t1,nCur1),m1)\n                   $ ( (  (-p_mDist(t,m,t1,m1)    eq round(p_prodLengthB(herds,breeds)) )\n                $$iftheni.compStat \"%dynamics%\" == \"comparative-static\"\n                     or (-p_mDist(t,m,t1,m1)+12 eq round(p_prodLengthB(herds,breeds)) )\n                $$endif.compStat\n                       )   $  sum(feedRegime,actHerds(herds,breeds,feedRegime,t1,m1)) $ isNodeBefore(nCur,nCur1)),\n                                    v_herdStart(herds,breeds,t1,nCur1,m1))\n*\n*      --- bought to herd (e.g. heifers bought from market)\n*\n     + sum( (bought_to_herds(herds,breeds,balherds))\n           $ sum(feedRegime,actherds(herds,breeds,feedRegime,t,m)), v_herdStart(herds,breeds,t,nCur,m))\n*\n*      --- sold animals from the competing process for these herds (e.g. using heifer for remonte or selling heifer)\n*\n     - sum( sold_comp_herds(herds,breeds,balherds) $ sum(feedRegime,actherds(herds,breeds,feedRegime,t,m)),\n            v_herdStart(herds,breeds,t,nCur,m));\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/AnimalProduction/pigs/","title":"Pig Module","text":"<p>The pig module, similar to the cattle module, is closely linked with the general herd module. The herd dynamics of the pig module are shown in Figure 1.</p> <p> :   Figure 1: Pig Module Management Decisions. :   Source: Own Illustration.</p> <p>The piglet production process starts with the production of young piglets born which are raised to sows as shown in the following equation:</p> <pre><code>$$iftheni.sows \"%farmBranchSows%\"==\"on\"\n\n       newPiglets_(t_n(tCur(t),nCur),m) $  sum(feedRegime,actHerds(\"sows\",\"\",feedRegime,t,m)) ..\n\n          v_herdStart(\"youngPiglets\",\"\",t,nCur,m)\n              =e=  sum(actHerds(\"sows\",\"\",feedRegime,t,m),\n                       v_herdSize(\"sows\",\"\",feedRegime,t,nCur,m) * p_OCoeff(\"sows\",\"youngPiglet\",\"\",t))/card(m);\n    $$endif.sows\n</code></pre> <p>Each sow produces on average 26.7 young piglets per year in the default parameterisation. After one month young piglets become weaners and remain 2 months within the herd before they are sold or transferred to the fattener branch. Labour and feed requirements are chosen according to a growing period of 41 days and a weight gain from 8 to 30 kg. The feeding-, stable- and labour requirements of the piglet production branch are steered by the sows and piglets herd size.</p> <p>The fattener farm branch distinguishes between four different stages of fatteners to account for different feeding and excretion values during the production process. Feeding levels and excretion values are connected via the set feedregime. This set allows to adapt feeding patterns, for instance to adjust nutrient output in response to legislatively given fertiliser restrictions. For a more thorough explanation of the feeding options, please refer to the pig feeds module in section 2.2.2. The piglets bought in a month are immediately transferred into early fatteners and to the next fattening stage after a month until they become fatteners and are sold as fattened pigs. Each stage lasts for one month. The weight development during the fattening process is assumed from 28 to 118kg live weight.</p> <p>As mentioned in the general herd module description, equations such as herd balance herdsBal_ and herd size, herdSize_ are used for the herd dynamic in the pig module. The following model code shows the elements of the herd used in the farm branch for sows.</p> <pre><code>$$iftheni.sows \"%farmBranchSows%\" == \"on\"\n\n      herds_from_herds(\"piglets\",\"youngPiglets\",\"\")  = yes;\n\n      bought_to_herds(\"youngSows\",\"\",\"sows\")         = yes;\n\n      actHerds(\"piglets\",\"\",feedRegimePigs,t,m)      = yes;\n      actHerds(\"sows\",\"\",feedRegimePigs,t,m)         = yes;\n      actHerds(\"youngPiglets\",\"\",feedRegimePigs,t,m) = yes;\n      actHerds(\"youngSows\",\"\",feedRegimePigs,t,m)    = yes;\n   $$endif.sows\n</code></pre> <p>The statements below show the elements of the herd used in the farm branch for fatteners:</p> <pre><code>$iftheni.pigHerd %pigHerd% == true\n   $$iftheni.fattners \"%farmBranchFattners%\" == \"on\"\n\n       actHerds(\"PigFattened\",\"\",feedRegimePigs,t,m)       = yes;\n       actHerds(\"Fattners\",\"\",feedRegimePigs,t,m)          = yes;\n       actHerds(\"earlyFattners\",\"\",feedRegimePigs,t,m)     = yes;\n       actHerds(\"midFattners\",\"\",feedRegimePigs,t,m)       = yes;\n       actHerds(\"lateFattners\",\"\",feedRegimePigs,t,m)      = yes;\n       actHerds(\"pigletsBought\",\"\",feedRegimePigs,t,m)     = yes;\n\n       bought_to_herds(\"pigletsBought\",\"\",\"earlyFattners\") = yes;\n\n       herds_from_herds(\"midfattners\",\"earlyfattners\",\"\")  = yes;\n       herds_from_herds(\"lateFattners\",\"midFattners\",\"\")   = yes;\n       herds_from_herds(\"Fattners\",\"lateFattners\",\"\")      = yes;\n\n   $$endif.fattners\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/AnimalProduction/pigs/#feeding","title":"Feeding","text":"<p>The feeding requirements for the piglet production branch differentiate between sows with the attached young piglets and the piglets after separation from the sows. Requirements are set for energy, crude protein, lysin, phosphorus feed and dry matter. Further, minimum and maximum requirements are set for certain feeds in order to reflect realistic feeding patterns. For example, a minimum requirement for oil in the feed intake is assumed to assure a correct viscosity.</p> <p>The fattening branch distinguishes between four fattening stages to provide the option of nitrogen and phosphorus reduced feeding (N/P). It includes the stages earlyFattners, midFattners, and lateFattners. Three feeding regimes are applicable, which are: normal feed, reduced N/P feed and highly reduced N/P feed. The primary differences between the feeding schemes are the adjustments of daily nutrient requirements depending on the stage a fattening pig is currently in. For instance, with the normal feed there are only two different feeding requirements; a daily requirement for the weight range from 28-40 kg which is in the early fattening phase and a daily requirement from 40-118 kg which assumes daily feed requirements in the mid, late and finishing fattening stage. In contrast, the N/P reduced feeding phase differentiates between daily nutrient requirements for the weight ranges 28-40 kg, 40-70 kg and 70-118 kg. Thus, all stages require different daily nutrient requirements. In accordance with the piglet production branch, the fattening branch also imposes maximal and minimal values for certain products to account for digestibility, correct feeding textures and mineral provision.</p> <p>The requirements are used to determine the optimal feeding mix shown in the equation reqPigs_. Hence, it can be seen which feeding products are used by which herd type at a certain time. The equation feedSourcePig_ determines the source of feed, i.e. whether it is purchased or produced on farm.</p> <pre><code>reqPigs_(possHerds,feedAttr,feedRegime,t_n(tCur(t),nCur),m) $ ( sum(actHerds(herds,\"\",feedRegime,t,m),1)\n                                           $ p_feedReqPig%l%(possHerds,feedRegime,feedAttr)\n                                           $ (not (sameas(possherds,\"pigletsBought\") or sameas(possherds,\"youngSows\")\n                                                                                     or sameas(possherds,\"youngPiglets\")))) ..\n\n         v_herdSize(possHerds,\"\",feedRegime,t,nCur,m) * p_feedReqPig(possHerds,feedRegime,feedAttr)\n                =L= sum(feedspig $ sum(sameas(feedsPig,curInputs),1), v_feedingPig(possherds,feedsPig,feedRegime,t,nCur,m) * p_feedAttrPig(feedsPig,feedAttr));\n</code></pre> <pre><code>feedSourcePig_(feedspig,t_n(tCur(t),nCur)) $ (sum(actHerds(herds,\"\",feedRegime,t,m),1) $ sum(sameas(feedsPig,curInputs),1))  ..\n\n        v_feedOwnPig(feedspig,t,nCur) $ sum(sameas(curProds,feedspig),1)\n      + v_feedPurchPig(feedspig,t,nCur)\n\n          =E= sum((possherds,feedRegime,m)\n                  $ [   (not (    sameas(possherds,\"pigletsBought\") or sameas(possherds,\"youngSows\")\n                               or sameas(possherds,\"youngPiglets\")))\n                      $ sum(actHerds(possHerds,\"\",feedRegime,t,m),1)],\n                       v_feedingPig(possherds,feedsPig,feedRegime,t,nCur,m));\n</code></pre> <p>The upper and lower bound for the feeding mix are then determined by feedTotPig_, feedMaxPig_, feedMinPig_ (not additionally shown here) which allows certain flexibility in the feeding mix.</p> <p>However, for the fatteners the feeding mix is fixed for different feeding regimes to precisely reproduce empirically found feeding ratios.</p>"},{"location":"FarmDynDocumentation/ModelDescription/AnimalProduction/pigs/#pig-specific-manure-excretion","title":"Pig Specific Manure Excretion","text":"<p>With regard to excretion of animals, relevant equations and variables can be found in the general_herd_module.gms. v_manQuantM is the monthly volume in cubic meter of manure produced. As a default, liquid manure is considered in the model. The monthly manure excretion, v_manQuantM, is computed in the following equation:</p> <pre><code>manQuantM_(curManChain(manChain),t_n(tCur,nCur),m) $ (not sameas(curManChain,\"LiquidBiogas\")) ..\n\n        v_manQuantM(manChain,tCur,nCur,m)\n\n          =e=\n               sum( actherds(possHerds,breeds,feedRegime,tCur,m) $ (manChain_herd(curManChain,possHerds) $ p_prodLength(possherds,breeds)),\n                   p_manQuantMonth(possHerds,curManChain) * ( 1 - 1   $ sameas(feedRegime,\"fullGraz\")\n                                                                - 0.5 $ sameas(feedRegime,\"partGraz\"))\n                    * v_herdSize(possHerds,breeds,feedRegime,tCur,nCur,m));\n</code></pre> <p>Furthermore, the monthly excretion of nutrients, NTAN (total ammonia nitrogen), Norg (organic nitrogen) and P (phosphorus) is calculated, multiplying v_herdsize and p_nut2ManMonth. For cows, the excretion rate depends on animal category and feeding regime. Corresponding parameters can be found in coeffgen\\manure.gms (not shown here).</p>"},{"location":"FarmDynDocumentation/ModelDescription/BiodiversityAssessment/abstract_biodiversity_assessment/","title":"Biodiversity Assessment","text":"<p>FarmDyn comprises three methods for an post-model estimation of the effect of a simulated agricultural production programme on biodiversity. The method according to Paracchini and Britz (2010) uses crop diversity, fertiliser use and a proxy for management intensity to draw conclusions about biodiversity. The more sophisticated method based on the biodiversity part of the Sustainablity Monitoring and Assessment Routinge (SMART) of the Swiss FibL Institute determines a variety of biodiversity indicators based on the production programme. This method goes into more detail and distinguishes not only the overall impact but also the impact on ecosystem diversity, genetic diversity and species diversity. An implementation of the advanced SALCA-Biodiversity (SALCA-BD) method developed by the Swiss Competence Centre Agroscope can be used to determine the influence of different management practices or the entire agricultural production programme on a total of eleven indicator species groups.</p> <p>The calculation of the post-model biodiversity assessments can be activated in FarmDyn's Graphical User Interface (GUI) in the tab \"Environmental Impacts and Restrictions\". Furthermore, a selection can be made between the methods.</p> <p>It should be noted that the calculations according to the SALCA method are not freely available, but are only possible on request. </p>"},{"location":"FarmDynDocumentation/ModelDescription/BiodiversityAssessment/paracchini_britz_score/","title":"Paracchini-Britz-Score","text":"<p>The Paracchini-Britz-Score calculated in FarmDyn is a modified version of the common pan-European indicator described by Paracchini and Britz (2010) and is based on the assumptions that agriculture can be beneficial for biodiversity and that diverse crop rotations in combination with low management intensities are best for biodiversity. The Paracchini-Britz-Score consists of three sub-indices: (1) a Modified-Shannon-Index, (2) a N-Fertilisation-Index and (3) a Ruminant-Index. All three indices are standardised to take values between 0 and 1. A higher grade stands for a better biodiversity score. The three indices are weighted to the final Paracchini-Britz-Score based on the area for which they are determined.</p>"},{"location":"FarmDynDocumentation/ModelDescription/BiodiversityAssessment/paracchini_britz_score/#modified-shannon-index","title":"Modified-Shannon-Index","text":"<p>The Modified-Shannon-Index is used to capture the diversity and evenness of the distribution of the crops grown on a farm. The index is used to evaluate the assumption that diverse crop rotations in equal shares are best for biodiversity and is calculated according to the following formula:</p> <p>Modiefied-Shannon-Index = $ \\dfrac{ - \\displaystyle\\sum_{ i  }^{   } \\left( \\dfrac{  { n  }{ i  }    }{ N  }   \\cdot   \\ln\\left(  \\dfrac{  { n  }    }{ N  }    \\right)   \\right)    }{  \\ln\\left( S  \\right)    } $  </p> <p>with: \\({ n  }_{ i  }\\) = hectares of arable land devoted to crop group i \\(N\\)             = endowed hectares of arable land \\(S\\)             = number of crop groups which can potentially be grown (FarmDyn contains 27 crop groups)</p> <p>The corresponding GAMS code can be found in the directory gams\\exploiter\\biodiv_ind_simple.gms.</p>"},{"location":"FarmDynDocumentation/ModelDescription/BiodiversityAssessment/paracchini_britz_score/#n-fertilisation-index","title":"N-Fertilisation-Index","text":"<p>The N-Fertilisation-Index is used as a proxy for the overall management intensity. For the calculation, the amount of manure and mineral nitrogen fertiliser applied per ha and year p_NFert(t) is first determined. Using a step-wise linear function described in Paracchini and Britz (2010), this value is then assigned the final index value p_NFertIndex(t):</p> <pre><code>p_NFert(t) $ p_totLand(t)  = sum( t_n(t,nCur), v_nutTotalAppliedYear(\"n\",t,nCur)*p_probN(nCur)) / p_totLand(t);\n\n  p_NFertIndex(t) = + (1.0 -  p_NFert(t)        /  30 * 0.2) $((p_NFert(t) &lt;=  30))\n                    + (0.8 - (p_NFert(t) -  30) /  70 * 0.3) $((p_NFert(t) &gt;   30)  $(p_NFert(t) &lt;= 100))\n                    + (0.5 - (p_NFert(t) - 100) / 100 * 0.4) $((p_NFert(t) &gt;  100)  $(p_NFert(t) &lt;= 200))\n                    + (0.1 - (p_NFert(t) - 200) / 800 * 0.1) $((p_NFert(t) &gt;  200)  $(p_NFert(t) &lt;= 800));\n</code></pre> <p>The figure below illustrates the step-wise linear function for a better understanding of the code:</p> <p> :   Figure 1: Step-wise Linear Function of the N-Fertilisation-Index.     Source: Own illustration based on PARACCHINI and BRITZ (2010).</p>"},{"location":"FarmDynDocumentation/ModelDescription/BiodiversityAssessment/paracchini_britz_score/#ruminant-index","title":"Ruminant-Index","text":"<p>The Ruminant-Index refers to the stocking density of ruminants in livestock units (LU) per ha as a proxy for the management intensity of grassland and of arable land used for fodder production. For the calculation, the ruminant stocking density of the modelled production programme is first determined:</p> <pre><code>$$ifi defined v_sumGV p_StockDens(t) $ (p_RumLand(t) &gt; 0) =  sum(t_n(t,nCur),v_sumGV(t,nCur))/p_rumLand(t);\n                        p_StockDens(t) $ (p_RumLand(t) = 0) = 0;\n</code></pre> <p>Subsequently, the final Ruminant-Index is again determined using a step-wise linear function described in Paracchini and Britz (2010). This function considers ruminant stocking densities between 0.64 and 1.368 as beneficial for biodiversity. The mean value of 1,004 therefore serves as the optimum. Below the code and an illustration of this function are shown:</p> <pre><code>p_RumIndex(t) $ (p_stockDens(t) = 0) = 0;\n\n    p_RumIndex(t) =   (0.1 + (p_stockDens(t) - 0.00) / p_MinStockDens * 0.7)\n                        $((p_stockDens(t) &lt;= p_MinStockDens) $(p_stockDens(t) &gt; 0))\n\n                    + (0.8 + (p_stockDens(t) - p_MinStockDens) / (p_OptStockDens - p_MinStockDens) * 0.2)\n                        $((p_stockDens(t) &gt; p_MinStockDens) $(p_stockDens(t) &lt;= p_OptStockDens))\n\n                    + (1.0 - (p_stockDens(t) - p_OptStockDens) / (p_MaxStockDens - p_OptStockDens) * 0.2)\n                        $((p_stockDens(t) &gt; p_OptStockDens) $(p_stockDens(t) &lt;= p_MaxStockDens))\n\n                    + (0.8 - (p_stockDens(t) - p_MaxStockDens) / (2 * p_MaxStockDens) * 0.7)\n                        $((p_stockDens(t) &gt; p_MaxStockDens) $(p_stockDens(t) &lt;= p_MaxStockDens * 3))\n\n                    + (0.1 - (p_stockDens(t) - p_MaxStockDens * 3) / (p_MaxStockDens *10)*0.1)\n                        $((p_stockDens(t) &gt; p_MaxStockDens * 3));\n</code></pre> <p> :   Figure 2: Step-wise Linear Function of the Ruminant-Index.     Source: Own illustration based on PARACCHINI and BRITZ (2010).</p>"},{"location":"FarmDynDocumentation/ModelDescription/BiodiversityAssessment/paracchini_britz_score/#final-paracchini-britz-score","title":"Final Paracchini-Britz-Score","text":"<p>The final Paracchini-Britz-Score is calculated by weighting and summing up the three sub-indices. Thereby, the areas which are of relevance for the respective sub-index serve as weights. This is the arable land in case of the Modified-Shannon-Index (p_ShanLand(t)), the total land in case of the N-Fertilisation-Index (p_NLand(t)) and the grassland and the arable land on which fodder is produced in case of the Ruminant-Index (p_RumLand(t)). The sum of these 3 parameters is larger than the actual land endowment of the modelled farm and must therefore be determined in another parameter p_ImTotLand(t) for weighting:  </p> <pre><code>p_ImTotLand(t) = p_ShanLand(t) + p_NLand(t) + p_RumLand(t);\n\n  p_ShanLandShare(t) $ (p_ImTotLand(t) &gt; 0) = p_ShanLand(t) / p_ImTotLand(t);\n\n  p_NLandShare(t) $ (p_ImTotLand(t) &gt; 0)    = p_NLand(t) / p_ImTotLand(t);\n\n  p_RumLandShare(t) $ (p_ImTotLand(t) &gt; 0)  = p_RumLand(t) / p_ImTotLand(t);\n\n  p_SollIndex(t) =\n                      p_NewShannonIndex(t) * p_ShanLandShare(t)\n                    + p_NFertIndex(t)      * p_NLandShare(t)\n                    + p_RumIndex(t)        * p_RumLandShare(t);\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/BiodiversityAssessment/salca_method/","title":"SALCA-BD Method","text":"<p>SALCA-BD is a highly detailed biodiversity assessment method developed by the Swiss Competence Centre Agroscope. The following explanation of this method is based on JEANNERET et al. (2009; 2014).</p> <p>SALCA-BD examines the impact of agricultural activities on eleven indicator species groups (ISGs), focusing on organismic diversity. These ISGs are depicted in the set s_bioType_e:</p> <pre><code>set biodType_e /\n      \"Grassland flora\"\n      \"Flora arable land\"\n      \"Birds\"\n      \"Small mammals\"\n      \"Amphibians\"\n      \"Mollusks\"\n      \"Spiders\"\n      \"Ground beetles\"\n      \"Butterflies\"\n      \"Wild bees\"\n      \"Grasshoppers\"\n/;\n</code></pre> <p>Inventories are used to calculate biodiversity scores. These inventories describe the agricultural practices of a cultivated crop in detail and distinguishes between 2 habitat type levels and 3 management levels. The following figure gives an overview of the structure of such an inventory:</p> <p> :   Figure 1: General Structure of SALCA Inventories.     Source: Own illustration based on JEANNERET et al. (2009; 2014).     Remark: One example in black, further selection options in grey.</p> <p>SALCA inventories were created for all FarmDyn crops, differentiated by cropping system and mechanisation. The inventories are stored externally and are read into the GAMS code in GDX format:</p> <pre><code>* --- parameter storing the SALCA inventory IDs differentiated by crop and system\n  parameter p_salcaInv(*,*,*);\n$GDXIN \"%datDir%/SALCAPrep/InventareGDX/biod_ind_salca_Inv.gdx\"\n  $$LOAD p_salcaInv\n</code></pre> <p>The SALCA-BD method offers grades evaluating the impact for each management option on each ISG. The grades are confidentially stored in separate file linked to the inventories and also read in to the GAMS code in GDX format:</p> <pre><code>* --- load the salca weights and grades from salcaWeights.gdx\n  parameter p_salcaWeigthsCompact(ID,biodType,BewNiv1,coeffs)\n            p_salcaWeigthsCompact3(ID,BewNiv1,BewNiv2,BewNiv3,biodType,coeffs);\n  execute_load  \"%datDir%/SALCAPrep/salcaWeights.gdx\" p_salcaWeigthsCompact,p_salcaWeigthsCompact3;\n</code></pre> <p>The grades range from 0 - 5. Grade 0 refers to the ISG being not affected as it does not occur in the habitat. The grades from 1-5 refers to the population change, grade 1 to a strong depletion, grade 3 to a neutral impact on the population size and grade 5 to strong populational increase. The grades are weighted by a coefficient ranging from 0 - 10, referring to the importance of the habitat type and of the management type (e.g. fertilisation vs. plant protection) for the ISG under consideration. The grade weighted by the coefficient results in the biodiversity score for the option. If multiple options belonging to one management level III are selected, either the mean or the minimum of the biodiversity scores is used, depending on the ISG\u2019s ability to recover from management activities. The habitat score for one agricultural activity is calculated by building the mean of the biodiversity scores of all management level III.</p> <pre><code>* --- Sum of all biodiversity scores, each BewNiv3 enters sum with one entry\n  p_salcaRes3(curCrops,sys,\"\",biodType,\"\",\"\",\"\",\"cur\",\"SumScore\")\n      = sum((BewNiv3,BewNiv2,BewNiv1), p_salcaRes3(curCrops,sys,\"\",biodType,BewNiv1,BewNiv2,BewNiv3,\"cur\",\"ScoreBewNiv3\"));\n\n* --- Count BewNiv3\n    p_salcaRes3(curCrops,sys,\"\",biodType,\"\",\"\",\"\",\"cur\",\"CountGAV\") = sum((BewNiv1,BewNiv2),p_salcaRes3(curCrops,sys,\"\",biodType,BewNiv1,BewNiv2,\"\",\"cur\",\"CountGAV\"));\n\n* --- Calculation of overall biodiversity score (each BewNiv3 has the same weight)\n  p_salcaRes3(curCrops,sys,\"\",biodType,\"\",\"\",\"\",\"cur\",\"impactGAV\") $p_salcaRes3(curCrops,sys,\"\",biodType,\"\",\"\",\"\",\"cur\",\"CountGAV\")\n     = p_salcaRes3(curCrops,sys,\"\",biodType,\"\",\"\",\"\",\"cur\",\"SumScore\")/p_salcaRes3(curCrops,sys,\"\",biodType,\"\",\"\",\"\",\"cur\",\"CountGAV\");\n</code></pre> <p>For each ISG, this habitat score is compared to the maximum achievable and minimum achievable score to standardise the score and get a potential ranging from 0 to 1:</p> <pre><code>* --- Storing maximum and minimum possible SALCA Scores for each species in the result parameter\n    p_salcaRes(curCrops,sys,\"\",biodType,\"\",\"max\",\"impactGAV\")  $ (sum(id,p_salcaInv(id,curCrops,sys)) $ p_ha(curCrops,sys))=  p_biodTypeMinMaxGrades(biodType,\"max\");\n    p_salcaRes(curCrops,sys,\"\",biodType,\"\",\"min\",\"impactGAV\")  $ (sum(id,p_salcaInv(id,curCrops,sys)) $ p_ha(curCrops,sys))=  p_biodTypeMinMaxGrades(biodType,\"min\");\n</code></pre> <pre><code>* --- Standardization of the results:\n p_salcaSummary3(curCrops,biodType,\"pot\",impactCat) $ ((p_salcaSummary3(curCrops,biodType,\"cur\",impactCat) AND (p_salcaSummary3(curCrops,biodType,\"max\",impactCat)-p_salcaSummary3(curCrops,biodType,\"min\",impactCat) gt 0 ) AND (p_salcaSummary3(curCrops,biodType,\"cur\",impactCat)-p_salcaSummary3(curCrops,biodType,\"min\",impactCat) gt 0 )))\n      =  (p_salcaSummary3(curCrops,biodType,\"cur\",impactCat)-p_salcaSummary3(curCrops,biodType,\"min\",impactCat))\n        / (p_salcaSummary3(curCrops,biodType,\"max\",impactCat)-p_salcaSummary3(curCrops,biodType,\"min\",impactCat)) ;\n</code></pre> <p>Habitat scores can be aggregated temporally, spatially, and over the indicator species groups. Temporal aggregation is possible as soon as multiple crops per year are entered, e.g. crops and catch crops. Depending on the ISG\u2019s ability to recover from harming management activities, either the mean or the minimum of both habitat scores is used. Spatial aggregation refers to the aggregation of the scores of plots into scores of the whole farm. For the spatial aggregation, the ISG\u2019s biodiversity scores of the plots are weighted by their plot size. For the aggregation from individual habitat scores for each ISG into one general habitat score for all ISGs the so-called G weighting coefficients provided by SALCA-BD are used. These coefficients take the subspecies richness of a species and the trophic relations between the different ISGs into account. This type of aggregation can also be done on the level of a plot, using the temporally aggregated scores, and on the level of a farm, using the spatially aggregated scores.</p> <p>All described calculations and aggregations were reconstructed in FarmDyn. Besides, another aggregation was built such that each management level I enters the habitat score with the same weight instead of each management level III. Thus, a distinction between SALCA Original and SALCA Modified can be chosen in FarmDyn\u2019s graphical user interface. The complete code of the SALCA-BD method with additional explanations can be found in the directory gams/exploiter/biodiv_ind_salca.gms. Links to other code locations where preparations for the SALCA-BD method are made can be taken from this file. It should be noted that confidential SALCA data cannot be found on FarmDyn's head revision but can only be viewed on request.</p>"},{"location":"FarmDynDocumentation/ModelDescription/BiodiversityAssessment/smart_score/","title":"SMART Score","text":"<p>SMART is an acronym for Sustainability Monitoring and Assessment Routine, an comprehensive sustainability assessment method developed by the Swiss FibL-Institute. The full SMART method is described by Schader et al. (2016). The implementation in FarmDyn relies on the biodiversity part only and covers 22 out of the 72 SMART biodiversity indicators. This discrepancy is due to limitations imposed by the FarmDyn model. The following table shows the 22 implemented SMART biodiversity indicators:  </p> <p>:   Table 1: SMART Indicators.      Source: Own illustration based on SCHADER et al. (2016).</p> <p>As can be seen in the table, the SMART method does not only estimate the overall impact of the agricultural production programme on biodiversity but distinguish the impact on (1) ecosystem diversity (ED), (2) genetic diversity (GD) and (3) species diversity (SD).</p> <p>The SMART biodiversity indicators take values between 0 (worst) and 1 (best). Their calculation is done in three steps: determination of the Relevance, the Driver and the Value. In the following, these 3 steps are explained in more detail using the example of indicator 236 which captures the number of crops in the crop rotation:</p>"},{"location":"FarmDynDocumentation/ModelDescription/BiodiversityAssessment/smart_score/#relevance-of-individual-smart-biodiversity-score","title":"Relevance of Individual SMART Biodiversity Score","text":"<p>The Relevance is a binary variable which becomes 0 if the indicator is not relevant for the farm and 1 if it is. With a Relevance of 0 an indicator does not get included in the calculation of the SMART-Score. Indicator 236 is relevant if the farm has any endowment of arable land which can be seen in the following lines of code:  </p> <pre><code>p_Ind(\"236\",\"rel\")    $ sum( (landType,soil,t_n(tCur,nCur)), v_croppedLand(landtype,soil,tCur,nCur)*p_probN(nCur)) = 1;\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/BiodiversityAssessment/smart_score/#driver-of-individual-smart-biodiversity-score","title":"Driver of Individual SMART Biodiversity Score","text":"<p>The Driver captures a parameter, variable or similar of FarmDyn which describes the indicator. Thus, the Driver serves as the link to the model. In the case of indicator 236, the Driver captures the number of crops grown by the farm (excluding catch crops).</p> <pre><code>p_Ind(\"236\",\"driver\") $ p_Ind(\"236\",\"rel\")\n =  sum(arabCrops(CurCrops) $ sum((c_p_t_i(curCrops,plot,till,intens),t_n(tCur,nCur)) $ ((not  catchCrops(curCrops)) $ v_cropHa(curCrops,plot,till,intens,tCur,nCur)),1),1);\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/BiodiversityAssessment/smart_score/#value-of-individual-smart-biodiversity-score","title":"Value of Individual SMART Biodiversity Score","text":"<p>The Value converts the Driver of an indicator to fit the scale between 0 and 1. Step-wise linear functions are frequently used for this purpose. The Driver of indicator 236 can take any value depending on the number of different crops a farm grows. For example, if a farm cultivates 3 crops, the Driver is 3. Using a step-wise linear function, the 3 is then converted into the Value 0.25.</p> <pre><code>p_ind(\"236\",\"val\") =   0                                   $(p_ind(\"236\",\"driver\") &lt; 3)\n                      + 0.25 $((p_ind(\"236\",\"driver\") &gt;= 3) $(p_ind(\"236\",\"driver\") &lt; 4))\n                      + 0.50 $((p_ind(\"236\",\"driver\") &gt;= 4) $(p_ind(\"236\",\"driver\") &lt; 5))\n                      + 0.75 $((p_ind(\"236\",\"driver\") &gt;= 5) $(p_ind(\"236\",\"driver\") &lt; 6))\n                      + 1.00 $( p_ind(\"236\",\"driver\") &gt;= 6);\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/BiodiversityAssessment/smart_score/#aggregation-to-final-smart-scores","title":"Aggregation to Final SMART Scores","text":"<p>The individual SMART biodiversity scores are summarized into 3 indicators for each of the 3 biodiversity dimensions.</p> <p>p_EcoDiv estimates the effect of the agricultural production progamme on ED:</p> <pre><code>p_ind(smartInds,\"ecoSys\") $ ecoDivInd(smartInds) = 1;\n\n p_EcoDiv $ sum(ecoDivInd(smartInds), p_ind(smartInds,\"rel\"))\n = sum(ecoDivInd(smartInds) $ p_ind(smartInds,\"rel\"),p_ind(smartInds,\"val\"))\n   /sum(ecoDivInd(smartInds), p_ind(smartInds,\"rel\"));\n</code></pre> <p>p_GenDiv estimates the effect of the agricultural production progamme on GD:</p> <pre><code>p_ind(smartInds,\"genetic\") $ genDivInd(smartInds) = 1;\n\n p_GenDiv $ sum(genDivInd(smartInds), p_ind(smartInds,\"rel\"))\n = sum(genDivInd(smartInds) $ p_ind(smartInds,\"rel\"),p_ind(smartInds,\"val\"))\n   /sum(genDivInd(smartInds), p_ind(smartInds,\"rel\"));\n</code></pre> <p>And p_SpecDiv estimates the effect of the agricultural production programme on SD:  </p> <pre><code>p_ind(smartInds,\"species\") $ specDivInd(smartInds) = 1;\n\n  p_SpecDiv $ sum(specDivInd(smartInds), p_ind(smartInds,\"rel\"))\n  = sum(specDivInd(smartInds) $ p_ind(smartInds,\"rel\"),p_ind(smartInds,\"val\"))\n    /sum(specDivInd(smartInds), p_ind(smartInds,\"rel\"));\n</code></pre> <p>Finally, the mean of p_EcoDiv,p_GenDiv and p_SpecDiv summarises the overall impact on biodiversity - p_BioDiv:</p> <pre><code>p_BioDiv =[ + p_EcoDiv\n             + p_GenDiv\n             + p_SpecDiv ]/ 3;\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/Biogas/biogas/","title":"Biogas Module","text":"<p>Information:</p> <p>The biogas module has not been tested under the current FarmDyn version, therefore run time errors are very likely to occur when it is used.</p> <p>The biogas module defines the economic and technological relations between components of a biogas plant with a monthly resolution, as well as links to the farm. Thereby, it includes the statutory payment structure and their respective restrictions according to the German Renewable Energy Acts (EEGs) from 2004 up to 2014. The biogas module differentiates between three different sizes of biogas plants and accounts for three different life spans of investments connected to the biogas plant. Data for the technological and economic parameters used in the model are derived from KTBL (2013) and FNR (2013). The equations within the template model related to the biogas module are presented in the following section.</p>"},{"location":"FarmDynDocumentation/ModelDescription/Biogas/biogas/#biogas-economic-part","title":"Biogas Economic Part","text":"<p>The economic part describes on the one hand the revenues stemming from the heat and electricity production of the biogas plant, and on the other hand investment and operation costs. The guaranteed feed-in tariff paid to the electricity producer per kWh, p_priceElec, and underlying the revenues, is constructed as a sliding scale price and is exemplary shown in the next equation.</p> <pre><code>p_priceElec(bhkw,eeg,tCur(t))$(eegRated(eeg)) = (p_priceElecBase(\"150kW\",eeg) * (150/p_powRate(bhkw,eeg))\n                                                          + p_priceElecBase(bhkw,eeg) * ((p_powRate(bhkw,eeg) - 150)/p_powRate(bhkw,eeg)))\n                                                         ;\n</code></pre> <pre><code>p_priceElecE2004(\"150kW\",\"E2004\")= 0.08;\n</code></pre> <p>p_priceElecBase, used to calculate the guaranteed feed-in tariff differentiated by size, includes the base rate and additional bonuses 1 according to the legislative texts of the EEGs. For the EEG 2012 it only contains the base rate. In addition, the guaranteed feed-in tariff is subject to a degressive relative factor, p_priceElecDeg which differs between EEGs and describes price reductions over time. The p_priceElecBase is then used to calculate the electricity based revenue of the biogas operator by multiplying it with the produced electricity, v_prodElec. In order to assure a correct representation of the EEG 2012 payment, the biogas module differentiates the electricity output by input source v_prodElecCrop and v_prodElecManure and multiplies it with its respective bonus tariffs p_priceElecInputclass which are added to the base rate.</p> <pre><code>bioGasObje_(tCur(t),nCur) $ t_n(t,nCur) ..\n       v_salRevBioGas(t,nCur)\n\n        =e=\n\n*            --- Revenue stemming from electricity production with degression depending on EEG (excluding direct marketing)\n                 sum( (curBhkw(bhkw),curEeg(eeg),m) $ (not(eegDM(eeg))),\n                                    v_prodElec(bhkw,eeg,t,nCur,m) *  p_priceElec(bhkw,eeg,t)   )\n\n*            --- Revenue stemming from electricity production for EEG E2012 differentiated by input class\n               + sum( (curBhkw(bhkw),curEeg(eeg),m) $ (eegDif(eeg)) ,\n                                        v_prodElecCrop(bhkw,eeg,t,nCur,m)   * p_priceElecInputclass(bhkw,eeg,\"inputCl1\")\n                                      + v_prodElecManure(bhkw,eeg,t,nCur,m) * p_priceElecInputclass(bhkw,eeg,\"inputCl2\") )\n\n*            --- Revenue stemming from heat\n               + sum( curEeg(eeg),  v_sellHeat(eeg,t,nCur) * p_priceHeat(t) )\n\n*            --- Revenue specification for EEG with direct marketing and flexible biogas production\n               + sum( (curBhkw(bhkw),curEeg(eeg),m)$(eegDM(eeg)),\n                                   + (v_prodElec(bhkw,eeg,t,nCur,m) * p_shareEPEX(bhkw) )\n                                       * (p_dmMP(bhkw,eeg,t,m) + p_dmsellPriceHigh(m) )\n                                   + (v_prodElec(bhkw,eeg,t,nCur,m) * (1 - p_shareEPEX(bhkw) ) )\n                                       * (p_dmMP(bhkw,eeg,t,m) + p_dmsellPriceLow(m) )\n                                   + (v_prodElec(bhkw,eeg,t,nCur,m) * p_flexPrem(bhkw,eeg) ) )\n\n*            --- Revenue stemming from scenario premium\n               + sum( (curBhkw(bhkw), curEeg(eeg),m)$(eegScen(eeg)),\n                                      v_prodElec(bhkw,eeg,t,nCur,m) * p_scenPremium(eeg)$(eegScen(eeg)))\n;\n</code></pre> <p>In addition to the traditional guaranteed feed-in tariff, the biogas module comprises the payment structure for the so-called direct marketing option which was implemented in the EEG 2012. The calculation of the revenue with a direct marketing option is defined as the product of the produced electricity, v_prodElec, the sum of the market premium, p_dmMP, and the price at the electricity spot exchange EPEX Spot, p_dmsellPriceHigh/Low. The latter depends on the amount of electricity sold during high and low stock market prices. Additionally, it is accounted for a flexibility premium, p_flexPrem.</p> <p>Furthermore, the revenue stemming from heat is accounted for and is included as the product of sold heat, v_sellHeat, times the price of heat, p_priceHeat, which is set to two cents per kWh. The amount of head sold is set exogenously and depends on the biogas plant type.</p> <p>The detailed steps of the construction of prices can be seen in the following file: gams\\coeffgen\\prices_eeg.gms.</p>"},{"location":"FarmDynDocumentation/ModelDescription/Biogas/biogas/#biogas-inventory","title":"Biogas Inventory","text":"<p>The biogas plant inventory differentiates biogas plants by size (set bhkw), which determines the engine capacity, the investment costs and the labour use. Three size classes are currently depicted.</p> <pre><code>set bhkw \"different bhkw sizes\" /\n                                 150KW       \"150kW engine\"\n                                 250kW       \"250kW engine\"\n                                 500KW       \"500kW engine\"\n                                /;\n</code></pre> <p>Moreover, in order to use a biogas plant, different components need to be present which differ by lifetime (investment horizon ih). For example, to keep using the original biogas plant, the decision maker has to re-invest every seventh year in a new engine but only every twentieth year in a new fermenter.</p> <pre><code>iH              \"investment horizon\"       /\n                                                  iH7      \"reinvestment after seven years\",\n                                                  iH10     \"reinvestment after ten years\",\n                                                  iH20     \"reinvestment after twenty years\"\n</code></pre> <p>The biogas plant and their respective parts can either be bought, v_buyBiogasPlant(Parts), or an already existing biogas plant can be used, p_iniBioGas. Both define the size of the inventory of the biogas plant, v_invBioGas(Parts). The model currently limits the number of biogas plants present on farm to unity.</p> <pre><code>invBioGasTot_(tCur(t),nCur) $ t_n(t,nCur) ..\n\n       sum( (curBhkw(bhkw),curEeg(eeg)), v_invBioGas(bhkw,eeg,t,nCur)) =L=  1;\n</code></pre> <pre><code>invBioGas_(curBhkw(bhkw),curEeg(eeg),ih,tFull(t),nCur) $ (ih20(ih) $ t_n(t,nCur))   ..\n\n       v_invBioGas(bhkw,eeg,t,nCur)\n\n           =L=\n                 sum( (tCur(t1),nCur1)  $ (t_n(t1,nCur1) $ isNodeBefore(nCur,nCur1)\n                       $  (p_year(t1) + p_ih(ih)+1 ge p_year(t)+1 )\n                      and (p_year(t1)+1 le p_year(t)+1 ) ),\n\n                                       v_buyBioGasPlant(bhkw,eeg,ih,t1,nCur1) )\n\n                 + sum( tOld $ ( (p_year(tOld) + p_ih(ih) ge p_year(t) ) and (p_year(tOld) le p_year(t) ) ),\n\n                                       p_iniBioGas(bhkw,eeg,ih,tOld) );\n</code></pre> <pre><code>invBioGasTotParts_(curBhkw(bhkw),ih,tCur(t),nCur) $ (t_n(t,nCur) $ (not ih20(ih)))..\n\n           v_invBioGasParts(bhkw,ih,t,nCur) =G= sum(curEeg(eeg), v_invBioGas(bhkw,eeg,t,nCur));\n</code></pre> <p>Furthermore, the inventory v_invBioGas stores the information under which EEG the plant was original erected, either by externally setting the EEG for an existing biogas plant or the initial EEG is endogenously determined by the year of investment. In addition, the module provides the plant operator the option to switch from the EEG under which its plant was original erected to newer EEGs endogenously, such that the electricity and heat price of the newer legislation determines the revenues of the plant. For this purpose, the variable v_switchBioGas transfers the current EEG from v_invBioGas to the variable v_useBioGasPlant. Hence, the v_invBioGas is used to represent the inventory while v_useBioGasPlant is used to determine the actual EEG under which a plant is used, i.e. payment structures and feedstock restrictions.</p> <pre><code>switchBioGas_(curBhkw(bhkw),curEeg(eeg1),tCur(t),nCur) $ t_n(t,nCur) ..\n\n       v_invBioGas(bhkw,eeg1,t,nCur)\n\n          =G= sum(newEeg_oldEeg(eeg,eeg1) $ curEeg(eeg), v_switchBioGas(bhkw,eeg1,eeg,t,nCur));\n</code></pre> <pre><code>useBioGas_(curBhkw(bhkw),curEeg(eeg),tCur(t),nCur) $ t_n(t,nCur) ..\n\n       v_useBioGasPlant(bhkw,eeg,t,nCur)\n\n          =L= sum(newEeg_oldEeg(eeg,eeg1) $ curEeg(eeg1), v_switchBioGas(bhkw,eeg1,eeg,t,nCur));\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/Biogas/biogas/#production-technology","title":"Production Technology","text":"<p>The production technology describes not only the production process, but also defines the limitations set by technological components such as the engine capacity, fermenter volume and fermentation process. As heat is only a by-product of the electricity production and therefore the production equations do not differ from those for electricity, the heat production is not explicitly described.</p> <p>The size of the engine restricts with p_fixElecMonth the maximal output of electricity in each month. According to the available size classes, the maximal outputs are 150kW, 250kW and 500kW, respectively, at 8.000 operating hours per year. This number of hours stems from the assumption that the biogas plant is not operating for 9 % of the available time due to maintenance, etc. .</p> <pre><code>fixkWel_(curBhkw(bhkw),curEeg(eeg),tCur(t),nCur,m) $ (t_n(t,nCur) and (v_prodElec.up(bhkw,eeg,t,nCur,m) ne 0)) ..\n\n       v_prodElec(bhkw,eeg,t,nCur,m)\n\n          =l= v_useBioGasPlant(bhkw,eeg,t,nCur) * p_fixElecMonth(bhkw,m) * p_scenRed(eeg);\n</code></pre> <p>The production process of electricity, v_prodElec, is constructed in a two-stage procedure. First, biogas 2, v_methCrop/Manure, is produced in the fermenter as the product of crops and manure, v_usedCrop/Manure, and the amount of methane content per ton fresh matter of the respective input. Second, the produced methane is combusted in the engine in which the electricity-output, v_prodElecCrop/Manure, is calculated by the energy content of methane, p_ch4Con, and the conversion efficiency of the respective engine, p_bhkwEffic.</p> <pre><code>methCrop_(curBhkw(bhkw),curEeg(eeg),tCur(t),nCur,m) $ t_n(t,nCur) ..\n\n       v_methCrop(bhkw,eeg,t,nCur,m)\n\n          =e= sum(crM(biogasFeedM), v_usedCropBiogas(bhkw,eeg,crM,t,nCur,m) * p_crop(crM) );\n</code></pre> <pre><code>methManure_(curBhkw(bhkw),curEeg(eeg),tCur(t),nCur,m) $ t_n(t,nCur) ..\n\n       v_methManure(bhkw,eeg,t,nCur,m)\n\n          =e= sum(curmaM,     v_usedManBiogas(bhkw,eeg,curmaM,t,nCur,m) * p_manure(curmaM) );\n</code></pre> <pre><code>kWel_(curBhkw(bhkw),curEeg(eeg),tCur(t),nCur,m) $ (t_n(t,nCur) and (v_prodElec.up(bhkw,eeg,t,nCur,m) ne 0)) ..\n\n       v_prodElec(bhkw,eeg,t,nCur,m)\n\n          =l= v_useBioGasPlant(bhkw,eeg,t,nCur) * p_fixElecMonth(bhkw,m) * p_scenRed(eeg);\n</code></pre> <pre><code>kWelCrop_(curBhkw(bhkw),curEeg(eeg),tCur(t),nCur,m) $ t_n(t,nCur) ..\n\n       v_prodElecCrop(bhkw,eeg,t,nCur,m)\n\n         =e= v_methCrop(bhkw,eeg,t,nCur,m) * p_ch4Con * p_bhkwEffic(bhkw,\"el\") * p_transLosses;\n</code></pre> <pre><code>kWelManure_(curBhkw(bhkw),curEeg(eeg),tCur(t),nCur,m) $ t_n(t,nCur) ..\n\n       v_prodElecManure(bhkw,eeg,t,nCur,m)\n\n         =e= v_methManure(bhkw,eeg,t,nCur,m) * p_ch4Con * p_bhkwEffic(bhkw,\"el\") * p_transLosses;\n</code></pre> <p>The bonus structure of the EEG 2012 requires a differentiation between the two input classes: crop and manure. Thus, the production process is separated in methane produced from the Crop input class and the Manure input class.</p> <p>The production technology imposes a second bound by connecting a specific fermenter volume, p_volFermMonthly, to each engine size. The fermenter volume is exogenously given under the assumption of a 90-day hydraulic retention time and an input mix of 70 % maize silage and 30 % manure. Hence, the input quantity derived from crops, v_usedCropBiogas, and manure, v_usedManBiogas, is bound by the fermenter size, v_totVolFermMonthly.</p> <pre><code>fixKW_(curBhkw(bhkw),curEeg(eeg),tCur(t),nCur,m) $ t_n(t,nCur) ..\n\n       v_totVolFermMonthly(bhkw,eeg,t,nCur,m)\n\n         =l= v_useBioGasPlant(bhkw,eeg,t,nCur) *  p_volFermMonthly(bhkw) * p_scenred(eeg);\n</code></pre> <pre><code>totVolFerm_(curBhkw(bhkw),curEeg(eeg),tCur(t),nCur,m) $ t_n(t,nCur) ..\n\n       v_totVolFermMonthly(bhkw,eeg,t,nCur,m)  =g=\n\n                                          sum(crM(biogasFeedM), v_usedCropBiogas(bhkw,eeg,crM,t,nCur,m))\n\n                                        + sum(curmaM, v_usedManBiogas(bhkw,eeg,curmaM,t,nCur,m) );\n</code></pre> <p>The inputs for the fermentation process can be either externally purchased, v_purchCrop/Manure, or produced on farm, v_feedBiogas/v_volManBiogas. Additionally, the module accounts for silage losses for purchased crops, as crops from own production already includes silage losses in the production pattern of the farm.</p> <pre><code>usedCropBioGas_(curBhkw(bhkw),curEeg(eeg),crM(biogasFeedM),tCur(t),nCur,m) $ t_n(t,nCur) ..\n\n       v_usedCropBiogas(bhkw,eeg,crM,t,nCur,m)\n\n          =e= (    v_purchCrop(bhkw,eeg,crM,t,nCur,m)  $ selPurchInputs(crM) * p_silageLoss)\n                 + v_feedBioGas(bhkw,eeg,crM,t,nCur,m) $ SUM(sameas(curProds,crM),1);\n</code></pre> <pre><code>    manureTot_(curBhkw(bhkw), curEeg(eeg),curmaM,tCur(t),nCur,m) $ t_n(t,nCur) ..\n\n       v_usedManBiogas(bhkw,eeg,curmaM,t,nCur,m)\n          =e=\n               v_purchManure(bhkw,eeg,curmaM,t,nCur,m) $ selPurchInputs(curmaM)\n$ifi %herd%==true            + sum(curmanchain $ (not sameas (curmanChain,\"LiquidBiogas\")) , v_volManBiogas(curmanchain,bhkw,eeg,curmaM,t,nCur,m))\n    ;\n</code></pre> <pre><code>volManBioGas_(curmanchain, tCur(t),nCur) $ (t_n(t,nCur) $ (not sameas (curmanchain,\"LiquidBiogas\"))) ..\n\n      v_manQuant(curManChain,t,nCur) $ (not sameas (curmanchain,\"LiquidBiogas\"))\n\n          =G= sum( (manchain_mam(curmanchain,curmam),curbhkw(bhkw),curEeg(eeg),m) $(not sameas (curmanchain,\"liquidBiogas\")), v_volManBiogas(curmanchain,bhkw,eeg,curmaM,t,nCur,m)) ;\n</code></pre> <p>The third bound imposed by the production technology is the so called digestion load (Faulraumbelastung). The digestion load, p_digLoad, restricts the amount of organic dry matter within the fermenter to ensure a healthy bacteria culture. The recommended digestion load of the three different fermenter sizes ranges from 2.5 to 3 \\(\\frac{\\text{kg oDM}}{m^3 \\cdot d}\\) 3 and is converted into a monthly limit.</p> <pre><code>fixdigLoad_(curBhkw(bhkw),tCur(t),nCur,m) $ t_n(t,nCur) ..\n\n      v_digLoad(bhkw,t,nCur,m)   =l= sum(curEeg(eeg),  v_useBioGasPlant(bhkw,eeg,t,nCur) * p_digLoad(bhkw,m))  ;\n</code></pre> <pre><code>digLoad_(curBhkw(bhkw),tCur(t),nCur,m) $ t_n(t,nCur) ..\n\n      v_digLoad(bhkw,t,nCur,m)   =l= sum(curEeg(eeg),  v_useBioGasPlant(bhkw,eeg,t,nCur) * p_digLoad(bhkw,m))  ;\n</code></pre> <p>The data used for the fermenter technology can be seen in the following file: gams\\coeffgen\\fermenter_tech.gms</p>"},{"location":"FarmDynDocumentation/ModelDescription/Biogas/biogas/#restrictions-related-to-the-renewable-energy-act","title":"Restrictions Related to the Renewable Energy Act","text":"<p>Within the legislative text of the different Renewable Energy Acts different restrictions were imposed in order to receive certain bonuses or to receive any payment at all. In the biogas module most bonuses for the EEG 2004 and EEG 2009 are inherently included such as the KWK-Bonus and NawaRo-Bonus, i.e. the plant is already defined such that these additional subsidies on top of the basic feed-in tariff can be claimed. Additionally, the biogas operator has the option to receive the Manure-Bonus, if he ensures that 30 % of his input quantity is manure based, as can be seen in the following code.</p> <pre><code>manureRes_(curBhkw(bhkw),eegMan(eeg),tCur(t),nCur,m) $ (t_n(t,nCur) $ curEeg(eeg)) ..\n\n       sum(curmaM,  v_usedManBiogas(bhkw,eeg,curmaM,t,nCur,m)) =g= v_totVolFermMonthly(bhkw,eeg,t,nCur,m)*0.3 ;\n</code></pre> <p>Furthermore, the EEG 2012 imposes two requirements which have to be met by the plant operator to receive any statutory payment at all. First, the operator must ensure that not more than 60 % of the used fermenter volume, v_totVolFermMonthly, is used for maize. Second, under the assumption that the operator uses 25 % of the heat emitted by the combustion engine for the fermenter itself, he has to sell at least 35 % of the generated heat externally;</p> <pre><code>maizeRes_(curBhkw(bhkw),eegDif(eeg),biogasFeedM,tCur(t),nCur,m) $ (curEeg(eeg) $ t_n(t,nCur)) ..\n\n        v_usedCropBiogas(bhkw,eeg,biogasFeedM,t,nCur,m) $sum(sameas(biogasFeedM,maizSilage),1)\n             =l=  0.6 * v_totVolFermMonthly(bhkw,eeg,t,nCur,m);\n</code></pre> <pre><code>heatRes_(curBhkw(bhkw),eegDif(eeg),tCur(t),nCur,m) $ (curEeg(eeg) $ t_n(t,nCur)) ..\n\n       v_sellHeat(eeg,t,nCur) =g= p_minHeatSold * v_prodHeat(eeg,t,nCur);\n</code></pre> <p>Changes made in EEG 2014 and the amendment of 2016 has not been included in the model yet.</p>"},{"location":"FarmDynDocumentation/ModelDescription/Biogas/biogas/#biogas-disgestates","title":"Biogas Disgestates","text":"<p>Biogas production involves the production of digestates. Four feed sources can be differentiated depending on their origin: use of manure produced on farm, manure imported to the farm, crops grown on farm and crops imported to the farm. Manure produced on farm is treated as not fermented manure, as though it is not entering the biogas plant.</p> <p>For digestates from imported manure and from crops, volume of digestates in cubic meter is calculated in the biogas_module.gms by multiplying amount of used feed stock, v_usedCropBiogas and v_purchManure, and a fugal factor. The latter represents the decrease of volume during the fermentation process.</p> <pre><code>biogasVolCropDigestate_(crm(biogasfeedM),tCur(t),nCur,m) $ t_n(t,nCur) ..\n\n        v_volDigCrop(crM,t,nCur,m) =E= sum( (curBhkw(bhkw), curEeg(eeg)),\n                                        v_usedCropBiogas(bhkw,eeg,crM,t,nCur,m)* p_fugCrop(crM));\n</code></pre> <pre><code>biogasVolManDigestate_(tCur(t),nCur,m) $ t_n(t,nCur) ..\n\n        v_volDigMan(t,nCur,m) =E= sum( (curBhkw(bhkw), curEeg(eeg), curmaM) ,\n                                        v_purchManure(bhkw,eeg,curmaM,t,nCur,m) $ selPurchInputs(curmaM)   * p_fugMan);\n</code></pre> <p>The amount of nutrients produced in the biogas plant and entering the manure storage is computed by multiplying the amount of feed stock and the corresponding nutrient content. It is assumed, that N and P is not lost during fermentation. Furthermore, nutrients from crop inputs are calculated as an annual average since no short term changes are common.</p> <pre><code>nutCropBiogasY_(curmanchain,nut2,tCur(t),nCur) $ (t_n(t,nCur) $ sameas(curmanchain,\"LiquidBiogas\")) ..\n\n        v_nutCropBiogasY(curmanchain,nut2,t,nCur) =E=\n             sum( ( crM(biogasFeedM),m,curBhkw(bhkw), curEeg(eeg) ),\n                                         v_usedCropBiogas(bhkw,eeg,crM,t,nCur,m)\n                                               * p_nutDigCrop(curmanchain,nut2,crM));\n</code></pre> <pre><code>nutCropBiogasM_(curmanchain,nut2,tCur(t),nCur,m) $(t_n(t,nCur) $ sameas(curmanchain,\"LiquidBiogas\")) ..\n\n        v_nutCropBiogasM(\"LiquidBiogas\",nut2,t,nCur,m) =E=  v_nutCropBiogasY(\"LiquidBiogas\", nut2,t,nCur) / card(m);\n</code></pre> <pre><code>nut2ManurePurch_(curmanchain,nut2,curmaM,tCur(t),nCur,m) $( t_n(t,nCur) $ sameas(curmanchain,\"LiquidBiogas\"))  ..\n\n         v_nut2ManurePurch(curmanchain,nut2,curmaM,t,nCur,m)\n            =E=    sum ( (curBhkw(bhkw), curEeg(eeg)),\n                        v_purchManure(bhkw,eeg,curmaM,t,nCur,m) * p_nut2manPurch(\"LiquidBiogas\",nut2,curmaM)  )    ;\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/Biogas/biogas/#references","title":"References","text":"<p>KTBL (2013): Faustzahlen Biogas. 3. Ausgabe, Kuratorium f\u00fcr Technik und Bauwesen in der Landwirtschaft e.V., Darmstadt</p> <ol> <li> <p>For the EEG 2004: NawaRo-Bonus, KWK-Bonus; For the EEG 2009: Nawaro-Bonus, KWK-Bonus or NawaRo-Bonus, KWK-Bonus and Manure-Bonus\u00a0\u21a9</p> </li> <li> <p>Biogas is a mixture of methane (CH4), carbon dioxide (CO2), water vapor (H2O) and other minor gases. The gas component containing the energy content of biogas is methane. Thus, the code with respect to production refers to the methane production rather than the production of biogas.\u00a0\u21a9</p> </li> <li> <p>oDM = organic dry matter; m3 = cubic meter; d = day\u00a0\u21a9</p> </li> </ol>"},{"location":"FarmDynDocumentation/ModelDescription/BuildingsAndMachines/machinery/","title":"Farm Machinery and Field Operations","text":"<p>Abstract Field operations and associated machinery needs are depicted in high detail. For each crop required field operations and related machinery applications are included. The machinery requirements are based on the level of mechanisation selected in the GUI. Based on the mechanisation level and information on plot sizes and farm to field distances resource requirements and variable costs are calculated.</p> <p>Different types of machines and field operations are implemented in FarmDyn, using data from two different databases: The default-database is manually implemented in FarmDyn. The data reports required field operations and related machine applications for grassland management, fertilization operations as well as specific crops for policy implementations (e.g. flowerstrips). In addition, it includes data for ~20 default crops. Based on the crop-data selection in the Graphical User Interface (GUI), data on field operations and machinery needs can further be imported from a large scale KTBL-database. The KTBL-database includes more than 400 machines and 1500 field operations for ~145 crops. It distinguishes between conventional and organic farming systems, reflecting system specific field operations. Both databases consider different types of tillage and are differentiated by mechanisation levels, which reflect substitution possibilities between labor and capital. Labour and resource requirements related to machine applications are further conditional on plot sizes and farm to field distances.</p>"},{"location":"FarmDynDocumentation/ModelDescription/BuildingsAndMachines/machinery/#machinery-and-machine-attributes","title":"Machinery and Machine Attributes","text":"<p>The models default farm machinery includes various different machines (see tech.gms). An extraction is shown in the following:</p> <pre><code>set set_machType /tractor\n                      tractorSmall\n                      plough                  \"Pflug\"\n                      chiselPlough            \"Schwergrubber\"\n                      sowMachine              \"Saemaschine\"\n                      directSowMachine        \"Direktsaemaschine\"\n                      seedBedCombi            \"Saatbeetkombination\"\n                      circHarrow              \"Scheibenegge\"\n                      springTineHarrow        \"Federzinkenegge\"\n                      fingerHarrow            \"Hackstriegel\"\n                      combine                 \"Maehdrescher\"\n                      cuttingUnitCere         \"Getreideschneidwerk\"\n                      cuttingAddRape          \"Zusatzausruestung Rapsernte\"\n                      cuttingUnitMaiz         \"Maispflueckeinrichtung fuer Maehdrescher\"\n                      rotaryHarrow            \"Kreiselegge\"\n                      mulcher                 \"Mulcher\"\n</code></pre> <p>Based on the crop-data selection in the GUI, further machines are imported from the KTBL-database. Here, each machine is assigned a machine type and an unique ID:</p> <pre><code>sets\n     set_machType                                         \"name of a machine\"\n     set_machTypeID                                       \"unique ID of a machine\"\n     set_machTypeID_machType(set_machTypeID,set_machType) \"crossset between machType and machTypeID\"\n     machineType                                          \"Type of a machine, e.g. tractor, plough\"\n     set_machType_machineType(set_machType,machineType)       \"assigns a machineType to each machine\"\n   ;\n</code></pre> <p>Each machinery type is characterised by the set of attributes p_machAttr, for example:</p> <pre><code>table p_machAttr(machType,machAttr)\n\n*\n* --- Data from KTBL 2014/2015, if not otherwise stated\n*\n*\n* --- KTBL. 82, 4 Schare, 140 cm\n*\n                      price        hour       ha       m3     t     varCost_ha  varCost_t  varCost_h  diesel_h  fixCost_h  fixCost_t years varCost_m3\n Plough               13000                 2000                        12.0\n*\n* --- KTBL. 84, Schwergrubber, angebaut, 2.5m\n*\n ChiselPlough          5600                 2600                         5.0\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/BuildingsAndMachines/machinery/#field-operations-machinery-needs-and-related-costs","title":"Field Operations: Machinery Needs and Related Costs","text":""},{"location":"FarmDynDocumentation/ModelDescription/BuildingsAndMachines/machinery/#default-database","title":"Default Database","text":"<p>The models default-database includes different field operations (see cropop_de.gms). An extraction is shown in the following:</p> <pre><code>set operation \"Field operators as defined by KTBL\"\n\n             /\n                      soilSample              \"Bodenprobe\"\n                      manDist                 \"Guelleausbringung\"\n                      basFert                 \"P und K Duengung, typischerweise Herbst\"\n                      plow                    \"Pfluegen\"\n                      chiselPlow              \"Tiefengrubber\"\n                      seedBedCombi            \"Saatbettkombination\"\n                      herb                    \"Herbizidmassnahme\"\n                      sowMachine              \"Saemaschine\"\n                      directSowMachine        \"Direktsaatmaschine\"\n                      circHarrowSow           \"Kreiselegge u. Drillmaschine Kombination\"\n                      springTineHarrow        \"Federzinkenegge\"\n                      weedValuation           \"Unkrautbonitur\"\n                      weederLight             \"Striegeln\"\n                      weederIntens            \"Hacken\"\n                      plantvaluation          \"Bestandsbonitur\n</code></pre> <p>For each field operation required machinery is stated, for example:</p> <pre><code>set op_machType(operation,machType) \"Links the operations to machinery\";\n* was ist mit dem Trecker? muss nicht f\ufffdr jeden Arbeitsgang auch noch der Traktor zu den\n* Arbeitsg\ufffdngen verlinkt werden? oder ist das woanders schon mit Treckeranspr\ufffdchen pro ha und Frucht abgegolten?\n* Die Kosten f\ufffdr Trecker in den Arbeitsg\ufffdngen sind ja durch KTBL Angaben zu var und fixCost schon abgegolten, aber die\n* Treckerstunden evtl. nicht die die Nutzungsdauer beeinflussen (BL 10.02.2014)\n\n op_machType(\"plow\",\"plough\")                                  = yes;\n op_machType(\"chiselplow\",\"chiselPlough\")                      = yes;\n op_machType(\"stubble_shallow\",\"chiselPlough\")                 = yes;\n op_machType(\"stubble_deep\",\"chiselPlough\")                    = yes;\n op_machType(\"seedBedCombi\",\"seedBedCombi\")                    = yes;\n op_machType(\"springTineHarrow\",\"springTineHarrow\")            = yes;\n op_machType(\"circHarrowSow\",\"circHarrow\")                     = yes;\n op_machType(\"circHarrowSow\",\"sowMachine\n</code></pre> <p>The performance of field operations involves labour and diesel requirements as well as variable and fixed machinery costs. An extraction is shown in the following:</p> <pre><code>table op_attr(operation,machVar,rounded_plotsize,opAttr) \"resource requirements of operations\"\n\n                                                labTime         diesel      fixCost      varCost   nPers  amount\n    soilSample                .67kw.\"2\"          0.2              0.5          1.05         0.30\n    manDist                   .67kw.\"2\"          1.7              6.7         20.20        24.65\n    basFert                   .67kw.\"2\"          0.25             0.9          2.04         2.11\n*\n*   --- page 153, KTBL 2010/2011\n*\n    plow                      .67kw.\"2\"          1.89            23.0         20.39        40.76\n    chiselPlow                .67kw.\"2\"          1.09            15.1          9.02        22.92\n    SeedBedCombi              .67kw.\"2\"          0.58             6.0          7.98        12.05\n    sowMachine                .67kw.\"2\"          0.84             4.9          9.44        10.62\n    directSowMachine          .67kw.\"2\"          0.71             6.5         23.01        22.59\n    circHarrowSow             .67kw.\"2\"          1.29            12.9         16.96        27.16\n    springTineHarrow          .67kw.\"2\"          0.75             7.3          6.56        13.60\n    weedValuation             .67kw.\"2\"          0.16             0.3          1.59         0.35\n    herb                      .67kw.\"2\"          0.28             1.0          4.37         3.25\n    weederLight               .67kw.\"2\"          0.42             2.6          3.93         6.22\n    weederIntens              .67kw.\"2\"          0.73             3.8         13.10         9.70\n    plantValuation            .67kw.\"2\"          0.13             0.1          0.91         0.18\n</code></pre> <p>Per hectare resource requirements and costs of field operations are conditional on plot sizes and mechanisation level. The default-database considers these effect for four different plot sizes and three mechanisation levels. Farm-plot distances are not considered. Thereby, idle serves as placeholder for all crops in the default-database:</p> <pre><code>table p_plotSizeEffect(crops,machVar,opAttr,rounded_plotSize)\n\n                            \"1\"    \"2\"   \"5\"  \"20\"\n\n     idle. 67kw .labTime    12.4   10.5   9.3   8.0\n     idle. 67kw .diesel       90     83    78    73\n     idle. 67kw .varCost     205    188   176   168\n     idle. 67kw .fixCost     282    258   241   231\n\n     idle.102kw .labTime    11.1    9.1   7.6   6.8\n     idle.102kw .diesel       95     86    78    74\n     idle.102kw .varCost     209    188   172   164\n     idle.102kw .fixCost     315    284   262   249\n\n     idle.200kw .labTime    11.9    8.6   6.3   4.9\n     idle.200kw .diesel      118     99    84    75\n     idle.200kw .varCost     240    201   173   157\n     idle.200kw .fixCost     396    334   292   267\n  ;\n</code></pre> <p>FarmDyn distinguishes in total seven different mechanisation levels. As the default-database does not report input requirements for all mechanisation levels, data of similar mechanisation is used:</p> <pre><code>p_plotSizeEffect(\"idle\",\"45kW\",opAttr,rounded_plotSize)=p_plotSizeEffect(\"idle\",\"67kW\",opAttr,rounded_plotSize);\n</code></pre> <pre><code>p_plotSizeEffect(\"idle\",\"83kW\",opAttr,rounded_plotSize)=p_plotSizeEffect(\"idle\",\"67kW\",opAttr,rounded_plotSize);\n</code></pre> <pre><code>p_plotSizeEffect(\"idle\",\"120kW\",opAttr,rounded_plotSize)=p_plotSizeEffect(\"idle\",\"102kW\",opAttr,rounded_plotSize);\n</code></pre> <pre><code>p_plotSizeEffect(\"idle\",\"230kW\",opAttr,rounded_plotSize)=p_plotSizeEffect(\"idle\",\"200kW\",opAttr,rounded_plotSize);\n</code></pre> <pre><code>p_plotSizeEffect(\"idle\",machVar,\"nPers\",rounded_plotSize) = 1;\n</code></pre> <pre><code>p_plotSizeEffect(\"idle\",machVar,\"amount\",rounded_plotSize) = 1;\n</code></pre> <p>Subsequentely, the effect of plot size is assigned to all crops included in the default-dataset, for example:</p> <pre><code>p_plotSizeEffect(crops,\"67kW\",opAttr,rounded_plotSize) $ ((not p_plotSizeEffect(crops,\"67kW\",opAttr,rounded_plotSize)) $ (not sum(till, c_p_t_i_GDX(crops,\"plot\",till,\"normal\"))))\n     =  (sum( crops1,  p_plotSizeEffect(crops1,\"67kW\",opAttr,rounded_plotSize))\n       / sum( crops1 $ p_plotSizeEffect(crops1,\"67kW\",opAttr,rounded_plotSize),1)) $sum(crops1, p_plotSizeEffect(crops1,\"67kW\",opAttr,rounded_plotSize));\n</code></pre> <p>The plot size effect is used to scale resource requirements of machines and field operations that are not included in KTBL-database:</p> <pre><code>p_machAttr(machType,\"diesel_h\") $ (sum(op_machType(operation,machType),1) or sameas(machType,\"Tractor\"))\n   =  p_machAttr(machType,\"diesel_h\")\n        *  sum( (curCrops(crops),actMachVar,act_rounded_plotsize)\n           $$iftheni.data \"%database%\" == \"KTBL_database\"\n              $ (not sum(till, c_p_t_i_GDX(crops,\"plot\",till,\"normal\")))\n           $$endif.data\n            ,p_plotSizeEffect(crops,actMachVar,\"diesel\",act_rounded_plotsize)\n                                               /p_plotSizeEffect(crops,\"67Kw\",\"diesel\",\"2\"))\n         / sum( (curCrops(crops),actMachVar,act_rounded_plotsize) $ p_plotSizeEffect(crops,actMachVar,\"diesel\",act_rounded_plotsize),1);\n\n\n  op_attr(operation,actmachVar,rounded_plotsize,\"diesel\") $ op_attr(operation,actMachVar,rounded_plotsize,\"diesel\")\n   = op_attr(operation,actmachVar,rounded_plotsize,\"diesel\")\n        *  sum( (curCrops(crops),act_rounded_plotsize)\n           $$iftheni.data \"%database%\" == \"KTBL_database\"\n              $ (not sum(till, c_p_t_i_GDX(crops,\"plot\",till,\"normal\")))\n           $$endif.data\n           ,p_plotSizeEffect(crops,actMachVar,\"diesel\",act_rounded_plotsize)\n                                               /p_plotSizeEffect(crops,\"67Kw\",\"diesel\",\"2\"))\n         / sum( (curCrops(crops),act_rounded_plotsize) $ p_plotSizeEffect(crops,actMachVar,\"diesel\",act_rounded_plotsize),1);\n\n\n  set techEval_c_t_i\n</code></pre> <p>The field operations are linked to monthly cropping activities, considering the frequency of a field operation in the production (below an example for potatoes):</p> <pre><code>table p_crop_op_per_tilla(crops,operation,labPeriod,till)\n                                                              plough     minTill   noTill          org  silo  bales  hay      graz\n\n potatoes     .    soilSample          .  AUG1                   0.2         0.2                   0.2\n potatoes     .    basFert             .  AUG1                   1.0         1.0                   1.0\n potatoes     .    solidManDist        .  AUG2                                                     1.0\n potatoes     .    plow                .  AUG2                                                     1.0\n potatoes     .    chiselPlow          .  AUG2                   1.0         1.0\n potatoes     .    sowmachine          .  AUG2                   1.0         1.0\n potatoes     .    mulcher             .  NOV1                   1.0         1.0                   1.0\n potatoes     .    plow                .  NOV1                   1.0                               1.0\n potatoes     .    chiselPlow          .  NOV1                               1.0\n potatoes     .    NminTesting         .  FEB1                   1.0         1.0\n potatoes     .    NFert320            .  MAR1                   1.0         1.0                   1.0\n potatoes     .    chitting            .  MAR1                                                     1.0\n potatoes     .    seedBedCombi        .  MAR2                   1.0\n potatoes     .    rotaryHarrow        .  MAR2                               1.0                   1.0\n potatoes     .    seedPotatoTransp    .  APR1                   1.0         1.0                   1.0\n potatoes     .    potatoLaying        .  APR1                   1.0         1.0                   1.0\n potatoes     .    rakingHoeing        .  APR2                                                     1.0\n potatoes     .    earthingUp          .  APR2                   1.0         1.0\n potatoes     .    weedValuation       .  MAY1                   1.0         1.0                   1.0\n potatoes     .    earthingUP          .  MAY1\n potatoes     .    plantvaluation      .  JUN1                   1.0                               1.0\n potatoes     .    herb                .  JUN1                                                     1.0\n potatoes     .    plantValuation      .  JUN2                   2.0         2.0                   1.0\n potatoes     .    herb                .  JUN2                   2.0         2.0                   2.0\n potatoes     .    plantValuation      .  JUL1                   2.0         2.0\n potatoes     .    herb                .  JUL1                   2.0         2.0                   1.0\n potatoes     .    plantValuation      .  JUL2                   1.0         1.0\n potatoes     .    herb                .  JUL2                   1.0         1.0                   1.0\n potatoes     .    plantValuation      .  AUG1                   1.0         1.0\n potatoes     .    herb                .  AUG1                   1.0         1.0                   1.0\n potatoes     .    plantValuation      .  AUG2                   1.0         1.0\n potatoes     .    herb                .  AUG2                   1.0         1.0\n potatoes     .    knockOffHaulm       .  AUG2                                                     1.0\n potatoes     .    killingHaulm        .  AUG2                   1.0         1.0\n potatoes     .    potatoHarvest       .  SEP1                   0.5         0.5                   0.5\n potatoes     .    potatoTransport     .  SEP1                   0.5         0.5                   0.5\n potatoes     .    potatoStoring       .  SEP1                   0.5         0.5                   0.5\n potatoes     .    potatoHarvest       .  SEP2                   0.5         0.5                   0.5\n potatoes     .    potatoTransport     .  SEP2                   0.5         0.5                   0.5\n potatoes     .    potatoStoring       .  SEP2                   0.5         0.5                   0.5\n potatoes     .    lime_fert           .  OCT1                 0.333\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/BuildingsAndMachines/machinery/#ktbl-database","title":"KTBL Database","text":"<p>Further field operations can be included from the KTBL-database. Here, each operation is assigned to an operation type and receives an unique ID. Field operations are linked to cropping activities, p_crops_operationID, on a monthly resolution, considering the frequency of a field operation in the production. Data distinguish between different types of tillage and conventional and organic farming systems, reflecting system specific field operations. Further, different soil types and amounts (e.g. transport volumes, application quantities) are considered, reflecting their impact on resource requirements of field operations.Field operations are reported for seven mechanisation levels between 45 and 230 kW.  Details on resource requirements and costs of each operation are expressed as function of plot sizes and farm to field distances, building on a polynomial regression function. For each operation and resource/cost item, regression coefficients p_RegCoeff are specified.  For field operations that are independent of plot sizes and distances (e.g. loading and cleaning operations), constant values p_noRegCoeff are reported. Based on information on soil type, mechanisation, plot sizes and distances entered in the GUI, resource requirement are calculated. Plot sizes of up to 40 ha and farm to field distances up to 30 km are considered.</p> <pre><code>p_opIDInputReq(curCrops,till,items,operationID) = sum((crops_operationID(curCrops,sys,till,operationID,labperiod,amount,actMachVar),amountUnit,\n              Soil) $ sum(soil_plot(soil,plot),c_p_t_i(curCrops,plot,till,\"normal\"))\n              ,\n             (\n              p_noRegCoeff(operationID,amount,soil,items)\n                 $ (not p_regCoeff(operationID,amount,\"m\",\"time\",\"intercept\"))\n      +\n              Max(p_RegCoeff(operationID,amount,Soil,items,\"minvalue\"),\n              Min(p_regCoeff(operationID,Amount,soil,items,\"maxvalue\"),\n          ((\n               p_regCoeff(operationID,amount,Soil,items,\"intercept\")\n            +  p_regCoeff(operationID,amount,Soil,items,\"size_linear\")   * p_actPlotSize\n            +  p_regCoeff(operationID,amount,Soil,items,\"size_sqr\")      * sqr(p_actPlotSize)\n            +  p_regCoeff(operationID,amount,Soil,items,\"sqroot_size\")   * sqrt(p_actPlotSize)\n            +  p_regCoeff(operationID,amount,Soil,items,\"size_distance\") * p_actPlotSize * p_actPlotDist\n            +  p_regCoeff(operationID,amount,Soil,items,\"dist_linear\")   * p_actPlotDist\n            +  p_regCoeff(operationID,amount,Soil,items,\"dist_sqr\")      * sqr(p_actPlotDist)\n             ) $ p_regCoeff(operationID,amount,\"m\",\"time\",\"intercept\"))\n             )))\n             * p_crops_operationID(curCrops,sys,till,operationID,labperiod,amount,amountUnit,actMachVar)\n           );\n</code></pre> <p>These information on required field operation and related resource requirements and cost in crop production determine:</p> <ol> <li> <p>The number of necessary field working days and monthly labour     need per ha (excluding the time used for fertilisation, which is     determined endogenously)</p> </li> <li> <p>The machinery need for the different crops</p> </li> <li> <p>Related variable costs</p> </li> </ol>"},{"location":"FarmDynDocumentation/ModelDescription/BuildingsAndMachines/machinery/#labour-requirements-in-crop-production","title":"Labour Requirements in Crop Production","text":"<p>The labour needs per month are determined by summing up over all farm operations, considering the labour period, the effect of plot size and mechanisation (coeffgen\\labour.gms):</p> <pre><code>p_cropLab(c_t_i(curCrops,till,intens),m)\n\n     =\n*\n* --- crops included in KTBL database\n*\n$iftheni.data \"%database%\" == \"KTBL_database\"\n   sum((operation),\n          p_opInputReq(curCrops,till,\"labTime\",operation)\n          $ (sum((amount,labperiod),  p_crop_op_per_tillaKTBL(curCrops,operation,labperiod,till,amount)\n          $ labPeriod_to_month(labPeriod,m))))\n$endif.data\n*\n* --- crops not included in KTBL database\n*\n+     sum( (curOperation(operation),actmachVar,act_rounded_plotsize,labPeriod_to_month(labPeriod,m))\n                  $((not contractOperation(operation)\n                  $$iftheni.data \"%database%\" == \"KTBL_database\"\n                  $(not (sum(operationID $operationID_operation(operationID,operation),1)))\n                  $$endif.data\n                  )),\n              p_crop_op_per_till(curCrops,operation,labPeriod,till,intens)\n                     * op_attr(operation,\"67kW\",\"2\",\"labTime\")\n*\n*                    -- effect of plot size and mechanisation on labour time\n*\n                         * p_plotSizeEffect(curCrops,actMachVar,\"labTime\",act_rounded_plotsize)\n                          /p_plotSizeEffect(curCrops,\"67kW\",\"labTime\",\"2\")\n               )\n               $$iftheni.data \"%database%\" == \"KTBL_database\"\n               $ (not c_p_t_i_GDX(curCrops,\"plot\",till,\"normal\"))\n               $$endif.data\n ;\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/BuildingsAndMachines/machinery/#depreciation-of-machines-included-in-ktbl-database","title":"Depreciation of Machines Included in KTBL-Database","text":"<p>Deprecation cost of machine applications in the KTBL-database are calculated at the level of a field operations. Field operations, however, often require more than one machine such that deprecation costs refer to multiple machines. To draw conclusions about the value of the machine park and necessary new acquisitions, data on cost of depreciation are required on level of a single machine. Therefore, total depreciation costs are allocated to individual machines, considering the respective depreciation type and usage. An extraction is shown in the following (at the example of machines depreciated by area use).</p> <p>First, total depreciation costs are assigned to p_physDepr.</p> <pre><code>p_physDepr(curCrops,till,operation,\"\",\"\",\"cost\")\n       = p_opInputReq(curCrops,till,\"deprec\",operation);\n</code></pre> <p>For each machine of a field operation that is depreciated by area use, depreciation costs per hectare are calculated:</p> <pre><code>p_physDepr(curCrops,till,op_machType(operation,machType),\"\",\"areaCost\")\n      $ (p_machAttr(machType,\"ha\") $ p_physDepr(curCrops,till,operation,\"\",\"\",\"cost\"))\n      = p_machAttr(machType, \"price\")/p_machAttr(machType,\"ha\") + eps;\n</code></pre> <p>The total depreciation costs allocated to area use are summarised for each operation:   </p> <pre><code>p_physDepr(curCrops,till,operation,\"\",\"\",\"areaCost\")\n       $ p_opInputReq(curCrops,till,\"deprec\",operation)\n     = sum(op_machType(operation,machType)\n           $ p_machAttr(machType,\"ha\"),\n                p_physDepr(curCrops,till,operation,machType,\"\",\"areaCost\"));\n</code></pre> <p>In case the total depreciation allocated to area use costs exceed the total deprecation costs of a field operation, the depreciation costs of each machine are scaled</p> <pre><code>p_physDepr(curCrops,till,op_machType(operation,machType),\"\",\"areaCost\")\n      $ (p_machAttr(machType,\"ha\") $ p_physDepr(curCrops,till,operation,\"\",\"\",\"cost\"))\n      = p_machAttr(machType, \"price\")/p_machAttr(machType,\"ha\") + eps;\n</code></pre> <p>The depreciation costs allocated to area use are subtracted from total deprecation costs of a field operation:</p> <pre><code>p_physDepr(curCrops,till,op_machType(operation,machType),\"\",\"areaCost\")\n      $ (p_machAttr(machType,\"ha\") $ p_physDepr(curCrops,till,operation,\"\",\"\",\"cost\"))\n      = p_machAttr(machType, \"price\")/p_machAttr(machType,\"ha\") + eps;\n</code></pre> <p>The same procedure is repeated to allocate the remaining depreciation costs to machines depreciated over time and mass use and to machines which are not depreciated over specific use but have fixed annual depreciation costs.</p> <p>For each field operation, the total depreciation costs allocated to machine applications are summed to check for any remaining depreciation costs not allocated to any machine.</p> <pre><code>p_physDepr(curCrops,till,operation,\"\",\"\",\"totCost\")\n       = sum((op_machType(operation,machType),depCost),\n               p_physDepr(curCrops,till,operation,machType,\"\",depCost));\n</code></pre> <p>Any remaining depreciation costs are allocated to all machines of a field operation.</p> <pre><code>p_physDepr(curCrops,till,operation,machType,\"\",depCost));\n</code></pre> <p>Some field operations are not associated with any machine applications (e.g. drying and storing; covering of silo). Here, remaining depreciation costs can not be distributed to machines but reflect depreciation of associated buildings and facilities (storage facility, silo):</p> <pre><code>p_physDepr(curCrops,till,operation,\"Buildings and Facilities\",\"\",\"totcost\")\n       $ (abs(p_physDepr(curCrops,till,operation,\"\",\"\",\"error\")) gt 1)\n      = abs(p_physDepr(curCrops,till,operation,\"\",\"\",\"error\"));\n</code></pre> <p>Total depreciation costs of a machine per hectare crop production are calculated over all field operations that are required to produce a crop under a specific production system and all deprecation types, as some machines are depreciated by more than one deprecation type (e.g. area and mass use):</p> <p>Commentembedmd:# (N:/em/work1/Pahmeyer/FarmDyn/FarmDynDoku/FarmDyn_Docu/gams/coeffgen/tech.gms GAMS /Report.*?machType/ /;/)</p> <pre><code>*\n*    --- sum depreciation of a machType over all field operations of a crop (sys,till)\n*\n     p_physDepr(curCrops,till,\"mach_crop\",machType,\"\",depCost)\n       =sum(op_machType(operation,machType) $ p_physDepr(curCrops,till,operation,\"\",\"\",\"cost\"),\n          p_physDepr(curCrops,till,operation,machType,\"\",depCost));\n*\n*   --- total depreciation of a machine over all deprec types for a crop,sys,till\n*\n    p_physDepr(curCrops,till,\"mach_crop\",machType,\"\",\"totCost\")\n       = sum(depCost,p_physDepr(curCrops,till,\"mach_crop\",machType,\"\",depCost));\n\n</code></pre> <p>The depreciation costs per hectare are assigned to the machinery requirements by each crop per hectare</p> <pre><code>p_machNeed(crops,till,\"normal\",machType,\"invCost\")\n       = p_physDepr(crops,till,\"mach_crop\",machType,\"\",\"totCost\");\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/BuildingsAndMachines/machinery/#investments-in-new-machinery","title":"Investments in new machinery","text":"<p>Depending on the depreciation type, investments in new machines are either depicted continuously, where v_buyMachFlex is the fractional investment according to actual machine needs (e.g. operation hours, mass flows) or using a binary variable v_buyMach for machines where lifetime is declared in years.</p> <pre><code>machBuyFlex_(curMachines(machType),machLifeUnit,tFull(t),nCur)\n        $ (   (v_machInv.up(machType,machLifeUnit,t,nCur) ne 0)\n            $ v_buyMachFlex.up(machType,t,nCur)  $ p_lifeTimeM(machType,machLifeUnit)\n            $ (not sameas(machLifeUnit,\"years\")) $ p_priceMach(machType,t) $ t_n(t,nCur))  ..\n\n        v_buyMachFlex(machType,t,nCur) * p_lifeTimeM(machType,MachLifeUnit)\n            =L= v_machNeed(machType,machLifeUnit,t,nCur) $ tCur(t)\n\n              + [sum( (t_n(t1,nCur1)) $ ( tCur(t1) $ isNodeBefore(nCur,nCur1)),\n                                 v_machNeed(machType,machLifeUnit,t1,nCur1))/card(tCur)\n                 ]  $ ( (not tCur(t)) and p_prolongCalc);\n</code></pre> <pre><code>buyMachLifeTimeT_(curMachines(machType),t_n(tCur(t),nCur)) $ ((v_buyMach.up(machType,tCur,nCur) ne 0) $ p_lifeTimeM(machType,\"years\")\n                                                                   $ ( mod(t.pos,p_lifeTimeM(machType,\"years\")) eq 1) $ (Card(tCur) gt 1) ) ..\n\n         sum( (tFull(t1),nCur1) $ ( t_n(t1,nCur1)\n                                    $ (p_year(t1) + p_lifeTimeM(machType,\"years\") lt p_year(t))\n                                    $ (v_buyMach.up(machType,t1,nCur1) ne 0)),\n\n                  v_buyMach(machType,t1,nCur1)) =L= 1;\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/BuildingsAndMachines/machinery/#endogenous-machine-inventory","title":"Endogenous Machine Inventory","text":"<p>The inventory equation for machinery is shown in machInv_, where v_machInv is the available inventory by type and machType, in operation hours. v_machNeed is the machinery need of the farm in operating hours and v_buyMach are investments in new machines.</p> <pre><code>machInv_(curMachines(machType),machLifeUnit,tFull(t),nCur)\n         $ (     (v_machInv.up(machType,machLifeUnit,t,nCur) ne 0)\n               $ p_lifeTimeM(machType,machLifeUnit)  $ p_priceMach(machType,t)\n               $ (not sameas(machLifeUnit,\"years\"))  $ t_n(t,nCur) )  ..\n*\n*      --- inventory end of current year (in operating hours, hectares etc.)\n*\n       v_machInv(machType,machLifeUnit,t,nCur)\n\n             =e=\n*\n*        --- inventory end of last year (in operating hours)\n*\n          sum(t_n(t-1,nCur1) $ anc(nCur,nCur1), v_machInv(machType,machLifeUnit,t-1,nCur1))\n*\n*        --- new machines, converted in operation time\n*\n        + (v_buyMach(machType,t,nCur)+v_buyMachFlex(machType,t,nCur)) * p_lifeTimeM(machType,MachLifeUnit)\n*\n*        --- minus operating hours in current year if in normal planning period\n*\n        - v_machNeed(machType,machLifeUnit,t,nCur)  $ tCur(t)\n*\n*        --- minus operating hours of weighted average over normal planning period\n*            if beyond the normal planning period\n*\n        - [sum( (t_n(t1,nCur1)) $ ( tCur(t1) $ isNodeBefore(nCur,nCur1)),\n                          v_machNeed(machType,machLifeUnit,t1,nCur1))/card(tCur)\n           ]\n                       $ ( (not tCur(t)) and p_prolongCalc)\n       ;\n</code></pre> <p>The last expression is used when the farm program for the simulated period is used to estimate the machinery needs for all years until the stables are fully depreciated.</p> <p>Machinery need is also linked to activities in livestock production (e.g. small tractors):</p> <pre><code>machNeedHerds_(curMachines(machType),machLifeUnit,t_n(tCur(t),nCur))\n        $ sum(actHerds(sumHerds,breeds,feedRegime,t,m),\n               p_machNeed(sumHerds,\"plough\",\"normal\",machType,machLifeUnit)) ..\n\n       v_machNeedHerds(machType,machLifeUnit,t,nCur)\n\n         =e=\n*\n*      --- herd sizes times their request for specific machine type\n*\n          sum(actHerds(sumHerds,breeds,feedRegime,t,m) $ p_prodLength(sumHerds,breeds),\n             v_herdSize(sumHerds,breeds,feedRegime,t,nCur,m)\n              * p_machNeed(sumHerds,\"plough\",\"normal\",machType,machLifeUnit)\n                          * 1/min(12,p_prodLength(sumHerds,breeds)));\n</code></pre> <p>The total machinery need in each year is defined as sum from activities or processes requiring machinery:</p> <pre><code>machines_(curMachines(machType),machLifeUnit,t_n(tCur(t),nCur))     $ p_lifeTimeM(machType,machLifeUnit) ..\n*\n*    --- less than total machinery need\n*\n       v_machNeed(machType,machLifeUnit,t,nCur) =G=\n*\n*      --- crops times their request for specific machine type\n*          crops and machines not included in the KTBL Regression in ha/ha: hour/ha ...\n*          machines inclueded in KTBL Regression: EUR depreciation costs\n       sum( c_p_t_i(curCrops(crops),plot,till,intens),\n           v_cropHa(crops,plot,till,intens,t,nCur)\n            * p_machNeed(crops,till,intens,machType,machLifeUnit))\n*\n*             --- yield depression effects (increase plant protection cost)\n*\n\n     $$iftheni.pmp \"%pmp%\"==\"true\"\n      + sum( (curCrops(Crops),sys) $ [sum(c_p_t_i(crops,plot,till,intens) $ (sys_till(sys,till)\n                                       $ p_critShare(crops,sys,\"dep1\") $ (p_machNeed(crops,till,intens,machType,machLifeUnit) gt 0)),1)\n                                                                                  $ sameas(machType,\"sprayer\")],\n            sqr(v_sumCrop(crops,sys,t,nCur))\n                                         /[  (  p_nArabLand  $ (not grassCrops(crops))\n                                              + (p_nGrasLand+p_nPastLand) $ grassCrops(crops))\n                                                * smax((sys_till(sys,till),cropShareLevl),p_critShare(crops,sys,cropShareLevl))\n                                                ]\n     $$else.pmp\n\n        + sum( (curCrops(Crops),sys,cropShareLevl) $ (sum(c_p_t_i(crops,plot,till,intens) $ sys_till(sys,till),\n                                                        p_machNeed(crops,till,intens,machType,machLifeUnit))\n                                                                                   $ sameas(machType,\"sprayer\")),\n              v_cropShareEffect(crops,sys,cropShareLevl,t,nCur)*p_cropShareLevl(crops,sys,cropShareLevl)\n\n     $$endif.pmp\n\n             *    sum(c_p_t_i(crops,plot,till,intens) $ sys_till(sys,till),p_machNeed(crops,till,intens,machType,machLifeUnit))\n                / sum(c_p_t_i(crops,plot,till,intens) $ (sys_till(sys,till) $ p_machNeed(crops,till,intens,machType,machLifeUnit)),1))\n\n*        ---- machine need for the application of N (syntfert)\n\n     + sum( (c_p_t_i(curCrops(crops),plot,till,intens),curInputs(syntFertilizer),m),\n               v_syntDist(crops,plot,till,intens,syntFertilizer,t,nCur,m) * (1 + m.pos*1.E-3)\n                  * p_machNeed(syntFertilizer,till,\"normal\",machType,machLifeUnit))\n\n*        ---- machine need for the application of manure\n\n     $$iftheni.man \"%manure%\"==\"true\"\n\n        + sum((c_p_t_i(curCrops(crops),plot,till,intens),manApplicType_manType(ManApplicType,curManType),m)\n              $ (v_manDist.up(crops,plot,till,intens,manApplicType,curManType,t,nCur,m) ne 0),\n                v_manDist(crops,plot,till,intens,ManApplicType,curManType,t,nCur,m)\n                  * p_machNeed(ManApplicType,\"plough\",\"normal\",machType,machLifeUnit))\n\n     $$endif.man\n\n     $$iftheni.herd \"%herd%\"==\"true\"\n\n      + v_machNeedHerds(machType,machLifeUnit,t,nCur)\n           $ sum(actHerds(sumHerds,breeds,feedRegime,t,m),\n                 p_machNeed(sumHerds,\"plough\",\"normal\",machType,machLifeUnit))\n     $$endif.herd\n    ;\n</code></pre> <p>A small set of machinery, such as the front loader, dung grab, shear grab or fodder mixing vehicles are depreciated by time and not by use:</p> <pre><code>machInvT_(curMachines(machType),tFull(t),nCur)\n        $ (      (v_machInv.up(machType,\"years\",t,nCur) ne 0)\n                $ p_lifeTimeM(machType,\"years\")\n                $ p_priceMach(machType,t) $ t_n(t,nCur)  )  ..\n*\n*      --- inventory end of current year (in operating hours)\n*\n       v_machInv(machType,\"years\",t,nCur)\n\n     +  sum( t_n(t1,nCur1) $ (  (p_year(t1) gt smax( tOld $ p_iniMachT(machType,told),\n                                                     p_year(tOld) + p_lifeTimeM(machType,\"years\")))\n                             $  (p_year(t1)+p_prolongLen gt p_year(t))\n                             $ tCur(t1)  $ isNodeBefore(nCur,nCur1)),\n                 v_machInv(machType,\"years\",t1,nCur1)/p_proLongLen)\n                                                $ ( (not tCur(t)) and p_prolongCalc)\n\n          =L=\n*\n*         --- old machines according to investment dates\n*             (will drop out of equation if too old)\n*\n          sum( tOld $ (   ((p_year(tOld) + p_lifeTimeM(machType,\"years\")) gt p_year(t))\n                              $ ( p_year(told)                            le p_year(t))),\n                                 p_iniMachT(machType,tOld))\n\n*\n*         --- plus (old) investments - de-investments\n*\n       +  sum( t_n(t1,nCur1) $ (  ((p_year(t1)  + p_lifeTimeM(machType,\"years\") ) gt p_year(t))\n                                $ ( p_year(t1)                                    le p_year(t))\n                                $ isNodeBefore(nCur,nCur1)),\n                                                v_buyMach(machType,t1,nCur1));\n</code></pre> <p>The aforementioned set of machinery, depreciated by time and not usage, are linked to the existence of stables, i.e. stables cannot be used if machinery is not present:</p> <pre><code>machInvStable_(curMachines(machType),stables,tCur(t),nCur)\n       $ ( (v_machInv.up(machType,\"years\",t,nCur) ne 0)\n           $  (   sum( (t_n(t1,nCur1),hor) $ ( (isNodeBefore(nCur,nCur1) or sameas(nCur,nCur1)) and (p_year(t1) le p_year(t))),\n                      (v_buyStables.up(stables,hor,t1,nCur1) ne 0))\n              or  sum( tOld, p_iniStables(stables,\"long\",tOld)))\n           $ sum(stables_to_mach(stables,machType),1)\n           $ (p_lifeTimeM(machType,\"years\"))  $ p_priceMach(machType,t)  $ t_n(t,nCur))  ..\n\n       sum(stables_to_mach(stables,machType), v_stableUsed(stables,t,nCur)\n           -sum(m $ (p_stableLab(stables,m) gt eps),v_stableNotUsed(stables,t,nCur,m))/card(m))\n          =L= v_machInv(machType,\"years\",t,nCur);\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/BuildingsAndMachines/machinery_old/","title":"Farm Machinery","text":"<p>The model includes farm machineries in quite some detail:</p> <p>[^Comment][embedmd]:# (N:/em/work1/Pahmeyer/FarmDyn/FarmDynDoku/FarmDyn_Docu/gams/model/templ_decl.gms GAMS /(?i)set.*?machtype/ /;/)</p> <pre><code>set machType   /  tractor\n                      tractorSmall\n                      plough                  \"Pflug\"\n                      chiselPlough            \"Schwergrubber\"\n                      sowMachine              \"Saemaschine\"\n                      directSowMachine        \"DirektSaemaschine\"\n                      seedBedCombi            \"Saatbeetkombination\"\n                      circHarrow              \"Scheibenegge\"\n                      springTineHarrow        \"Federzinkenegge\"\n                      fingerHarrow            \"Hackstriegel\"\n                      combine                 \"Maehdrescher\"\n                      cuttingUnitCere         \"Getreideschneidwerk\"\n                      cuttingAddRape          \"Zusatzausruestung Rapsernte\"\n                      cuttingUnitMaiz         \"Maispflueckeinrichtung fuer Maehdrescher\"\n                      rotaryHarrow            \"Kreiselegge\"\n                      mulcher                 \"Mulcher\"\n                      potatoPlanter           \"Kartoffellegegeraet\"\n                      potatoLifter            \"Kartoffelroder\"\n                      hoe                     \"Hackmachine, 5-reihig\"\n                      ridger                  \"Haeufler\"\n                      haulmCutter             \"Krautschlaeger\"\n                      forkLiftTruck           \"Gabelstapler\"\n                      threeWayTippingTrailer  \"Dreiseitenkippanhaenger\"\n                      Sprayer                 \"Feldspritze\"\n                      singleSeeder            \"Einzelkornsaehgeraet (Rueben/Mais)\"\n                      beetHarvester           \"Ruebenroder\"\n                      fertSpreaderSmall       \"Duengerstreuer, 0.8cbm\"\n                      fertSpreaderLarge       \"Duengerstreuer, 4.0cbm\"\n                      chopper                 \"Feldhaecksler\"\n                      cornHeader              \"Maisgebiss fuer Haecksler\"\n                      mowerConditioner        \"Maehaufbereiter\"\n                      grasReseedingUnit       \"Gasnachsaemaschine\"\n                      rotaryTedder            \"Kreiselzettwender\"\n                      rake                    \"Schwader\"\n                      roller                  \"Walze\"\n                      silageTrailer           \"Silage trailer, service\"\n                      balePressWrap           \"Baler and bale wrapper, service\"\n                      balePressHay            \"Baler\"\n                      closeSilo\n\n                      manbarrel,draghose,injector,trailingshoe\n\n                      solidManDist      \"Miststreuer\"\n                      frontLoader       \"Frontlader\"\n                      siloBlockCutter   \"Siloblockschneider\"\n                      shearGrab         \"Schneidzange\"\n                      dungGrab          \"Dungzange\"\n                      fodderMixingVeh8  \"Futtermischwagen,  8m3, horizontale Schnecke, mit Befuellschild\"\n                      fodderMixingVeh10 \"Futtermischwagen, 10m3, vertikale Schnecke, mit Befuellschild\"\n                      fodderMixingVeh16 \"Futtermischwagen, 16m3, 2 vertikale Schnecken, mit Befuellschild\"\n                    /;\n</code></pre> <p>For further information see Appendix A1.</p> <p>Each machinery type is characterised by set of attributes p_machAttr (see coeffgen\\mach.gms), for example:</p> <p>[^Comment][embedmd]:# (N:/em/work1/Pahmeyer/FarmDyn/FarmDynDoku/FarmDyn_Docu/gams/coeffgen/mach.gms GAMS /table.*?p_mach/ /5.0/)</p> <pre><code>table p_machAttr(machType,machAttr) \"Machinery attribute for default size (67kw, 2 ha)\"\n\n*\n* --- Data from KTBL 2014/2015, if not otherwise stated\n*\n*\n* --- KTBL. 82, 4 Schare, 140 cm\n*\n                      price        hour       ha       m3     t     varCost_ha  varCost_t  varCost_h  diesel_h  fixCost_h  fixCost_t years varCost_m3\n Plough               13000                 2000                        12.0\n*\n* --- KTBL. 84, Schwergrubber, angebaut, 2.5m\n*\n ChiselPlough          5600                 2600                         5.0\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/BuildingsAndMachines/machinery_old/#farm-operations-machinery-needs-and-related-costs","title":"Farm Operations: Machinery Needs and Related Costs","text":"<p>Machinery is linked to specific farm operations (see tech.gms):</p> <p>[^Comment][embedmd]:# (N:/em/work1/Pahmeyer/FarmDyn/FarmDynDoku/FarmDyn_Docu/gams/coeffgen/tech.gms GAMS /set\\soperation/ /;/)</p> <pre><code>set operation \"Field operators as defined by KTBL\"\n\n             /\n                      soilSample              \"Bodenprobe\"\n                      manDist                 \"Guelleausbringung\"\n                      basFert                 \"P und K Duengung, typischerweise Herbst\"\n                      plow                    \"Pfluegen\"\n                      chiselPlow              \"Tiefengrubber\"\n                      seedBedCombi            \"Saatbettkombination\"\n                      herb                    \"Herbizidmassnahme\"\n                      sowMachine              \"Saemaschine\"\n                      directSowMachine        \"Direktsaatmaschine\"\n                      circHarrowSow           \"Kreiselegge u. Drillmaschine Kombination\"\n                      springTineHarrow        \"Federzinkenegge\"\n                      weedValuation           \"Unkrautbonitur\"\n                      weederLight             \"Striegeln\"\n                      weederIntens            \"Hacken\"\n                      plantvaluation          \"Bestandsbonitur\"\n                      NFert320\n                      NFert160\n                      combineCere             \"Maehdrusch, Getreide\"\n                      combineRape             \"Maehdrusch, Raps\"\n                      combineMaiz             \"Maehdrusch, Mais\"\n                      cornTransport           \"Getreidetransport\"\n                      store_n_dry_8\n                      store_n_dry_4\n                      store_n_dry_beans\n                      store_n_dry_rape\n                      store_n_dry_corn\n                      lime_fert               \"Kalkung\"\n                      stubble_shallow         \"Stoppelbearbeitung flach\"\n                      stubble_deep            \"Stoppelbearbeitung tief\"\n                      rotaryHarrow            \"Kreiselegge\"\n                      NminTesting             \"Nmin Probenahme\"\n                      mulcher                 \"Mulcher\"\n                      chitting                \"Vorkeimen\"\n                      solidManDist            \"Miststreuer\"\n                      seedPotatoTransp        \"Pflanzkartoffeltransport\"\n                      potatoLaying            \"Legen von Kartoffeln\"\n                      rakingHoeing            \"Hacken, striegeln\"\n                      earthingUp              \"haeufeln\"\n                      knockOffHaulm           \"Kartoffelkraut schlagen\"\n                      killingHaulm            \"Krautabtoeten\"\n                      potatoHarvest           \"Kartoffeln roden\"\n                      potatoTransport         \"Kartoffeln zum Lager transportieren\"\n                      potatoStoring           \"Kartoffeln lagern\"\n                      singleSeeder            \"Einzelkornlegegeraet fuer Zuckerrueben/Mais\"\n                      weederHand              \"von Hand hacken\"\n                      uprootBeets             \"Zuckerrueben roden\"\n                      DiAmmonium              \"Diammonphosphat streuen\"\n                      grinding                \"KornMahlen\"\n                      disposal                \"Erntegut festfahren\"\n                      coveringSilo            \"Silo reinigen und mit Folie verschliessen, Maiz\"\n                      chopper                 \"Haeckseln\"\n                      grasReSeeding           \"Grasnachsaeen\"\n                      roller                  \"Walzen\"\n                      mowing                  \"Maehen mit Maehaufbereiter\"\n                      raking                  \"Schwaden\"\n                      tedding                 \"Wenden mit Kreiselzettwender\"\n                      silageTrailer           \"Anwelkgut bergen mit Ladewagen\"\n                      closeSilo               \"Silo reinigen und mit Folie verschliessen\"\n* Hay/Bale specific tasks\n                      balePressWrap           \"Ballen pressen und wickeln, Silage (Anwelkgut)\"\n                      baleTransportSil        \"Ballentransport Silageballen\"\n                      baleTransportHay        \"Ballentransport Heuballen\"\n                      balePressHay            \"Bodenheu pressen\"\n               /;\n</code></pre> <p>For more details see Appendix A2.</p> <p>Labour needs, diesel, variable and fixed machinery costs are linked to these operations. An extraction is shown in the following:</p> <p>[^Comment][embedmd]:# (N:/em/work1/Pahmeyer/FarmDyn/FarmDynDoku/FarmDyn_Docu/gams/coeffgen/tech.gms GAMS /table\\sop_attr/ /;/)</p> <pre><code>table op_attr(operation,machVar,plotSize,opAttr)\n\n                                                labTime         diesel      fixCost      varCost   nPers  amount\n    soilSample                .67kw.2ha         0.2              0.5          1.05         0.30\n    manDist                   .67kw.2ha         1.7              6.7         20.20        24.65\n    basFert                   .67kw.2ha         0.25             0.9          2.04         2.11\n*\n*   --- page 153, KTBL 2010/2011\n*\n    plow                      .67kw.2ha         1.89            23.0         20.39        40.76\n    chiselPlow                .67kw.2ha         1.09            15.1          9.02        22.92\n    SeedBedCombi              .67kw.2ha         0.58             6.0          7.98        12.05\n    sowMachine                .67kw.2ha         0.84             4.9          9.44        10.62\n    directSowMachine          .67kw.2ha         0.71             6.5         23.01        22.59\n    circHarrowSow             .67kw.2ha         1.29            12.9         16.96        27.16\n    springTineHarrow          .67kw.2ha         0.75             7.3          6.56        13.60\n    weedValuation             .67kw.2ha         0.16             0.3          1.59         0.35\n    herb                      .67kw.2ha         0.28             1.0          4.37         3.25\n    weederLight               .67kw.2ha         0.42             2.6          3.93         6.22\n    weederIntens              .67kw.2ha         0.73             3.8         13.10         9.70\n    plantValuation            .67kw.2ha         0.13             0.1          0.91         0.18\n    NFert320                  .67kw.2ha         0.23             0.9          1.75         1.95\n    NFert160                  .67kw.2ha         0.19             0.8          1.16         1.58\n    lime_fert                 .67kw.2ha         0.48             3.6         12.54         6.51\n    combineCere               .67kw.2ha         1.20            20.8         66.43        31.94\n    combineRape               .67kw.2ha         1.25            22.83        86.11        40.73\n    combineMaiz               .67kw.2ha         1.32            23.99       115.57        54.54\n    cornTransport             .67kw.2ha         0.23             0.8          5.28         3.41\n    store_n_dry_8             .67kw.2ha         1.29                        100.81        29.28\n    store_n_dry_4             .67kw.2ha         0.64                         50.41        14.64\n    store_n_dry_beans         .67kw.2ha         0.47                         33.42        11.56\n    store_n_dry_rape          .67kw.2ha         0.64                         49.38        40.52\n    store_n_dry_corn          .67kw.2ha         1.50                        107.36       255.20\n*\n*   --- page 152 KBL 2010/2011\n*\n    stubble_shallow           .67kw.2ha         0.85             8.4          7.54        16.59\n    stubble_deep              .67kw.2ha         0.92             9.8          7.99        18.04\n*\n*--- KTBL 12/13 S. 420 [TK,24.07.13]\n*\n    rotaryHarrow              .67kw.2ha         1.17            9.40           8.27       22.06\n    NminTesting               .67kw.2ha         0.51            0.18           1.32        0.34\n    mulcher                   .67kw.2ha         1.40            8.39          14.51       20.59\n    chitting                  .67kw.2ha         2.36                         481.82       97.80\n    solidManDist              .67kw.2ha         1.61           10.88          32.73       30.99\n    seedPotatoTransp          .67kw.2ha         0.26            0.94           2.77        2.72\n    potatoLaying              .67kw.2ha         1.19           11.84          23.94       31.60\n    rakingHoeing              .67kw.2ha         0.73            4.12          11.65       10.80\n    earthingUp                .67kw.2ha         0.70            3.49           7.67       10.03\n    knockOffHaulm             .67kw.2ha         1.92            8.41          22.24       23.46\n    killingHaulm              .67kw.2ha         0.23            1.15           5.48        3.09\n    potatoHarvest             .67kw.2ha        19.94           55.23         189.53      133.98      3\n    potatoTransport           .67kw.2ha         1.61            5.37          31.63       22.82\n*\n*   --- fix costs covered by potaStore type buildings\n*\n    potatoStoring             .67kw.2ha        10.00                                     148.50\n\n\n*\n*---  KTBL 12/13 S.437 und 445  (BL 10.02.2014)\n*\n   singleSeeder               .67kw.2ha         1.0            4.26           28.3        18.39\n   weederHand                 .67kw.2ha        71.52           0.35           1.26         1.09\n   uprootBeets                .67kw.2ha         4.41          49.73         149.98       134.33\n\n*\n*---  KTBL 12/13 S.348  (BL 10.02.2014)\n*\n   DiAmmonium                 .67kw.2ha        0.16            0.65           0.86        1.48\n   grinding                   .67kw.2ha                                                     84\n   disposal                   .67kw.2ha         0.7            3.57           4.19        7.55\n*---  KTBL 14/15 S.331  (WB 27.07.2016)\n*  coveringSilo               .67kw.2ha         4.2                         265.15       60.61\n   coveringSilo               .67kw.2ha         4.2                         000.00       60.61\n\n*     H?cksler wird bei KTBL nur als Dienstleistung gef?hrt, nicht zur Eigenanschaffung\n*\n   chopper                    .67kw.2ha                                                    410\n*\n*---  KTBL 14/15 S.453 (CP 28.02.2018)\n*\n*                                               labTime         diesel      fixCost      varCost   nPers  amount\n   mowing                     .67Kw.2ha         0.64            5.47          8.48         11.39\n   tedding                    .67kw.2ha         0.43            2.78          3.56          6.88\n   raking                     .67kw.2ha         0.51            3.12          4.45          8.02\n   silageTrailer              .67kw.2ha                                                    98.00           11.9\n   closeSilo                  .67kw.2ha         1.09                         69.42         15.87\n   grasReSeeding              .67kw.2ha         0.27            2.07          3.63          4.44\n   roller                     .67kw.2ha         0.34            1.72          3.91          4.36\n*---  KTBL 14/15 S.458 (Silage)/S.515 (Hay) (CP 27.02.2018)\n*---  Ballenpressen mit Wickeln wird bei KTBL als Dienstleistung aufgefuehrt\n   balePressWrap              .67kw.2ha                                                   240.00           11.9\n   balePressHay               .67kw.2ha          0.5            3.02         15.45         14.19            4.8\n   baleTransportSil           .67kw.2ha         1.65            3.29         21.66         16.27           11.9\n   baleTransportHay           .67kw.2ha         1.62            3.02         15.45         14.19            4.8\n;\n</code></pre> <p>Furthermore, the model considers the effect of different plot sizes and the mechanisation levels:</p> <p>[^Comment][embedmd]:# (N:/em/work1/Pahmeyer/FarmDyn/FarmDynDoku/FarmDyn_Docu/gams/coeffgen/tech.gms GAMS /(?i)table\\sp_plotsize/ /;/)</p> <pre><code>table p_plotSizeEffect(crops,machVar,opAttr,plotSize)\n\n                                    1ha    2ha   5ha  20ha\n\n     winterWheat. 67kw .labTime    12.4   10.5   9.3   8.0\n     winterWheat. 67kw .diesel       90     83    78    73\n     winterWheat. 67kw .varCost     205    188   176   168\n     winterWheat. 67kw .fixCost     282    258   241   231\n\n     winterWheat.102kw .labTime    11.1    9.1   7.6   6.8\n     winterWheat.102kw .diesel       95     86    78    74\n     winterWheat.102kw .varCost     209    188   172   164\n     winterWheat.102kw .fixCost     315    284   262   249\n\n     winterWheat.200kw .labTime    11.9    8.6   6.3   4.9\n     winterWheat.200kw .diesel      118     99    84    75\n     winterWheat.200kw .varCost     240    201   173   157\n     winterWheat.200kw .fixCost     396    334   292   267\n ;\n</code></pre> <p>[^Comment][embedmd]:# (N:/em/work1/Pahmeyer/FarmDyn/FarmDynDoku/FarmDyn_Docu/gams/coeffgen/tech.gms GAMS /p_plotSize.*?\"n/ /;/)</p> <pre><code>p_plotSizeEffect(\"winterWheat\",machVar,\"nPers\",plotSize) = 1;\n</code></pre> <p>[^Comment][embedmd]:# (N:/em/work1/Pahmeyer/FarmDyn/FarmDynDoku/FarmDyn_Docu/gams/coeffgen/tech.gms GAMS /p_plotSize.*?\"am/ /;/)</p> <pre><code>p_plotSizeEffect(\"winterWheat\",machVar,\"amount\",plotSize) = 1;\n</code></pre> <p>[^Comment][embedmd]:# (N:/em/work1/Pahmeyer/FarmDyn/FarmDynDoku/FarmDyn_Docu/gams/coeffgen/tech.gms GAMS /p_plotSize.*?$/ /;/)</p> <pre><code>p_plotSizeEffect(crops,machVar,opAttr,plotSize) $ (not p_plotSizeEffect(crops,machVar,opAttr,plotSize))\n  = sum( crops1,  p_plotSizeEffect(crops1,machVar,opAttr,plotSize))\n   /sum( crops1 $ p_plotSizeEffect(crops1,machVar,opAttr,plotSize),1);\n</code></pre> <p>The farm operations are linked to cropping activities (below an example for potatoes):</p> <p>[^Comment][embedmd]:# (N:/em/work1/Pahmeyer/FarmDyn/FarmDynDoku/FarmDyn_Docu/gams/coeffgen/tech.gms GAMS /(?i)table\\scrop_op_per_till/ /0.333/)</p> <pre><code>table crop_op_per_till(crops,operation,labPeriod,till)\n                                                              plough     minTill   noTill          eco  silo  bales\n\n potatoes     .    soilSample          .  AUG1                   0.2         0.2                   0.2\n potatoes     .    basFert             .  AUG1                   1.0         1.0                   1.0\n potatoes     .    solidManDist        .  AUG2                                                     1.0\n potatoes     .    plow                .  AUG2                                                     1.0\n potatoes     .    chiselPlow          .  AUG2                   1.0         1.0\n potatoes     .    sowmachine          .  AUG2                   1.0         1.0\n potatoes     .    mulcher             .  NOV1                   1.0         1.0                   1.0\n potatoes     .    plow                .  NOV1                   1.0                               1.0\n potatoes     .    chiselPlow          .  NOV1                               1.0\n potatoes     .    NminTesting         .  FEB1                   1.0         1.0\n potatoes     .    NFert320            .  MAR1                   1.0         1.0                   1.0\n potatoes     .    chitting            .  MAR1                                                     1.0\n potatoes     .    seedBedCombi        .  MAR2                   1.0\n potatoes     .    rotaryHarrow        .  MAR2                               1.0                   1.0\n potatoes     .    seedPotatoTransp    .  APR1                   1.0         1.0                   1.0\n potatoes     .    potatoLaying        .  APR1                   1.0         1.0                   1.0\n potatoes     .    rakingHoeing        .  APR2                                                     1.0\n potatoes     .    earthingUp          .  APR2                   1.0         1.0\n potatoes     .    weedValuation       .  MAY1                   1.0         1.0                   1.0\n potatoes     .    earthingUP          .  MAY1\n potatoes     .    plantvaluation      .  JUN1                   1.0                               1.0\n potatoes     .    herb                .  JUN1                                                     1.0\n potatoes     .    plantValuation      .  JUN2                   2.0         2.0                   1.0\n potatoes     .    herb                .  JUN2                   2.0         2.0                   2.0\n potatoes     .    plantValuation      .  JUL1                   2.0         2.0\n potatoes     .    herb                .  JUL1                   2.0         2.0                   1.0\n potatoes     .    plantValuation      .  JUL2                   1.0         1.0\n potatoes     .    herb                .  JUL2                   1.0         1.0                   1.0\n potatoes     .    plantValuation      .  AUG1                   1.0         1.0\n potatoes     .    herb                .  AUG1                   1.0         1.0                   1.0\n potatoes     .    plantValuation      .  AUG2                   1.0         1.0\n potatoes     .    herb                .  AUG2                   1.0         1.0\n potatoes     .    knockOffHaulm       .  AUG2                                                     1.0\n potatoes     .    killingHaulm        .  AUG2                   1.0         1.0\n potatoes     .    potatoHarvest       .  SEP1                   0.5         0.5                   0.5\n potatoes     .    potatoTransport     .  SEP1                   0.5         0.5                   0.5\n potatoes     .    potatoStoring       .  SEP1                   0.5         0.5                   0.5\n potatoes     .    potatoHarvest       .  SEP2                   0.5         0.5                   0.5\n potatoes     .    potatoTransport     .  SEP2                   0.5         0.5                   0.5\n potatoes     .    potatoStoring       .  SEP2                   0.5         0.5                   0.5\n potatoes     .    lime_fert           .  OCT1                 0.333\n</code></pre> <p>These information on farm operations determine</p> <ol> <li> <p>The number of necessary field working days and monthly labour     need per ha (excluding the time used for fertilising, which is     determined endogenously)</p> </li> <li> <p>The machinery need for the different crops</p> </li> <li> <p>Related variable costs</p> </li> </ol> <p>The labour needs per month are determined by summing up over all farm operations, considering the labour period, the effect of plot size and mechanisation (coeffgen\\labour.gms):</p> <p>[^Comment][embedmd]:# (N:/em/work1/Pahmeyer/FarmDyn/FarmDynDoku/FarmDyn_Docu/gams/coeffgen/labour.gms GAMS /p_cropLab/ /;/)</p> <pre><code>p_cropLab(crops,till,intens,m) $ sum(plot,c_s_t_i(crops,plot,till,intens))\n\n     = sum( (operation,actmachVar,actPlotSize,labPeriod_to_month(labPeriod,m)),\n              crop_op_per_till(crops,operation,labPeriod,till)\n                     * op_attr(operation,\"67kW\",\"2ha\",\"labTime\")\n*\n*                    -- effect of plot size and mechanisation on labour time\n*\n                         * p_plotSizeEffect(crops,actMachVar,\"labTime\",actPlotSize)\n                          /p_plotSizeEffect(crops,\"67kW\",\"labTime\",\"2ha\")   );\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/BuildingsAndMachines/machinery_old/#endogenous-machine-inventory","title":"Endogenous Machine Inventory","text":"<p>The inventory equation for machinery is shown in machInv_, where v_machInv is the available inventory by type, machType, in operation hours. v_machNeed is the machinery need of the farm in operating hours and v_buyMach are investments in new machines.</p> <p>[^Comment][embedmd]:# (N:/em/work1/Pahmeyer/FarmDyn/FarmDynDoku/FarmDyn_Docu/gams/model/templ.gms GAMS /machInv_(cur/ /;/)</p> <pre><code>machInv_(curMachines(machType),machLifeUnit,tFull(t),nCur)\n         $ (     (v_machInv.up(machType,machLifeUnit,t,nCur) ne 0)\n               $ p_lifeTimeM(machType,machLifeUnit)  $ p_priceMach(machType,t)\n               $ (not sameas(machLifeUnit,\"years\"))  $ t_n(t,nCur) )  ..\n*\n*      --- inventory end of current year (in operating hours, hectares etc.)\n*\n       v_machInv(machType,machLifeUnit,t,nCur)\n\n             =e=\n*\n*        --- inventory end of last year (in operating hours)\n*\n          sum(t_n(t-1,nCur1) $ anc(nCur,nCur1), v_machInv(machType,machLifeUnit,t-1,nCur1))\n*\n*        --- new machines, converted in operation time\n*\n        + (v_buyMach(machType,t,nCur)+v_buyMachFlex(machType,t,nCur)) * p_lifeTimeM(machType,MachLifeUnit)\n*\n*        --- minus operating hours in current year if in normal planning period\n*\n        - v_machNeed(machType,machLifeUnit,t,nCur)  $ tCur(t)\n*\n*        --- minus operating hours of weighted average over normal planning period\n*            if beyond the normal planning period\n*\n        - [sum( (t_n(t1,nCur1)) $ ( (p_year(t1) lt p_year(t)) $ tCur(t1) $ isNodeBefore(nCur,nCur1)),\n                          v_machNeed(machType,machLifeUnit,t1,nCur1)\n                                                                      * 1/(p_year(t)+5 - p_year(t1)) )\n          /sum( (t1) $ ( (p_year(t1) lt p_year(t)) $ tCur(t1)),         1/(p_year(t)+5 - p_year(t1)) )\n           ]\n                       $ ( (not tCur(t)) and p_prolongCalc)\n       ;\n</code></pre> <p>The last expression is used when the farm program for the simulated period is used to estimate the machinery needs for all years until the stables are fully depreciated.</p> <p>The machinery need in each year is defined from activities or processes requiring machinery::</p> <p>[^Comment][embedmd]:# (N:/em/work1/Pahmeyer/FarmDyn/FarmDynDoku/FarmDyn_Docu/gams/model/GENERAL_HERD_MODULE.gms GAMS /machNeedHerds_(c/ /;/)</p> <pre><code>machNeedHerds_(curMachines(machType),machLifeUnit,tCur(t),nCur)\n        $ (sum(actHerds(sumHerds,breeds,feedRegime,t,m),\n               p_machNeed(sumHerds,\"plough\",\"normal\",machType,machLifeUnit)) $ t_n(t,nCur)) ..\n\n       v_machNeedHerds(machType,machLifeUnit,t,nCur)\n\n         =e=\n*\n*      --- herd sizes times their request for specific machine type\n*\n          sum(actHerds(sumHerds,breeds,feedRegime,t,m) $ p_prodLength(sumHerds,breeds),\n             v_herdSize(sumHerds,breeds,feedRegime,t,nCur,m)\n              * p_machNeed(sumHerds,\"plough\",\"normal\",machType,machLifeUnit)\n                          * 1/min(12,p_prodLength(sumHerds,breeds)) * 12/card(herdM));\n</code></pre> <p>[^Comment][embedmd]:# (N:/em/work1/Pahmeyer/FarmDyn/FarmDynDoku/FarmDyn_Docu/gams/model/templ.gms GAMS /machines_(c/ /;/)</p> <pre><code>machines_(curMachines(machType),machLifeUnit,tCur(t),nCur) $ (p_lifeTimeM(machType,machLifeUnit) $ t_n(t,nCur)) ..\n*\n*      --- crops times their request for specific machine type\n*\n     + sum( c_s_t_i(curCrops(crops),plot,till,intens),\n           v_cropHa(crops,plot,till,intens,t,nCur)\n            * p_machNeed(crops,till,intens,machType,machLifeUnit))\n\n     + sum( (c_s_t_i(curCrops(crops),plot,till,intens),syntFertilizer,m),\n              v_syntDist(crops,plot,till,intens,syntFertilizer,t,nCur,m)\n               * p_machNeed(syntFertilizer,\"plough\",\"normal\",machType,machLifeUnit))\n\n*        ---- machine need for the application of N (manure/fertilizer)\n\n$iftheni.man %manure% == true\n\n     + sum((c_s_t_i(curCrops(crops),plot,till,intens),manApplicType_manType(ManApplicType,curManType),m)\n              $ (v_manDist.up(crops,plot,till,intens,manApplicType,curManType,t,nCur,m) ne 0),\n                v_manDist(crops,plot,till,intens,ManApplicType,curManType,t,nCur,m)\n                  * p_machNeed(ManApplicType,\"plough\",\"normal\",machType,machLifeUnit))\n\n$endif.man\n\n$iftheni.herd %herd%==true\n\n      + v_machNeedHerds(machType,machLifeUnit,t,nCur)\n           $ sum(actHerds(sumHerds,breeds,feedRegime,t,m),\n                 p_machNeed(sumHerds,\"plough\",\"normal\",machType,machLifeUnit))\n$endif.herd\n*\n*         --- total machinery need\n*\n              =L= v_machNeed(machType,machLifeUnit,t,nCur)\n    ;\n</code></pre> <p>A small set of machinery, such as the front loader, dung grab, shear grab or fodder mixing vehicles are depreciated by time and not by use:</p> <p>[^Comment][embedmd]:# (N:/em/work1/Pahmeyer/FarmDyn/FarmDynDoku/FarmDyn_Docu/gams/model/templ.gms GAMS /machInvT_(c/ /;/)</p> <pre><code>machInvT_(curMachines(machType),tFull(t),nCur)\n        $ (      (v_machInv.up(machType,\"years\",t,nCur) ne 0)\n                $ p_lifeTimeM(machType,\"years\")\n                $ p_priceMach(machType,t) $ t_n(t,nCur)  )  ..\n*\n*      --- inventory end of current year (in operating hours)\n*\n       v_machInv(machType,\"years\",t,nCur)\n\n     +  sum( t_n(t1,nCur1) $ (  (p_year(t1) gt smax( tOld $ p_iniMachT(machType,told),\n                                                     p_year(tOld) + p_lifeTimeM(machType,\"years\")))\n                             $  (p_year(t1)+p_prolongLen gt p_year(t))\n                             $ tCur(t1)  $ isNodeBefore(nCur,nCur1)),\n                 v_machInv(machType,\"years\",t1,nCur1)/p_proLongLen)\n                                                $ ( (not tCur(t)) and p_prolongCalc)\n\n          =L=\n*\n*         --- old machines according to investment dates\n*             (will drop out of equation if too old)\n*\n          sum( tOld $ (   ((p_year(tOld) + p_lifeTimeM(machType,\"years\")) ge p_year(t))\n                              $ ( p_year(told)                            le p_year(t))),\n                                 p_iniMachT(machType,tOld))\n\n*\n*         --- plus (old) investments - de-investments\n*\n       +  sum( t_n(t1,nCur1) $ (  ((p_year(t1)  + p_lifeTimeM(machType,\"years\") ) ge p_year(t))\n                                $ ( p_year(t1)                                    le p_year(t))\n                                $ isNodeBefore(nCur,nCur1)),\n                                                v_buyMach(machType,t1,nCur1));\n</code></pre> <p>The aforementioned set of machinery, depreciated by time and not usage, are linked to the existence of stables, i.e. stables cannot be used if machinery is not present:</p> <p>[^Comment][embedmd]:# (N:/em/work1/Pahmeyer/FarmDyn/FarmDynDoku/FarmDyn_Docu/gams/model/general_herd_module.gms GAMS /machInvStable_(c/ /;/)</p> <pre><code>machInvStable_(curMachines(machType),stables,tCur(t),nCur) $ ( (v_machInv.up(machType,\"years\",t,nCur) ne 0)\n                                                                 $  (   sum( t_n(t1,nCur1) $ isNodeBefore(nCur,nCur1),\n                                                                            v_buyStables.up(stables,\"long\",t1,nCur1))\n                                                                    or  sum( tOld, p_iniStables(stables,\"long\",tOld)))\n                                                                  $ sum(stables_to_mach(stables,machType),1)\n\n                                                    $ p_lifeTimeM(machType,\"years\")  $ p_priceMach(machType,t)  $ t_n(t,nCur))  ..\n\n       sum(stables_to_mach(stables,machType), v_stableInv(stables,\"long\",t,nCur))\n          =L= v_machInv(machType,\"years\",t,nCur);\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/BuildingsAndMachines/manure_storage/","title":"Manure Storage","text":"<p>Abstract Manure can be stored subfloor in stables and in different types of silos. The manure management is described in detail and takes into account, for example, storage losses, residues and emptying periods. Storage capacities depend on the environmental law predefined in FarmDyn's graphical user interface.</p> <p>The manure silo inventory (v_siloInv) for each type of silo (silos) is defined as seen in the following equation siloInv_. p_iniSilos is the initial endowment of manure silos in the construction year, p_lifeTimeSi is the maximal physical lifetime of the silo, and v_buyilosF are newly constructed silos.</p> <pre><code>siloInv_(curManChain(manChain),silos,tCur(t),nCur)\n          $ (  (p_ManStorCapSi(silos) gt eps)\n               $(   sum(t_n(t1,nCur1) $ isNodeBefore(nCur,nCur1), (v_buySilos.up(manChain,silos,t1,nCur1) ne 0))\n               or sum(tOld, p_iniSilos(manChain,silos,tOld))) $ t_n(t,nCur) ) ..\n\n       v_siloInv(manChain,silos,t,nCur)\n\n            =L=\n*\n*         --- Old silo according to building date and lifetime\n*             (will drop out of equation if too old)\n*\n           sum(tOld $ (   ((p_year(tOld) + p_lifeTimeSi(silos)) gt p_year(t))\n                        $ ( p_year(told)                        le p_year(t))),\n                           p_iniSilos(manChain,silos,tOld))\n\n*\n*         --- Plus (old) investments - de-investments\n*\n           +  sum(t_n(t1,nCur1) $ (tcur(t1) $ isNodeBefore(nCur,nCur1)\n                                 and (   ((p_year(t1)  + p_lifeTimeSi(silos)) gt p_year(t))\n                                       $ ( p_year(t1)                         le p_year(t)))),\n                                           v_buysilosF(manChain,silos,t1,nCur1));\n</code></pre> <p>The manure silos are linked to the manure storage needs, which are described in the following. Equations related to manure storage serve mainly for the calculation of the needed storage capacity, linked to investment, and for the calculation of emissions during storage. The equations related to manure storage in manure_module.gms are activated when fatteners, sows, dairy and/or biogas braches are activated in the graphical user interface (GUI).</p> <p>The amount of manure in the storage in cubic meter is described in the following equation. Sources for manure are monthly animal excretion, biogas differentiated by input, and purchased manure. Manure silos are  emptied by field application, v_volManApplied. When activated in the GUI, manure can also be exported from the farm.</p> <pre><code>volInStorage_(curManChain(manChain),tCur(t),nCur,m) $ ( t_n(t,nCur)$ ( not sameas (manchain,\"LiquidImport\"))  ) ..\n\n       v_volInStorage(manChain,t,nCur,m) =e= [sum(t_n(t-1,nCur1) $ anc(nCur,nCur1),\n                                  v_volInStorage(manChain,t-1,nCur1,\"Dec\")) $ (sameas(m,\"Jan\") $ tCur(t-1))\n                                + v_volInStorage(manChain,t,nCur,m-1)     $ (not sameas(m,\"Jan\"))]\n\n\n* ---- in comparative static setting, manure in Jan includes manure from Dec, assuming steady flow\n\n                   $$iftheni.cs \"%dynamics%\" == \"comparative-static\"\n                                + v_volInStorage(manChain,t,nCur,\"Dec\")     $ sameas(m,\"Jan\")\n                   $$endif.cs\n\n\n                   $$iftheni.herd %herd% == true\n*\n*                               --- m3 excreted per year divied by # of month: monthly inflow\n*\n                                + v_manQuantM(manChain,t,nCur,m) $ (not sameas(manchain,\"LiquidBiogas\"))\n                   $$endif.herd\n\n*                               --- m3 coming from biogas plant s energy crops and purchased manure\n                   $$iftheni.b %biogas% == true\n\n*                               --- Diogas digestate based on energy crops\n\n                                +  sum(crm(biogasfeedM), v_volDigCrop(crM,t,nCur,m)) $ sameas(manchain,\"LiquidBiogas\")\n\n*                               --- Biogas digestate based on manure\n\n                                +  v_volDigMan(t,nCur,m) $ sameas(manchain,\"LiquidBiogas\")\n                   $$endif.b\n*\n*                               --- m3 taken out of storage type for application to crops\n*\n                                - v_volManApplied(manChain,t,nCur,m)\n\n                   $$iftheni.ExMan \"%AllowManureExport%\"==\"true\"\n\n*                               --- m3 exported from farm\n\n                                - sum (manChain_Type(manChain,curManType), v_manExport(manChain,curManType,t,nCur,m))\n                   $$endif.ExMan\n\n                   $$iftheni.emissionRight not \"%emissionRight%\"==0\n*                               --- m3 exported through manure emission rights\n\n                                - sum (manChain_Type(manChain,curManType), v_manExportMER(manChain,curManType,t,nCur,m))\n                   $$endif.emissionRight\n                             ;\n</code></pre> <p>Following the same structure as the equation above, there is a nutrient pool for NTAN, Norg and P in the storage. Losses of NTAN and Norg during storage are calculated in the environmental accounting and subtracted from the respective pool.</p> <pre><code>nutPoolInStorage_(curManChain(manChain),nut2,tCur(t),nCur,m) $ ( t_n(t,nCur)$ ( not sameas (manchain,\"LiquidImport\"))  ) ..\n\n            v_nutPoolInStorage(manChain,nut2,t,nCur,m)\n\n              =e=  [sum(t_n(t-1,nCur1) $ anc(nCur,nCur1),\n                          v_nutPoolInStorage(manChain,nut2,t-1,nCur1,\"Dec\")) $ (sameas(m,\"Jan\") $ tCur(t-1))\n                        + v_nutPoolInStorage(manChain,nut2,t,nCur,m-1)       $ (not sameas(m,\"Jan\"))]\n\n\n* ---- in comparative static setting, nutrient pool in Jan includes nutrient pool from Dec, assuming steady flow\n\n              $$iftheni.cs \"%dynamics%\" == \"comparative-static\"\n\n                   + v_nutPoolInStorage(manChain,nut2,t,nCur,\"Dec\")       $ sameas(m,\"Jan\")\n\n               $$endif.cs\n\n               $$iftheni.herd %herd% == true\n\n                 + v_nut2ManureM(manChain,nut2,t,nCur,m) $ (not sameas(manchain,\"LiquidBiogas\"))\n\n               $$endif.herd\n\n               $$iftheni.biogas %biogas% == true\n\n                 +  sum( (curBhkw(bhkw),curEeg(eeg),curmaM),   v_nut2ManurePurch(\"LiquidBiogas\",nut2,curmaM,t,nCur,m)  ) $ sameas(manchain,\"LiquidBiogas\")\n\n                 +  v_nutCropBiogasM(\"LiquidBiogas\",nut2,t,nCur,m) $ sameas(manchain,\"LiquidBiogas\")\n\n               $$endif.biogas\n\n*               --- storage losses\n\n                - v_nutLossInStorage(manChain,nut2,t,nCur,m)\n\n*               --- Nutrients applied\n\n                 - sum(curCrops, v_nut2ManApplied(curCrops,manChain,nut2,t,nCur,m))\n\n*               --- Nutrients exported from farm\n\n               $$iftheni.ExMan \"%AllowManureExport%\"==\"true\"\n\n                 - v_nut2export(manChain,nut2,t,nCur,m)\n\n               $$endif.ExMan\n\n               $$iftheni.emissionRight not \"%emissionRight%\"==0\n\n*               --- Nutrient exported via manure emission rights\n\n                -  v_nut2ExportMER(manChain,nut2,t,nCur,m)\n\n                $$endif.emissionRight\n ;\n</code></pre> <p>Storage losses of reactive nitrogen are calculated in the equation nutLossInStorage_, using emission factors from the environmental impact accounting module.</p> <pre><code>nutLossInStorage_(curManChain(manChain),nut2,tCur(t),nCur,m) $ t_n(t,nCur)  ..\n\n       v_nutLossInStorage(manChain,nut2,t,nCur,m) =E=\n\n*             --- NH3 losses in stable and storage, only related to N TAN\n\n            $$iftheni.herd %herd% == true\n              [\n                   + v_nut2ManureM(manChain,\"NTAN\",t,nCur,m) * (p_EFSta(\"NH3\",manChain) + p_EFSto(\"NH3\",manChain) ) $ sameas(nut2,\"NTAN\")\n\n*             --- N2O, N2 and NO losses in stable and storage, related to NTAN and Norg\n\n                   + v_nut2ManureM(manChain,\"NTAN\",t,nCur,m)\n                    * ( p_EFStaSto(\"N2O\",curManChain) + p_EFStaSto(\"NOx\",curManChain) + p_EFStaSto(\"N2\",curManChain) ) $ sameas(nut2,\"NTAN\")\n\n                   + v_nut2ManureM(manChain,\"NOrg\",t,nCur,m)\n                    * ( p_EFStaSto(\"N2O\",curManChain) + p_EFStaSto(\"NOx\",curManChain) + p_EFStaSto(\"N2\",curManChain) ) $ sameas(nut2,\"NOrg\")\n\n               ] $ (not sameas(manchain,\"LiquidBiogas\"))\n            $$endif.herd\n\n*             --- N2O, N2 and NO losses from storage from digestate, related to NTAN and Norg\n\n            $$iftheni.biogas %biogas% == true\n\n             + {\n                     [ ( v_nutCropBiogasM(manchain,\"NTAN\",t,nCur,m)\n                          + sum (curmaM(mam), v_nut2ManurePurch(manchain,\"NTAN\",curmaM,t,nCur,m)  ) )\n\n                           *  (p_EFStaSto(\"N2O\",curManChain) + p_EFStaSto(\"NOx\",curManChain) + p_EFStaSto(\"N2\",curManChain))\n\n                      ]  $ sameas(nut2,\"NTAN\")\n\n                   + [ ( v_nutCropBiogasM(manchain,\"NOrg\",t,nCur,m)   + sum (curmaM(mam), v_nut2ManurePurch(manchain,\"NOrg\",curmaM, t,nCur,m) ) )\n                            *( p_EFStaSto(\"N2O\",curManChain)   + p_EFStaSto(\"NOx\",curManChain)  + p_EFStaSto(\"N2\",curManChain))\n                      ]  $ sameas(nut2,\"NOrg\")\n\n               } $ sameas(manchain,\"LiquidBiogas\")\n\n           $$endif.biogas\n        ;\n</code></pre> <p>The amount of manure in the storage needs to fit to the available storage capacity which is calculated in the equation totalManStorCap_. The total storage capacity is the sum of the sub floor storage in stables, silos and silos for digestates from biogasproduction. Note: when the biogas branch is active without herds, thesto rage concept is simplified.</p> <pre><code>totalManStorCap_(curManChain(manChain),tCur(T),nCur) $ t_n(t,nCur) ..\n\n       v_TotalManStorCap(manChain,t,nCur) =e=\n\n$iftheni.herd %herd%  == true\n                              v_SubManStorCap(manChain,t,nCur)  $ (not sameas (\"LiquidBiogas\",manchain))\n                            + v_SiloManStorCap(manChain,t,nCur) $ (not sameas (\"LiquidBiogas\",manchain))\n$endif.herd\n$ifi %biogas% == true       + v_siloBiogasStorCap(t,nCur) $ sameas (\"LiquidBiogas\",manchain)\n    ;\n</code></pre> <p>The storage capacity of silos v_SiloManStorCap is derived by multiplying the silo inventory with parameters characterising the corresponding storage capacity.</p> <pre><code>siloManStorCap_(curManChain(manChain),tCur(t),nCur) $ t_n(t,nCur) ..\n\n       v_SiloManStorCap(manChain,t,nCur)\n\n          =e= sum(silos $ (    sum(t_n(t1,nCur1) $ isNodeBefore(nCur,nCur1), (v_buySilos.up(manChain,silos,t1,nCur1) ne 0))\n                            or sum(tOld, p_iniSilos(manChain,silos,tOld))),\n                               v_SiloInv(manChain,silos,t,nCur) * p_ManStorCapSi(silos))    ;\n</code></pre> <p>The subfloor storage capacity of stables v_SubManStorCap is calculated in the general_herd_module.gms. The stable inventory is multiplied with parameters characterising the corresponding subfloor storage capacity. The amount of manure which can be stored in the stable building, p_ManStorCap, depends on the stable system. Slurry based systems with a plane floor normally only have small cesspits which demand the addition of manure silo capacities. The manure storage capacity of stables with slatted floor depends on the size of the stable, where a storage capacity for manure of three month in a fully occupied stable is assumed. A set of different dimensioned liquid manure reservoirs is depicted in the parameter, p_ManStorCapSi, ranging from 500 to 4000 m\u00b3.</p> <pre><code>subManStorCap_(curManChain(manChain),tCur(t),nCur) $(t_n(t,nCur)$(not sameas(curManChain,\"LiquidBiogas\"))) ..\n\n       v_SubManStorCap(manChain,t,nCur) =e=\n       sum(stables $ (     [ sum( (t_n(t1,nCur1),hor) $ ( (isNodeBefore(nCur,nCur1) or sameas(nCur,nCur1)) and (p_year(t1) le p_year(t))),\n                                                             (v_buyStables.up(stables,hor,t1,nCur1) ne 0))\n                                                    or (sum( (tOld,hor), p_iniStables(stables,hor,tOld)))\n                                                   ]  $ (p_ManStorCap(manChain,stables) gt eps)\n                                                    ),\n\n                                             v_StableInv(stables,\"long\",t,nCur)*p_ManStorCap(manChain,stables));\n</code></pre> <p>The storage capacity for digestates from biogas plants, v_siloBiogasStorCap, is linked to the size of the biogas plant and calculated in the biogas_module.gms.</p> <pre><code>invSiloBiogas_(tCur(t), nCur) $ t_n(t,nCur) ..\n\n        v_siloBiogasStorCap(t,nCur) =E= sum((curbhkw(bhkw), curEeg(eeg)), v_invBiogas(bhkw,eeg,t,ncur) * p_siloBiogas(bhkw));\n</code></pre> <p>The total volume is distributed to the different storage types based on the following equations.</p> <pre><code>storageDistr_(curManChain(manChain),t_n(tCur(t),nCur),m) ..\n\n       v_volInStorage(manChain,t,nCur,m) =e=\n\n              sum (manStorage,v_volInStorageType(manChain,ManStorage,t,nCur,m)) ;\n</code></pre> <p>For the silos related to animal husbandry, different coverage of silos can be applied. The type of silo cover used for a certain type of silo, v_siCovComb, is a binary variable, i.e. one type of silo must be fully covered or not.</p> <pre><code>siloCoverInv_(curManChain(manChain),silos,tCur(t),nCur)\n       $ ( (    sum(t_n(t1,nCur1) $ isNodeBefore(nCur,nCur1), (v_buySilos.up(manChain,silos,t1,nCur1) ne 0))\n             or sum(tOld, p_iniSilos(manChain,silos,tOld))) $ t_n(t,nCur)) ..\n\n       v_siloInv(manChain,silos,t,nCur) =e=  sum(siloCover, v_siCovComb(manChain,silos,t,nCur,siloCover));\n</code></pre> <p>The amount of storage capacity is prescribed by environmental law FarmDyn allows applying different regulations with regard to the required storage capacity, changed in the GUI. Thereby FarmDyn allows to precisely capture the requirements of the German Fertilisation Ordinance 2007,2017 and 2020, which is further specified in the fertilisation ordinance section.</p> <p>The total manure storage capacity v_TotalManStorCap must be greater than the required storage capacity v_ManStorCapNeed.</p> <pre><code>manStorCap_(curManChain(manChain),t_n(tCur(t),nCur)) ..\n\n       v_TotalManStorCap(manChain,t,nCur) =g= v_ManStorCapNeed(manChain,t,nCur);\n</code></pre> <p>Besides legal requirements for the storage capacity, there are equations which make sure that the storage is emptied in certain points of time. Every spring, the storage has to be emptied completely with regard to nutrients and volume, which is ensured by the equations emptyStorageVol_ and emptyStorageNut_. On the one hand, this represents typical manure management of farms. On the other hand, the restriction is necessary to make sure that the correct relation between mass and nutrients is maintained when nutrients and volume changes due to nutrient losses during storage.</p> <pre><code>emptyStorageVol_(curManChain(manChain),t_n(tCur(t),nCur),m) $ sameas(m,\"apr\") ..\n\n             v_volInStorage(manChain,t,nCur,m) =L= 0;\n</code></pre> <pre><code>emptyStorageNut_(curManChain(manChain),nut2,t_n(tCur(t),nCur),m) $ sameas(m,\"apr\") ..\n\n            v_nutPoolInStorage(manChain,nut2,t,nCur,m) =L= 0;\n</code></pre> <p>Furthermore, at the end of the time period modelled, only 1/3 of the annual excreted manure is allowed to remain in the storage, to avoid unrealistic behaviour in the last year modelled. This is ensured with the following equations.</p> <pre><code>maxManVolStorLastMonth_(curManChain(manChain),t_n(\"%lastYear%\",nCur),\"Dec\")  ..\n\n                        (\n\n$ifi %herd% == true         v_manQuant(manChain,\"%lastYearCalc%\",nCur)$ (not sameas(manchain,\"LiquidBiogas\"))\n\n$ifi %biogas% == true     + sum((crm(biogasFeedM),m), v_voldigCrop(crM,\"%lastYearCalc%\",nCur,m)+ v_volDigMan(\"%lastYearCalc%\",nCur,m) ) $ sameas(manchain,\"LiquidBiogas\")\n\n                         ) * 8/12\n\n                       =G=  v_volInStorage(manChain,\"%lastYear%\",nCur,\"Dec\");\n</code></pre> <pre><code>maxManNutStorLastMonth_(curManChain(manChain),nut2,\"%lastYear%\",nCur,\"Dec\") $ t_n(\"%lastYear%\",nCur) ..\n\n                       (\n\n$ifi %herd% ==true          sum(m, v_nut2ManureM(manChain,nut2,\"%lastYear%\",nCur,m) $ (not sameas(manchain,\"LiquidBiogas\")))\n\n                         $$iftheni.biogas %biogas% == true\n\n                          + sum((curmaM,m), v_nut2ManurePurch(manchain,nut2,curmaM,\"%lastYear%\",nCur,m) ) $ sameas(manchain,\"LiquidBiogas\")\n\n                          + sum(m, v_nutCropBiogasM(\"LiquidBiogas\",nut2,\"%lastYear%\",nCur,m))             $ sameas(manchain,\"LiquidBiogas\")\n\n                         $$endif.biogas\n\n                       ) * 8/12\n\n                      =G=  v_nutPoolInStorage(manChain,nut2,\"%lastYear%\",nCur,\"Dec\");\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/BuildingsAndMachines/other_buildings/","title":"Other Type of Buildings","text":"<p>Abstract Other buildings in Farmdyn comprise bunker silos for maize or grass silage and potatoe storage. The actual size and corresponding costs and labour requirements are presented in the investment and financing section.</p>"},{"location":"FarmDynDocumentation/ModelDescription/BuildingsAndMachines/other_buildings/#bunker-silos-and-storages","title":"Bunker Silos and Storages","text":"<p>The inventories for the other buildings (bunker silos for maize or grass silage and potatoe storages) are combined into one equation. The structure is similar to the inventory equation of manure silos and stables:</p> <pre><code>buildingInv_(curBuildings(buildings),tCur(t),nCur)\n        $ ( (    sum(t_n(t1,nCur1) $ isNodeBefore(nCur,nCur1), (v_buyBuildings.up(buildings,t1,nCur1) ne 0))\n                 or (sum(tOld, p_iniBuildings(buildings,tOld)))) $ t_n(t,nCur) ) ..\n\n       v_buildingsInv(buildings,t,nCur)\n\n            =L=\n*\n*         --- old building / silo according to building date and lifetime\n*             (will drop out of year is too far in the past)\n*\n           sum(tOld $ (   ((p_year(tOld) + p_lifeTimeBuild(buildings)) gt p_year(t))\n                        $ ( p_year(told)                               le p_year(t))),\n                           p_iniBuildings(buildings,tOld))\n*\n*         --- plus (old) investments - de-investments\n*\n        + sum(t_n(t1,nCur1) $ (   ((p_year(t1)  + p_lifeTimeBuild(buildings)) gt p_year(t))\n                                $ ( p_year(t1)                         le p_year(t))\n                                $ tcur(t1) $ isNodeBefore(nCur,nCur1)),\n                                  + v_buyBuildingsF(buildings,t1,nCur1));\n</code></pre> <p>The buildings included in the model are:</p> <pre><code>set s_bunkerSilos /\n                   bunkerSilo0\n                   bunkerSilo450\n*                   bunkerSilo900\n*                   bunkerSilo1620\n*                   bunkerSilo2640\n*                   bunkerSilo3630\n*                   bunkerSilo4620\n*                   bunkerSilo8580\n*                   bunkerSilo11870\n                   bunkerSilo26550\n                 /;\n</code></pre> <pre><code>set buildings  /\n                     set.s_potaStores\n                     set.s_bunkerSilos\n                   /;\n</code></pre> <p>The attributes of the buildings are defined in dat\\buildings_de.gms:</p> <pre><code>table p_building(buildings,buildAttr)\n                     invSum   capac_t  capac_m3   lifeTime    varCost\n\n  potaStore0                   eps                 12\n  potaStore100t     80000      100                 12          323\n  potaStore500t    195850      500                 12          323\n  potaStore11250t 1740000    11250                 12          323\n*\n*  --- KTBL 2014/15 p.144\n*\n  bunkerSilo0                            eps        20\n  bunkerSilo450      34176               450        20\n*  bunkerSilo900      60900               900        20\n*  bunkerSilo1620     84490              1620        20\n*  bunkerSilo2640    115770              2640        20\n*  bunkerSilo3630    127110              3630        20\n*  bunkerSilo4620    138450              4620        20\n*  bunkerSilo8580    218250              8580        20\n*  bunkerSilo11870   284970             11870        20\n  bunkerSilo26550   482000             26550        20\n   ;\n</code></pre> <p>The inventory of the buildings is linked to building needs of certain activities:</p> <pre><code>buildingNeed_(curBuildType(buildType),buildCapac,tCur(t),nCur)\n         $ (sum(curProds(prods),p_buildingNeed(prods,buildType,buildCapac)) $ t_n(t,nCur) ) ..\n\n       sum(buildType_buildings(buildType,buildings)\n               $ (  (     sum(t_n(t1,nCur1) $ isNodebefore(nCur,nCur1), (v_buyBuildings.up(buildings,t1,nCur1) ne 0))\n                      or  sum(tOld, p_iniBuildings(buildings,tOld)))\n                       $ curBuildings(buildings)),\n\n            v_buildingsInv(buildings,t,nCur) * p_building(buildings,buildCapac))\n\n                 =G= v_buildIngNeed(buildType,t,nCur);\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/BuildingsAndMachines/stables/","title":"Stables","text":"<p>Abstract Stables in FarmDyn are differentiated by size and animal type. The stable size present in the inventory is determined by the  number of animals set in the GUI. The investment decision and final size of the stable is described in the investment and financing section. Based on the actual stable size, aspects such as labour requirements and variable costs are set. Eventually, cattle stables differentiate between different type of flooring and manure management systems.</p> <p>Different types of stables are implemented in FarmDyn. In general, stables are differentiated between calf, cow, mother cow, young cattle (including beef fattening), piglet, fattener, and sow stables. These stables are available in different sizes. For more information on investment decision in different stable sizes please refer to the section investment and financing. The requirement of an animal for a certain stable type is defined by the parameter p_stableNeed. Through this approach, it is possible for some herds to share a stables place, e.g. calves and heifers, or bulls and heifers by assigning their stable need to the same stable type. Stable types can further be specified through their manure management system, depicted by the set stableStyle. As a default, all stable types will employ slatted floor manure handling, resulting in only liquid manure handling on the farm. Choosing a straw stable for a herd will consequently affects costs, manure handling, and labour requirement.</p> <p>The stable inventory (v_stableInv) for each type of stable, (stables), is defined as seen in the following equation stableInv_. p_iniStables is the initial endowment of stables in the construction year, p_lifeTimeS is the maximal physical lifetime of the stables, and v_buyStablesF are newly constructed stables.</p> <pre><code>stableInv_(stables,hor,tFull(t),nCur)\n       $ (   (p_priceStables(stables,hor,t) gt eps)\n               $ (      sum( (t_n(t1,nCur1),hor1) $ ((isNodeBefore(nCur,nCur1) or sameas(nCur,nCur1)) and (p_year(t1) le p_year(t))),\n                         (v_buyStables.up(stables,hor1,t1,nCur1) ne 0))\n                    or  sum( tOld, p_iniStables(stables,hor,tOld)))\n                     $ (sum(stableTypes,p_stableSize(stables,StableTypes)) gt eps)\n                     $ t_n(t,nCur) ) ..\n\n       v_stableInv(stables,hor,t,nCur)\n\n          =L=\n*\n*         --- old stables according to building date and lifetime\n*             (will drop out of equation if too old)\n*\n          sum( tOld $ (   ((p_year(tOld) + p_lifeTimeS(stables,hor)) gt p_year(t))\n                              $ ( p_year(told)                       le p_year(t))),\n                           p_iniStables(stables,hor,tOld))\n\n*\n*         --- plus (old) investments - de-investments\n*\n       +  sum( t_n(t1,nCur1) $ ( isNodeBefore(nCur,nCur1)\n                                   $  (   ((p_year(t1)  + p_lifeTimeS(stables,hor) ) gt p_year(t))\n                                   $ (      p_year(t1)                               le p_year(t)))),\n                                                    v_buyStablesF(stables,hor,t1,nCur1));\n</code></pre> <p>The variable v_stableUsed is defined as the size of a herd multiplied with the herds requirement for stable places in a particular stable type.</p> <pre><code>stables_(stableTypes,tCur(t),nCur,m)\n          $ (sum(actHerds(sumHerds,breeds,feedRegime,t,m) $ ((not sameas(feedRegime,\"fullGraz\"))\n                  $ v_herdSize.up(sumHerds,breeds,feedRegime,t,nCur,m)), p_stableNeed(sumHerds,breeds,stableTypes))\n                  $ t_n(t,nCur) )  ..\n*\n       v_stableNeed(stableTypes,t,nCur)\n\n          =L=\n*\n*         --- must be covered by current stable inventory (not fully depreciated building),\n*             mutiplied with the stable places they offer\n*\n       sum(stables $ (    sum( (t_n(t1,nCur1),hor) $ ((isNodeBefore(nCur,nCur1) or sameas(nCur,nCur1)) and (p_year(t1) le p_year(t))),\n                               (v_buyStables.up(stables,hor,t1,nCur1) ne 0))\n                       or sum( (tOld,hor), p_iniStables(stables,hor,tOld))),\n           v_stableUsed(stables,t,nCur) * p_stableSize(stables,stableTypes));\n</code></pre> <p>Eventually, the utilised stable places (v_stableUsed), need to be covered by the available stable inventory (v_stableInv):</p> <pre><code>stableUsed_(stables,hor,tFull(t),nCur,m)\n       $ ( (p_priceStables(stables,hor,t) gt eps)\n           $  (       sum( (t_n(t1,nCur1),hor1) $ ((isNodeBefore(nCur,nCur1) or sameas(nCur,nCur1)) and (p_year(t1) le p_year(t))),\n                               (v_buyStables.up(stables,hor1,t1,nCur1) ne 0))\n                or  sum( (tOld,hor1), p_iniStables(stables,hor1,tOld)))\n                     $ (sum(stableTypes,p_stableSize(stables,StableTypes)) gt eps) $  t_n(t,nCur)) ..\n\n       v_stableInv(stables,hor,t,nCur) =G= [v_stableUsed(stables,t,nCur) + v_stableNotUsed(stables,t,nCur,m)] $ tCur(t)\n\n                                         + [   sum( (t1,nCur1) $ ( isNodeBefore(nCur,nCur1) $ sameas(t1,\"%lastYear%\") $ t_n(t1,nCur1) $ (not sameas(t,t1))),\n                                                                    v_stableUsed(stables,t1,nCur1)+ v_stableNotUsed(stables,t1,nCur1,m))\n                                           ]  $ ( (not tCur(t)) and p_prolongCalc);\n</code></pre> <p>The investment horizon set hor differentiates between the initial investment into the building, assumed to last for 30 years, and certain equipment for which maintenance investments are necessary after 10 or 15 years for cow stables.</p> <p>A stable can only be used, if short and middle term maintenance investments are done. The different stable attributes are defined in \"coeffgen\\stables.gms\".</p>"},{"location":"FarmDynDocumentation/ModelDescription/CropProduction/cropping_land_and_land_use/","title":"Cropping, Land and Land Use","text":"<p>Abstract The cropping module optimises the cropping pattern subject to land availability, reflecting yields, prices, machinery and fertilising needs, and other variable costs for a selectable list of arable crops. The crops can be differentiated by production system (conventional, organic), tillage (plough, minimal tillage, no tillage) and intensity level (normal and reduced fertilisation in 20 % steps). Machinery use is linked to field working-day requirements depicted with a bi-weekly resolution during the relevant months. Crop rotational constraints can be either depicted by introducing crop rotations or by simple maximal shares. The model can capture plots which are differentiated by soil and land type (grassland, arable land and pasture), size and distance.</p>"},{"location":"FarmDynDocumentation/ModelDescription/CropProduction/cropping_land_and_land_use/#cropping-activities-in-the-model","title":"Cropping Activities in the Model","text":"<p>Crop activities are differentiated by crop, crops, soil types, soil, management intensity, intens, and tillage type, till. The use of different management intensities and tillage types is optional. Management intensities impact yield levels. Necessary field operations and thus variable costs, machinery and labour needs reflect intensity and tillage type as well.</p> <p>The farmer is assumed to be able to adjust on a yearly basis its land use  as long as the labour, machinery and further restrictions allow for it. Land is differentiated into arable and permanent grass land, landType. Land use decisions can be restricted by maximal rotational shares for the individual crops. The set plot differentiates the land with regard to plot size, soil type and climate zone. The attributes of plots and the number of plots from 1 to 20, is defined in the Graphical User Interface (GUI).</p> <p>The total land endowment is calculated in the equation totPlotLand_ as the sum of the initial endowment, p_plotSize(plot), and land purchased, v_buyLand, in the past or current year.</p> <pre><code>totPlotLand_(plot,tCur(t),nCur) $ (p_plotSize(plot) $ t_n(t,nCur)) ..\n\n       v_totPlotLand(plot,t,nCur)\n\n            =E=\n*\n*            --- initialize of plots\n*\n             p_plotSize(plot)\n*\n*            --- plus bought adjacent plots (= merged)\n*\n$ifi %landBuy% == true + sum(t_n(t1,nCur1) $ (tcur(t1) $ isNodeBefore(nCur,nCur1) $ (ord(t1) le ord(t))), v_buyPlot(plot,t1,nCur1))\n             ;\n</code></pre> <p>Total cropped land is defined by the land occupied by the different crops, v_cropHa. The c_p_t_i set defines the active possible combinations of crops, soil type, tillage type/system and management intensity.</p> <pre><code>croppedLand_(landType,soil,t_n(tCur(t),nCur)) ..\n\n       v_croppedLand(landType,soil,t,nCur)\n          =e= sum( (curCrops(crops),plot_lt_soil(plot,landType,soil),till,intens)\n                    $ c_p_t_i(crops,plot,till,intens), v_cropHa(crops,plot,till,intens,t,nCur)\n                             $( not catchcrops(crops) ));\n</code></pre> <p>The total land v_totPlotLand can be either used for cropping (including permanent grassland), v_croppedLand, or rented out, v_rentOutLand, on a yearly basis. The option to rent out land can be activated in the GUI:</p> <pre><code> plotland_(plot,t_n(tCur(t),nCur)) $ p_plotSize(plot) ..\n*\n           sum(sys,v_croppedPlotLand(plot,sys,t,nCur))\n*\n$ifi %landLease% == true + v_rentOutPlot(plot,t,nCur)*p_plotSize(plot)\n*\n              =E= v_totPlotLand(plot,t,nCur);\n</code></pre> <p>That a farm stays within a maximum stocking rate ceiling, expressed in livestock units per ha, is ensured by the following equation. The maximal allowed stocking rate can be adjusted in the GUI:</p> <pre><code>luLand_(t_n(tCur(t),nCur)) ..\n\n       sum( plot $ p_plotSize(plot), v_totPlotLand(plot,t,nCur)\n\n$ifi %landLease% == true            -v_rentOutPlot(plot,t,nCur) * p_plotSize(plot)\n\n           ) * p_maxStockRate  =G=  v_sumGV(t,nCur);\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/CropProduction/cropping_land_and_land_use/#optional-crop-rotational-module","title":"Optional Crop Rotational Module","text":"<p>Alternatively to the use of maximum rotational shares, the model offers an option of a three year crop rotation system. The rotation names (shown in the following list, see dat\\crops_de.gms), set rot, displays the order of the crops in the rotations. Each line depicts sequences of three crop types (do not have to be different) in a rotation with only the order being differently. This avoids unnecessary rigidities in the model.</p> <pre><code>set rot \"Rotations\" / WC_WC_PO,WC_PO_WC,PO_WC_WC\n                          WC_WC_SC,WC_SC_WC,SC_WC_WC\n                          WC_WC_SU,WC_SU_WC,SU_WC_WC\n                          WC_WC_OT,WC_OT_WC,OT_WC_WC\n                          WC_WC_ID,WC_ID_WC,ID_WC_WC\n\n                          WC_SC_PO,SC_PO_WC,PO_WC_SC\n                          WC_SC_SU,SC_SU_WC,SU_WC_SC\n                          WC_SC_OT,SC_OT_WC,OT_WC_SC\n                          WC_SC_ID,SC_ID_WC,ID_WC_SC\n\n                          SC_WC_SC,SC_SC_WC,WC_SC_SC\n                          SC_SC_ID,SC_ID_SC,ID_SC_SC\n                          SC_SC_PO,SC_SC_SU,SC_SC_OT\n                          WC_PO_ID,WC_SU_ID,WC_OT_ID\n                          SC_PO_ID,SC_SU_ID,SC_OT_ID\n                          WC_ID_ID,ID_WC_ID,ID_ID_WC\n                          SC_ID_ID,ID_SC_ID,ID_ID_SC\n                          PO_ID_ID,SU_ID_ID,OT_ID_ID\n                          ID_ID_ID\n                          PO_OT_WC,OT_WC_PO,WC_PO_OT\n                          SU_OT_WC,OT_WC_SU,WC_SU_OT\n                          PO_OT_SC,OT_SC_PO,SC_PO_OT\n                          SU_OT_SC,OT_SC_SU,SC_SU_OT\n                          SU_OT_PO,OT_PO_SU,PO_SU_OT\n                        /;\n</code></pre> <p>Remark: WC: winter cereals, SC: summer cereals, PO: potatoes, SU: sugar beets, ID: idling land, OT: other</p> <p>The rotations are linked to groups of crops in the first, second and third year of the rotation as can be seen in the following equation (only cross-set definitions rot_cropTypes for the first rotation are shown).</p> <pre><code>set rot_cropTypes(rot,cropTypes,cropTypes,cropTypes)  \"Rotation, first / second / third year crop type\"\n                                         /\n                                           WC_WC_PO.WinterCere.WinterCere.potatoes\n                                           WC_PO_WC.WinterCere.potatoes.WinterCere\n                                           PO_WC_WC.potatoes.WinterCere.WinterCere\n\n                                           WC_WC_OT.WinterCere.WinterCere.other\n                                           WC_OT_WC.WinterCere.other.WinterCere\n                                           OT_WC_WC.other.WinterCere.WinterCere\n\n                                           WC_WC_ID.WinterCere.WinterCere.idle\n                                           WC_ID_WC.WinterCere.idle.WinterCere\n                                           ID_WC_WC.idle.WinterCere.WinterCere\n\n                                           WC_WC_SU.WinterCere.WinterCere.sugarBeet\n                                           WC_SU_WC.WinterCere.sugarBeet.WinterCere\n                                           SU_WC_WC.sugarBeet.WinterCere.WinterCere\n\n                                           WC_WC_SC.WinterCere.WinterCere.summerCere\n                                           WC_SC_WC.WinterCere.summerCere.WinterCere\n                                           SC_WC_WC.summerCere.WinterCere.WinterCere\n\n                                           WC_SC_PO.WinterCere.summerCere.potatoes\n                                           SC_PO_WC.summerCere.potatoes.WinterCere\n                                           PO_WC_SC.potatoes.WinterCere.summerCere\n\n                                           WC_SC_SU.WinterCere.summerCere.sugarBeet\n                                           SC_SU_WC.summerCere.sugarBeet.WinterCere\n                                           SU_WC_SC.sugarBeet.WinterCere.summerCere\n\n                                           WC_SC_ID.WinterCere.summerCere.idle\n                                           SC_ID_WC.summerCere.idle.WinterCere\n                                           ID_WC_SC.idle.WinterCere.summerCere\n\n                                           WC_SC_OT.WinterCere.summerCere.other\n                                           SC_OT_WC.summerCere.other.WinterCere\n                                           OT_WC_SC.other.WinterCere.summerCere\n\n\n                                           SC_WC_SC.summerCere.WinterCere.summerCere\n                                           WC_SC_SC.WinterCere.summerCere.summerCere\n                                           SC_SC_WC.summerCere.summerCere.WinterCere\n\n                                           WC_ID_ID.WinterCere.idle.idle\n                                           ID_WC_ID.idle.WinterCere.idle\n                                           ID_ID_WC.idle.idle.WinterCere\n\n                                           SC_ID_ID.summerCere.idle.idle\n                                           ID_SC_ID.idle.summerCere.idle\n                                           ID_ID_SC.idle.idle.summerCere\n\n                                           SC_SC_ID.summerCere.summerCere.idle\n                                           SC_ID_SC.summerCere.idle.summerCere\n                                           ID_SC_SC.idle.summerCere.summerCere\n\n                                           SC_SC_PO.summerCere.summerCere.potatoes\n                                           WC_PO_ID.WinterCere.potatoes.idle\n                                           SC_PO_ID.summerCere.potatoes.idle\n                                           ID_ID_ID.idle.idle.idle\n                                           PO_ID_ID.potatoes.idle.idle\n\n                                           SC_SC_SU.summerCere.summerCere.sugarBeet\n                                           WC_SU_ID.WinterCere.sugarBeet.idle\n                                           SC_SU_ID.summerCere.SugarBeet.idle\n                                           SU_ID_ID.sugarBeet.idle.idle\n\n\n\n                                           SC_SC_OT.summerCere.summerCere.other\n                                           WC_OT_ID.WinterCere.other.idle\n                                           SC_OT_ID.summerCere.other.idle\n                                           OT_ID_ID.other.idle.idle\n\n                                           PO_OT_WC.potatoes.other.WinterCere\n                                           OT_WC_PO.other.WinterCere.potatoes\n                                           WC_PO_OT.WinterCere.potatoes.other\n\n                                           PO_OT_SC.potatoes.other.summerCere\n                                           SU_OT_WC.SugarBeet.other.WinterCere\n                                           OT_WC_SU.other.WinterCere.SugarBeet\n                                           WC_SU_OT.WinterCere.SugarBeet.other\n\n                                           SU_OT_SC.SugarBeet.other.summerCere\n                                           OT_SC_SU.other.summerCere.SugarBeet\n                                           SC_SU_OT.summerCere.SugarBeet.other\n\n                                           SU_OT_PO.SugarBeet.other.potatoes\n                                           OT_PO_SU.other.potatoes.SugarBeet\n                                           PO_SU_OT.potatoes.SugarBeet.other\n\n                                         /;\n</code></pre> <p>The link between individual crops and crop types used in the rotation definitions is as follows:</p> <pre><code>set cropTypes_crops(cropTypes,crops) / winterCere.(set.winterCere)\n                                          summerCere.(set.SummerCere,set.Maize)\n                                          other.(set.Other,set.catchCrops)\n                                          potatoes.(set.potatoes)\n                                          sugarbeet.(set.sugarbeet)\n                                          idle.idle\n                                      /;\n</code></pre> <p>To use the crop rotations in the model equations, three cross sets are generated which define the crop type in the first, second and third year for each rotation:</p> <pre><code>set cropType0_rot(cropTypes,rot);cropType0_rot(cropTypes,rot) $ sum(rot_cropTypes(rot,cropTypes,cropTypes1,cropTypes2),1) = YES;\n</code></pre> <pre><code>set cropType1_rot(cropTypes,rot);cropType1_rot(cropTypes,rot) $ sum(rot_cropTypes(rot,cropTypes1,cropTypes,cropTypes2),1) = YES;\n</code></pre> <pre><code>set cropType2_rot(cropTypes,rot);cropType2_rot(cropTypes,rot) $ sum(rot_cropTypes(rot,cropTypes1,cropTypes2,cropTypes),1) = YES;\n</code></pre> <p>For each simulation, crops can be selected to be available for cropping  on farm, therefore, it is possible that not all rotations are operational. Accordingly, in coeffgen\\coeffgen.gms, the set of available crop rotations is defined:</p> <pre><code>cropType0_rot(cropTypes,rot) $ (not sum( (cropType0_rot(cropTypes1,rot),curCrops) $ cropTypes_crops(cropTypes1,curCrops),1)) = NO;\n</code></pre> <pre><code> cropType0_rot(cropTypes,rot) $ (not sum( (cropType1_rot(cropTypes1,rot),curCrops) $ cropTypes_crops(cropTypes1,curCrops),1)) = NO;\n</code></pre> <pre><code> cropType0_rot(cropTypes,rot) $ (not sum( (cropType2_rot(cropTypes1,rot),curCrops) $ cropTypes_crops(cropTypes1,curCrops),1)) = NO;\n</code></pre> <pre><code> cropType1_rot(cropTypes,rot) $ (not sum( (cropType1_rot(cropTypes1,rot),curCrops) $ cropTypes_crops(cropTypes1,curCrops),1)) = NO;\n</code></pre> <pre><code> cropType1_rot(cropTypes,rot) $ (not sum( (cropType0_rot(cropTypes1,rot),curCrops) $ cropTypes_crops(cropTypes1,curCrops),1)) = NO;\n</code></pre> <pre><code> cropType1_rot(cropTypes,rot) $ (not sum( (cropType2_rot(cropTypes1,rot),curCrops) $ cropTypes_crops(cropTypes1,curCrops),1)) = NO;\n</code></pre> <pre><code> cropType2_rot(cropTypes,rot) $ (not sum( (cropType2_rot(cropTypes1,rot),curCrops) $ cropTypes_crops(cropTypes1,curCrops),1)) = NO;\n</code></pre> <pre><code> cropType2_rot(cropTypes,rot) $ (not sum( (cropType0_rot(cropTypes1,rot),curCrops) $ cropTypes_crops(cropTypes1,curCrops),1)) = NO;\n</code></pre> <pre><code> cropType2_rot(cropTypes,rot) $ (not sum( (cropType1_rot(cropTypes1,rot),curCrops) $ cropTypes_crops(cropTypes1,curCrops),1)) = NO;\n</code></pre> <p>The rotations enter the model via three constraints (see model\\general_cropping_module.gms). The right hand side sums up the crop hectares of a certain crop type in the current year in all three constraints, while the left hand side exhausts these hectares in the current, next and year after next year based on the rotations grown in these years.</p> <pre><code>rotHa0_(cropTypes,plot,t_n(tCur(t),nCur)) $ (not sum(plot_lt_soil(plot,\"gras\",soil),1))\n\n            $ (sum(cropType0_rot(cropTypes,curRot(rot)),1)\n               $ sum( (cropTypes_crops(cropTypes,crops),c_p_t_i(crops,plot,till,intens))\n                           $ (v_cropHa.up(crops,plot,till,intens,t,nCur) ne 0),1))) ..\n\n        sum( (cropTypes_crops(cropTypes,crops),c_p_t_i(crops,plot,till,intens)), v_cropHa(crops,plot,till,intens,t,nCur))\n\n            =E=   sum(cropType0_rot(cropTypes,curRot(rot)), v_rotHa(rot,plot,t,nCur));\n</code></pre> <pre><code>rotHa1_(cropTypes,plot,tCur(t),nCur) $ ((not sum(plot_lt_soil(plot,\"gras\",soil),1) )\n\n            $ (sum(cropType1_rot(cropTypes,curRot(rot)),1)\n               $ sum( (cropTypes_crops(cropTypes,crops),c_p_t_i(crops,plot,till,intens))\n                           $ (v_cropHa.up(crops,plot,till,intens,t,nCur) ne 0),1)\n                           $ tCur(t+1)) $ t_n(t,nCur)  ) ..\n\n        sum( (cropTypes_crops(cropTypes,crops),c_p_t_i(crops,plot,till,intens)), v_cropHa(crops,plot,till,intens,t,nCur))\n\n            =E=   sum((cropType1_rot(cropTypes,curRot(rot)),t_n(t+1,nCur1)), v_rotHa(rot,plot,t+1,nCur1));\n</code></pre> <pre><code>rotHa2_(cropTypes,plot,tCur(t),nCur) $ ((not sum(plot_lt_soil(plot,\"gras\",soil),1))\n\n            $ (sum(cropType2_rot(cropTypes,curRot(rot)),1)\n               $ sum( (cropTypes_crops(cropTypes,crops),c_p_t_i(crops,plot,till,intens))\n                           $ (v_cropHa.up(crops,plot,till,intens,t,nCur) ne 0),1)\n                           $ tCur(t+2)) $ t_n(t,nCur) ) ..\n\n        sum( (cropTypes_crops(cropTypes,crops),c_p_t_i(crops,plot,till,intens)), v_cropHa(crops,plot,till,intens,t,nCur))\n\n            =E=   sum((cropType2_rot(cropTypes,curRot(rot)),t_n(t+2,nCur1)), v_rotHa(rot,plot,t+2,nCur1));\n</code></pre> <p>The rotations restrict the combination of crops and enter into the optional soil pool balancing approach.</p>"},{"location":"FarmDynDocumentation/ModelDescription/CropProduction/cropping_land_and_land_use/#grassland-management","title":"Grassland Management","text":""},{"location":"FarmDynDocumentation/ModelDescription/CropProduction/cropping_land_and_land_use/#grazing-of-herds","title":"Grazing of Herds","text":"<p>For cows, bulls, heifers and calves, the user can define on the interface if no grazing (= all day long in stable), partial grazing (= half day in stable) or full grazing (= no time in stable) can be used. Figure XY illustrates the grazing of calves as specified in the GUI. The entries would imply that calves have to kept in stable during JAN,FEB,NOV,DEC as no other option is open, partial grazing is additionally possible in MAR and OCT, and during the period APR-SEP, the farmer has the choice of all three types. </p> <p>The labour needs differ between the three options:</p> <pre><code>p_herdLab(\"heifs\",\"noGraz\",m)        =   9 / card(m);\n</code></pre> <pre><code>p_herdLab(\"heifs\",\"partGraz\",m)      =   9 / card(m) + 0.5;\n</code></pre> <pre><code>p_herdLab(\"heifs\",\"fullGraz\",m)      =   5 / card(m);\n</code></pre> <p>The additional work load for partial grazing is calculated as follows: It is assumed that it takes one hour a day to move the herd form the stable to the pasture and back (= 15 hours in total in a month). The average herd driven is assumed to be equal to 60 animals for cows and 30 animals for heifers/bulls. For calves which are assumed to be driven with other herds, 0.25 hours a month are added. The introduction of these grazing feeding regimes (part of the set \u201cfeedRegime\u201d) requires a change in the logic of the program. The v_herdStart variable now is no longer indexed with the feed regime \u2013 reflecting that e.g. a heifer entering the cow herd might during its lifetime as a cow sometimes be grazed and sometimes not. The herdsSize_ equation (see gams\\model\\general_herd_module) equilibrates the herd sizes in the different months (left hand side) to the herds starting in the yearly and months before:</p> <pre><code>sum(feedRegime $ actHerds(herds,breeds,feedRegime,t,m),\n    v_herdSize(herds,breeds,feedRegime,t,nCur,m))\n  =E=\n*\n*         --- herds which started in the months before the production length, in case for piglets a separate construct is used\n*\n  sum((t_n(t1,nCur1),m1)\n    $ ((((-p_mDist(t,m,t1,m1) le (p_prodLength(herds,breeds)-1))\n        $ (p_mDist(t,m,t1,m1) le 0))\n        or\n        ((abs(p_mDist(t,m,t1,m1)-12) le (p_prodLength(herds,breeds)-1))\n        $ (p_mDist(t,m,t1,m1)-12 le 0)) $ p_compStatHerd\n       )\n       $ sum(feedRegime,actHerds(herds,breeds,feedRegime,t1,m1))\n       $ isNodeBefore(nCur,nCur1)\n       $$iftheni.sows \"%farmBranchSows%\" == \"on\"\n         $(not sameas(herds,\"piglets\"))\n       $$endif.sows\n     ),\n      v_herdStart(herds,breeds,t1,nCur1,m1)\n\n      $$iftheni.ch %cowHerd%==true\n*\n*       --- minus, in case of cows, slaughtered before reaching the final age\n*\n        -sum( (slgtCows,cows)\n          $ (sum(feedRegime, actHerds(slgtCows,breeds,feedRegime,t1,m1))\n            $ sameas(cows,herds) $ (slgtCows.pos eq cows.pos)),\n          v_herdStart(slgtCows,breeds,t1,nCur,m1))\n      $$endif.ch\n    )\n*\n*  --- add herds multiple times if their process length is longer than 12\n*\n\n  +  sum((t_n(t1,nCur1),m1)\n      $ (((-p_mDist(t,m,t1,m1) le (p_prodLength(herds,breeds)-1))\n          $\n          (   (abs(p_mDist(t,m,t1,m1)-12) le (p_prodLength(herds,breeds)-1))$ (p_mDist(t,m,t1,m1) le 0)\n          or  (abs(p_mDist(t,m,t1,m1)-24) le (p_prodLength(herds,breeds)-1))$ (p_mDist(t,m,t1,m1) ge 0)\n          ) $ p_compStatHerd $\n                                  $$ifi defined cows (not cows(herds) $ (p_prodLength(herds,breeds) gt 12))\n                                  $$ifi not defined cows (1 eq 1)\n         )\n         $ sum(feedRegime,actHerds(herds,breeds,feedRegime,t1,m1))\n         $ isNodeBefore(nCur,nCur1)\n         $$iftheni.sows \"%farmBranchSows%\" == \"on\"\n           $(not sameas(herds,\"piglets\"))\n         $$endif.sows\n      ),\n         v_herdStart(herds,breeds,t1,nCur1,m1)\n*\n*       --- minus, in case of cows, slaughtered before reaching the final age\n*\n      $$iftheni.ch %cowHerd%==true\n        -sum( (slgtCows,cows)\n          $ (sum(feedRegime, actHerds(slgtCows,breeds,feedRegime,t1,m1))\n            $ sameas(cows,herds) $ (slgtCows.pos eq cows.pos)),\n          v_herdStart(slgtCows,breeds,t1,nCur,m1))\n      $$endif.ch\n         )\n*\n*         --- Herd size dynamic for piglets separately to depict a correct transfer from year t to year t1 as well as account for temporal resolution adjustments\n*\n\n  $$iftheni.sows \"%farmBranchSows%\" == \"on\"\n    +  sum( (t_n(t1,nCur1),m1)\n      $ ((abs(p_mDist(t,m,t1,m1)) le (p_prodLengthB(herds,breeds) -1\n        $ (p_prodLengthB(herds,breeds) eq 1)))\n      $ (p_mDist(t,m,t1,m1) le 0)\n      $ isNodeBefore(nCur,nCur1)\n      $ sum(feedRegime,actHerds(herds,breeds,feedRegime,t1,m1))\n      $ (sameas(herds,\"youngPiglets\") or sameas(herds,\"piglets\"))\n      $ {\n        (sameas(t,t1) $ (not sameas(m  - p_prodLengthB(herds,breeds),m1)))\n        or ((not sameas(t,t1)) $ (sameas(\"Jan\",m))$ (sameas( m + 11, m1)))\n      }\n      ),\n         v_herdStart(herds,\"\",t1,nCur1,m1))\n  $$endif.sows\n;\n</code></pre> <p>An additional equation (see model\\cattle_module.gms) ensures that the feeding phase variable is linked to herd in a specific feed regime:</p> <pre><code>herdsByFeedRegime_(herds,breeds,feedRegime,t,n,m)         \"Distribute herds to feed regimes\"\n      herdsreqsPhase_(herds,breeds,reqsPhase,m,t,n)             \"Animal herds in a certain phase in a certain month\"\n      reqsPhase_(herds,breeds,feedRegime,reqs,reqsPhase,m,t,n)  \"Animal requirements need to be covered\"\n      sumReqs_(reqs,t,n)                                        \"Total requirements per year\"\n      sumReqsBought_(reqs,t,n)                                  \"Total requirements per year from bought feed\"\n      feedUse_(feeds,t,n)                                       \"Definition of total feed use\"\n      feedUseHerds_(herds,feeds,t,n)                            \"Definition of total feed use\"\n      feedUseM_(feeds,m,t,n)                                    \"Definition of total feed use\"\n      prodsM_(prods,m,t,n)                                      \"Monthly feed use definition\"\n      herdsBefore_(herds,breeds,feedRegime,t,t,n,m)             \"First two years\"\n      herdsStartBefore_(herds,breeds,t,t,n,m)                   \"First two years\"\n      sumHerdsYY_(sumHerdsY,breeds,t,n)                          \"Summary herd definition, per year, sold herds\"\n      avgLactations_(breeds,t,n)                                \"Recover average lactation length from short and long\"\n      maxHerdChange1_(herds,breeds,feedRegime,t,n,n)            \"Special restricton for heifer and calves raisingherd\"\n      maxHerdChange2_(herds,breeds,feedRegime,t,n,n)            \"Special restricton for heifer and calves raisingherd\"\n      hasHerdOrderDairy_(t,n)\n      hasHerdOrderMotherCows_(t,n)\n\n$iftheni.dh %cowherd%==true\n      newCalves_(breeds,t,n,m)                                  \"Born calves (male and female)\"\n      maleFemaleRel_(breeds,t,n,m)                              \"Born calves, keep male/female relation\"\n      calvesRaisBal_(herds,breeds,t,n,m)\n$elseifi.dh \"%buyCalvs%\"==\"true\"\n      calvesRaisBal_(herds,breeds,t,n,m)\n$endif.dh\n\n      herdExcrPast_(herds,grazRegime,t,n,m)                     \"Allocate grazing to grazing plots\"\n      nutExcrPast_(allNut,t,n,m)                                \"N and P excretion on pasture\"\n      nut2ManurePast_(crops,plot,till,intens,allNut,t,n,m)\n      manQuantPast_(crops,plot,till,intens,manChain,t,n,m) \"Defintion of manure quantity in m3 per month on pastures\"\n      FixGrasLand_(t,n)                                         \"Ensures that there is no grassland on arable land\"\n      FixPastLand_(t,n)                                         \"Distribution of gras and past land on total land  \"\n\n      buyCowStablesSos2_(hor,t,n,cowStables)\n      buyMotherCowStablesSos2_(hor,t,n,motherCowStables)\n      buyYoungStablesSos2_(hor,t,n,youngStables)\n      buyCalvStablesSos2_(hor,t,n,calvStables)\n;\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/CropProduction/cropping_land_and_land_use/#nutrient-content-of-different-grassland-outputs","title":"Nutrient Content of Different Grassland Outputs","text":"<p>The model now supports three types of fresh gras (labelled early \u2013 middle \u2013 late), three types of gras silage (labelled early \u2013 middle \u2013 late) and hay based on their feed attributes per unit of dry matter. Dry matter content is inputted as well:</p> <p></p>"},{"location":"FarmDynDocumentation/ModelDescription/CropProduction/cropping_land_and_land_use/#grassland-management_1","title":"Grassland Management","text":"<p>The user can define up to 10 different types of grassland management by the following two attributes: 1.  Total dry matter output, 2.  Distribution of outputs (see above) over months. The default setting defines two differently intensive grazing schemes, which only differ in dry matter output and two different silage use schemes:</p> <p></p> <p></p> <p></p> <p></p> <p>Embedded phyton code (see gams\\util\\grasAttr.gms) introduces more easily interpretable labels for the grassland reporting: After the original label follows the annual dry matter yield, followed by the number of cuts (where applicable) and the share of biomass used for grazing resp. silage or hay. The assignment of machinery needs and (related) labour hours in defined in \u201cgams\\model\\coeffgen\\tech.gms\u201d and \u201cdat\\cropop_de.gms\u201d:</p> <pre><code>* --- definition of basic field operations for graslands\n*\n set.gras     .    soilSample          .  SEP2                                      0.25                 0.25  0.25   0.25    0.25\n set.gras     .    weederlight         .  MAR2                                      0.25                 0.25  0.25   0.25    0.25\n set.gras     .    sowMachine          .  MAR2                                      0.75                 0.75  0.75   0.75    0.75\n set.gras     .    grasReSeeding       .  APR1                                      0.25                 0.25  0.25   0.25    0.25\n set.gras     .    roller              .  APR1                                      0.25                 0.25  0.25   0.25    0.25\n ;\n</code></pre> <p>The operations shown above occur on all type of grasslands in the given frequency. The operations related to cuts are defined as follows:</p> <pre><code>* --- definition of cuts for grasland\n*\n$ifthen.gras defined noPastOutputs\n\n\n  set toSilage(noPastOutputs) / earlyGrasSil,middleGrasSil,lateGrasSil /;\n  set toHay(noPastOutputs) / hay /;\n  set toPast(grasOutputs) /earlyGraz,middleGraz,lateGraz /;\n\n  set grasToOutput(crops,grasOutputs);\n  grasToOutput(crops,grasOutputs) $ sum((m) $(p_grasAttr(crops,grasOutputs,m)), 1) = YES;\n\n  table p_opPerCut(operation,noPastOutputs,till) \"Field operations for one gras cut per cutting process (either silo or bales)\"\n                                     silo     bales  hay\n     mowing.set.noPastOutputs        1.00      1.00  1.0\n     tedding.set.noPastOutputs       1.00      1.00  1.0\n     raking.set.noPastOutputs        1.00      1.00  1.0\n*\n*   --- these operations are changed by harvested biomas\n*\n    closeSilo.set.toSilage          1.00\n    silageTrailer.set.toSilage      1.00\n    balePressWrap.set.toSilage               1.00\n    balePressHay.hay                               1.00\n    baleTransportSil.set.toSilage            1.00\n    baleTransportHay.hay                           1.00\n  ;\n\n  parameter p_bioMassOpsFac(operation) \"Factor in order to correct dry matter content to witted silage content (35% DM) or hay (86% DM)\"\n  /\n    silageTrailer        0.35\n    balePressWrap        0.35\n    baleTransportSil     0.35\n    balePressHay         0.86\n    baleTransportHay     0.86\n</code></pre> <p>And are used to define the machinery needs:</p> <pre><code>* --- count lab period where gras is cut\n*\n  parameter p_cutPeriod(crops,*) \"Count # of labour period where grass is cut\";\n\n  p_cutPeriod(curCrops(grassCrops),labPeriod)\n    = sum( (labPeriod_to_month(labPeriod,m),noPastOutputs) $ p_grasAttr(grassCrops,noPastOutputs,m),1);\n\n*  p_cutPeriod(gras,labPeriod) = sum( labPeriod_to_month(labPeriod,m),p_cutPeriod(gras,m));\n*\n* --- silo cut for silage\n*\n\n  p_crop_op_per_till(curCrops(grassCrops),operation,labPeriod,\"org\",\"graz\")\n    = p_crop_op_per_till(grassCrops,operation,labPeriod,\"noTill\",\"graz\");\n\n\n  p_crop_op_per_till(curCrops(grassCrops),operation,labPeriod,\"org\",\"silo\")\n    = p_crop_op_per_till(grassCrops,operation,labPeriod,\"noTill\",\"silo\");\n\n  p_crop_op_per_till(curCrops(grassCrops),operation,labPeriod,\"org\",\"bales\")\n    = p_crop_op_per_till(grassCrops,operation,labPeriod,\"noTill\",\"bales\");\n\n  p_crop_op_per_till(curCrops(grassCrops),operation,labPeriod,\"org\",\"hay\")\n    = p_crop_op_per_till(grassCrops,operation,labPeriod,\"noTill\",\"hay\");\n\n  set grassTill(till) / noTill,org /;\n\n  p_crop_op_per_till(curCrops(grassCrops),operation,labPeriod,grassTill,\"silo\")\n     $ sum(toSilage, (p_cutPeriod(grassCrops,labPeriod) $ p_opPerCut(operation,toSilage,\"silo\") $ grasToOutput(grassCrops,toSilage)))\n    =   sum( (labPeriod_to_month(labPeriod,m),toSilage) $ p_grasAttr(grassCrops,toSilage,m),\n          p_opPerCut(operation,\"middleGrasSil\",\"silo\")/2\n*\n*            --- change machinery needs (or not) depending on harvested dry matter\n*\n                 * (    1 $ (not p_bioMassOpsFac(operation))\n                     +  (p_grasAttr(grassCrops,toSilage,m) * ( 1 $ sameas(grassTill,\"noTill\") + p_organicYieldMult(grassCrops) $ sameas(grassTill,\"org\"))\n                            /p_bioMassOpsFac(operation)/op_attr(operation,\"67kw\",\"2\",\"amount\")) $ p_bioMassOpsFac(operation))\n          )/ p_cutPeriod(grassCrops,labPeriod);\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/CropProduction/fertilizer_application/","title":"Fertiliser Application","text":"<p>Abstract The nutrient demand by crops can be either met by synthetic or organic fertiliser. The implementation of synthetic fertiliser application accounts for only very few N and P fertiliser with related input costs and the respective labour need, and machinery use. In contrast, the application of organic fertiliser considers different application machinery with their linked emission levels, labour requirements, etc.. Further, multiple organic fertiliser types are accounted for with varying levels of nutrients. Both application types consider agronomic aspects such as minimum application levels (synthetic) or periods where application is not possible (manure).</p>"},{"location":"FarmDynDocumentation/ModelDescription/CropProduction/fertilizer_application/#synthetic-fertilisers","title":"Synthetic Fertilisers","text":"<p>To meet the N and P demand of crops, synthetic fertiliser, v_syntDist, can be applied besides manure. Synthetic fertiliser application enters equations with regard to the buying of inputs, buy_ and varcost_, the labour need for application, labCropSM_, the field work hours and machinery, fieldWorkHours_ and machines_, and with regard to  plant nutrition. The equation nMinMan_ ensures that minimum amounts of mineral fertiliser are applied for certain crops. It represents the limitation meeting the plant need with nutrients from manure, e.g. fertilising short before harvest for baking wheat cannot be done with manure.</p> <pre><code>nMinMin_(c_p_t_i(curCrops(crops),plot,till,intens),nut,t_n(tCur(t),nCur))\n        $ (  (v_cropHa.up(crops,plot,till,intens,t,nCur) ne 0)\n                $ p_minChemFert(crops,nut) $ (not (sameas(till,\"org\") or lower(intens) or veryLow(intens))) ) ..\n\n       sum ((curInputs(syntFertilizer),m),\n                      v_syntDist(crops,plot,till,intens,syntFertilizer,t,nCur,m)\n                                                   * p_nutInSynt(syntFertilizer,nut))\n              =G=\n\n                v_cropHa(crops,plot,till,intens,t,nCur) * p_minChemFert(crops,nut)\n                  *  sum(plot_soil(plot,soil),p_nutNeed(crops,soil,till,intens,nut,t));\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/CropProduction/fertilizer_application/#organic-fertilisers","title":"Organic Fertilisers","text":"<p>Different application procedures for manure N are implemented, ManApplicType, including broad spread, drag hose spreader, injection of manure, and solid manure spread. The core variable is v_mandist which represents the amount of manure in distributed cubic meter. The different techniques are related to different application costs, labour requirements as well as effects on different emissions. Furthermore, manure application is linked to the nutrient balance and the manure storage.</p> <p>The application of manure links nutrient with volumes. The nutrient content of the manure is depending on the herd's excretion as well as on the losses during storage. The parameter p_nut2inMan contains the amount of NTAN, Norg and P per cubic meter of manure applied. The parameter is differentiated for the manure types linked to the present herd. Relevant parameters are calculated in coeffgen\\manure.gms.</p> <p>As a first step, the amount of different nutrients per cubic meter without losses is calculated in p_nut2inManNoLoss. Here, the nutrient excretion of the animals is related to their volume excretion depending on the stables present on the farm.</p> <p>In a second step, the nutrients per cubic meter are corrected for the storage losses in p_nut2inMan. Varying storage time of manure, and hence varying nutrient content, can be taken into account by activating the \"Nutrient loss depending on storage time\" control in the graphical user interface. In this case, for the manure of every herd, two types of manure are calculated, representing the maximum and minimum possible amount of losses during one year. This allows a complete emptying of the storage in a linear programming setting. In the default case, only the minimum losses are assumed.</p> <p>The total manure distributed in cubic meter and in nutrients per month is summarised in the following equations according to:</p> <pre><code>nut2ManApplied_(curCrops,curManChain(manChain),nut2,t_n(tCur(t),nCur),m) $ (v_volManApplied.up(manChain,t,nCur,m) ne 0) ..\n\n       v_nut2ManApplied(curCrops,manChain,nut2,t,nCur,m) =e=\n                                  sum( (plot,till,intens,manChain_applic(manChain,ManApplicType),curManType)\n                                          $ (manApplicType_manType(ManApplicType,curManType)\n                                          $ (v_manDist.up(curCrops,plot,till,intens,manApplicType,curManType,t,nCur,m) ne 0)\n                                          $ (not sameas (curCrops,\"catchcrop\")) $c_p_t_i(curCrops,plot,till,intens)),\n\n                                         v_manDist(curCrops,plot,till,intens,ManApplicType,curManType,t,nCur,m)\n                                                  * p_nut2inMan(nut2,curManType,manChain));\n</code></pre> <pre><code>volManApplied_(curManChain(manChain),t_n(tCur(t),nCur),m) $ (v_volManApplied.up(manChain,t,nCur,m) ne 0) ..\n\n       v_volManApplied(manChain,t,nCur,m)\n         =e= sum( (c_p_t_i(curCrops(crops),plot,till,intens),\n                     manChain_applic(manChain,ManApplicType),curManType)\n                                           $ (manApplicType_manType(ManApplicType,curManType)\n                                           $ (v_manDist.up(crops,plot,till,intens,manApplicType,curManType,t,nCur,m) ne 0)\n                                           $ (not sameas (curCrops,\"catchcrop\")) ),\n                     v_manDist(crops,plot,till,intens,ManApplicType,curManType,t,nCur,m));\n</code></pre> <p>There are several restrictions with regard to the application of manure. First of all, the application of manure is not possible in some crops in some months, e.g. in maize at certain height of growth.</p> <pre><code>set doNotApplyManure(crops,m) /\n                                 set.potatoes           .(Jun,Jul,Aug)\n                                 set.maize              .(Jun,Jul,Aug)\n                                 set.sugarbeet          .(Jun,Jul,Aug)\n                                 set.rapeseed           .(May,Jun,Jul)\n                                 set.summerCere         .(May,Jun,Jul)\n                                 set.WinterCere         .(Apr,May,Jun,Jul)\n                                /;\n</code></pre> <p>For these months, v_manDist is forced to be zero.</p>"},{"location":"FarmDynDocumentation/ModelDescription/CropProduction/plant_nutrition/","title":"Plant Nutrition","text":"<p>Crops in FarmDyn require nitrogen (N) and phosphate (P2O5) to grow. Conceptually, the nutrient need is opposed by different nutrient sources such as chemical fertilizer, manure, mineralization or deposition. In addition, nutrient losses such as ammonia volatilization are accounted. FarmDyn supports two differently detailed ways to calculate the plant nutrient need. The default approach and an approach in line with the fertilizing planning of the German Fertilization Ordinance. They differ amongst other by the calculation of the plant need, loss factors and accounted sources. In addition, different N fertilizing intensities and corresponding yield levels can be additionally used.</p> <p>The fertilization is mainly reflected in two equations in the file general_cropping_module.gms. Nutrient need, sources and losses are listed in the equation NutBalCropSour and opposed in NutBalCrop_. This allows to clearly specify different elements of the fertilization and facilitates the validation.</p> <p>The nutrient need p_nutNeed and the N fertilizing intensities are defined in the file cropping_nutNeed.gms. In the default fertilization approach, the nutrient need equals the nutrient content of the plants.</p> <pre><code>p_nutNeed(c_ss_t_i(curCrops(crops),soil,till,intens),nut,t)\n         = sum( prods $ p_OCoeffC(crops,soil,till,intens,prods,t), p_OCoeffC(crops,soil,till,intens,prods,t)/p_storageLoss(prods)\n             * (  p_nutContent(crops,prods,\"conv\",nut) $ (not sameas(till,\"org\"))\n                + p_nutContent(crops,prods,\"org\",nut)  $      sameas(till,\"org\") )*10);\n</code></pre> <p>In the approach following the Fertilization Ordinance, the nutrient need is defined by the legislation.</p> <pre><code>p_nutNeed(c_ss_t_i(curCrops(crops),soil,till,\"normal\"),nut,t)\n                 = p_NneedFerPlan(crops,soil,till,\"normal\",nut,t) ;\n</code></pre> <p>When switched on at the graphical user interface, the nutrient need for the different N fertilizing intensities is defined. Here, the calculation using the findings from Heyn and Olfs (2018) is exemplary shown. The underlying data can be found in the crop data file.</p> <p>xxx</p> <p>Beside the nutrient need, the variable v_nutOverNeed is introduced into the equation NutBalCropSour_ to allow manure application over plant need.</p> <pre><code>v_nutBalCropSour(fertSour,crops,plot,till,intens,nut,t,nCur)\n\n       =E=\n\n* --- N and P need of crops which needs to be met.\n\n         [\n            sum(plot_soil(plot,soil),\n\n                       p_nutNeed(crops,soil,till,intens,nut,t)\n\n            ) * v_cropHa(crops,plot,till,intens,t,nCur)\n\n         ] $sameas(fertSour,\"NBcropNeed\")\n\n*  ---  Application over plant need of fertilizer is possible (e.g. if mineralisation\n*        plus atmospheric deposition exceed crop needs, or in case too much nutrients\n*        from manure are available on farm)\n\n         + v_nutOverNeed(crops,plot,till,intens,nut,t,nCur) $sameas(fertSour,\"NBOverNeed\")\n</code></pre> <p>Mineralization and deposition are further N sources of plants. Under the default setting, FarmDyn accounts N mineralization in spring and deposition. Following the fertilizer planning of the Fertilization Ordinance, only mineralization in spring is accounted.</p> <pre><code>+  [ sum( plot_soil(plot,soil),\n                 $$iftheni.fert %Fertilization% == Default\n*                    Default - p_basNut, refelct Nmin in spring and N depostion from atmosphere\n                     sum(soilNutSour,p_basNut(crops,soil,till,soilNutSour,nut,t))\n                 $$else.fert\n*                   Fertilization Ordinance - Nmin in spring\n                    p_NutFromSoil(crops,soil,till,nut,t)\n                 $$endif.fert\n              ) * v_cropHa(crops,plot,till,intens,t,nCur)\n            ] $sameas(fertSour,\"NBbasNut\")\n</code></pre> <p>Chemical fertilizer application is summarized in the following part of the equation. In the case of the default setting, also losses from fertilizer application are included (not shown here).</p> <pre><code>+ [ sum ((curInputs(syntFertilizer),m),\n                 v_syntDist(crops,plot,till,intens,syntFertilizer,t,nCur,m) * p_nutInSynt(syntFertilizer,nut))\n           ] $ sameas(fertSour,\"NBminFert\")\n</code></pre> <p>Manure spreading and excretion on pasture (the latter not shown here) are other sources for N and P2O5. As illustrated exemplary for manure spreading, the amount of applied nutrients results from the volume of manure applied and the nutrient content.</p> <pre><code>+  [ sum ( (manApplicType_manType(ManApplicType,curManType),m)\n                      $ (v_manDist.up(crops,plot,till,intens,manApplicType,curManType,t,nCur,m) ne 0),\n                         v_manDist(crops,plot,till,intens,ManApplicType,curManType,t,nCur,m)\n\n                   * sum( (manChain_applic(curManChain,ManApplicType),nut2_nut(nut2,nut)),\n                           p_nut2inMan(nut2,curManType,curManChain))\n                )\n              ] $sameas(fertSour,\"NBmanure\")\n</code></pre> <p>N losses following manure application are calculated, using different emission factors for the two calculation schemes.</p> <pre><code>+ [  sum ( (manApplicType_manType(ManApplicType,curManType),m)\n                    $ (v_manDist.up(crops,plot,till,intens,manApplicType,curManType,t,nCur,m) ne 0),\n                       v_manDist(crops,plot,till,intens,ManApplicType,curManType,t,nCur,m)\n\n                   $$iftheni.fert %Fertilization% == FertilizationOrdinance\n\n*                        Fertilization Ordinance - standard loss factors provided by ordinance (N and P)\n                          * sum( (manChain_applic(curManChain,ManApplicType),nut2_nut(nut2,nut)),\n                              p_nut2inMan(nut2,curManType,curManChain)\n                                 * (1 - p_nutEffFOPlan(curManType,crops,m,nut)))\n\n                  $$else.fert\n*                        Default - different N losses from env accounting module\n\n                         * sum( (manChain_type(curManChain,curManType),nut2N),\n                                      p_nut2inMan(nut2N,curManType,curManChain)\n                                         * (     p_EFapplMan(curCrops,curManType,manApplicType,nut2N,m) $ sameas(nut2N,\"NTAN\")\n                                              +  p_EFApplMin(\"N2O\")\n                                              +  p_EFApplMin(\"NOx\")\n                                              +  p_EFApplMin(\"N2\")   )\n                              ) $ sameas(nut,\"N\")\n                  $$endif.fert\n                )\n              ] $sameas(fertSour,\"NBmanureloss\")\n</code></pre> <p>Finally, N fixation from legumes and N supply from vegetable residues are included.</p> <pre><code>$$iftheni.fert %Fertilization% ==  Default\n\n     + [\n           v_cropHa(crops,plot,till,intens,t,nCur) *   (  p_NfromLegumes(Crops,\"org\")  $ sameas(till,\"org\")\n                                                        + p_NfromLegumes(Crops,\"conv\") $ (not sameas(till,\"org\"))\n                                                       ) $ (sameas (nut,\"N\") )\n        ]  $sameas(fertSour,\"NBlegumes\")\n\n       $$iftheni.data \"%database%\" == \"KTBL_database\"\n    + [\n          v_cropHa(crops,plot,till,intens,t,nCur) *   (  p_NfromVegetables(Crops)\n                                                      ) $ (sameas (nut,\"N\") )\n       ]  $sameas(fertSour,\"NBvegetables\")\n       $$endif.data\n    $$endif.fert\n   ;\n</code></pre> <p>The equation NutBalCrop_ opposes the described nutrient need, nutrient sources and losses.</p> <pre><code>NutBalCrop_(c_p_t_i(curCrops(crops),plot,till,intens),nut,t_n(tCur(t),nCur))\n         $ ( (v_cropHa.up(crops,plot,till,intens,t,nCur) ne 0)  $ fertCrops(Crops) ) ..\n\n* --- Equation which oppons nutrient need, sources and losses based on the\n*     definition in NutBalCropSour_\n\n* --- Nutrient need\n          v_nutBalCropSour(\"NBcropNeed\",crops,plot,till,intens,nut,t,nCur)\n\n* --- Nutrient application over plant need with manure\n         + v_nutBalCropSour(\"NBOverNeed\",crops,plot,till,intens,nut,t,nCur)\n\n            =E=\n\n* --- Nutrient delivered from soil and air\n          v_nutBalCropSour(\"NBbasNut\",crops,plot,till,intens,nut,t,nCur)\n\n* --- Nutrient from chemical fertilizer\n        + v_nutBalCropSour(\"NBminFert\",crops,plot,till,intens,nut,t,nCur)\n\n* --- Losses from chemical fertilizer application\n        - v_nutBalCropSour(\"NBminFertLoss\",crops,plot,till,intens,nut,t,nCur)\n\n        $$iftheni.man \"%manure%\" == \"true\"\n* --- Nutrients from manure application\n        + v_nutBalCropSour(\"NBmanure\",crops,plot,till,intens,nut,t,nCur)\n\n* --- Losses from manure application\n        - v_nutBalCropSour(\"NBmanureloss\",crops,plot,till,intens,nut,t,nCur)\n        $$endif.man\n\n        $$iftheni.dh \"%cattle%\" == \"true\"\n* --- Nutrients on pasture from grazing\n        + v_nutBalCropSour(\"NBpasture\",crops,plot,till,intens,nut,t,nCur)\n\n* --- Losses on pasture from grazing\n        - v_nutBalCropSour(\"NBpastureLoss\",crops,plot,till,intens,nut,t,nCur)\n\n        $$endif.dh\n* ---- Nutrients from legumes\n        + v_nutBalCropSour(\"NBlegumes\",crops,plot,till,intens,nut,t,nCur)\n\n* ---- Nutrients from vegetables\n        $$iftheni.data \"%database%\" == \"KTBL_database\"\n        + v_nutBalCropSour(\"NBvegetables\",crops,plot,till,intens,nut,t,nCur)\n        $$endif.data\n;\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/CropProduction/plant_nutrition/#references","title":"References","text":"<p>Heyn, J. and Olfs, H.-W. (2018):  Wirkungen reduzierter N-D\u00fcngung auf Produktivit\u00e4t, Bodenfruchtbarkeit und N-Austragsgef\u00e4hrdung \u2013 Beurteilung anhand mehrj\u00e4hriger Feldversuche. VDLUFA. Schriftenreihe 72.</p> <ol> <li> <p>QIP solvers do not allow for equality conditions which are by    definition non-convex\u00a0\u21a9</p> </li> </ol>"},{"location":"FarmDynDocumentation/ModelDescription/EconomicsAndManagement/household_income_and_cash_flow/","title":"Household Income and Cashflow","text":"<p>Abstract The household's income is defined as the farm's withdrawals from the cash flow plus earnings from off-farm work and leasing land. The net cashflow is determined by offsetting financial, investment and operational cashflows. For this purpose, sales revenues, production levels and variables costs are calculated. </p>"},{"location":"FarmDynDocumentation/ModelDescription/EconomicsAndManagement/household_income_and_cash_flow/#household-income","title":"Household Income","text":"<p>The household income results from money withdraw v_withDraw from the farm cashflow v_netCashFlow and the off-farm income v_offFarmwages from all household members. Based on the settings from the user, the household income additionally accounts for rent from leased lands and taxation.</p> <pre><code>hhsldIncome_(t_n(tFull(t),nCur)) ..\n\n       v_hhsldIncome(t,nCur) =E= v_withDraw(t,nCur) + v_offFarmWages(t,nCur)\n*\n*        --- income from renting out land (assume that land is owned by farming family, and not by agricultural enterprise\n*\n$ifi %landLease% == true + sum( plot $ p_plotsize(plot), v_rentOutPlot(plot,t,nCur) * p_plotSize(plot) * p_landRent(plot,t))\n*\n$ifi not \"%incomeTax%\"==\"None\"- v_incomeTaxTot(t,nCur)\n        ;\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/EconomicsAndManagement/household_income_and_cash_flow/#net-cashflow-in-current-period","title":"Net Cashflow in Current Period","text":"<p>The net cash flow v_netCashFlow itself comprises all cash flow sources from on-farm activities. First, depending on the setting of the time dynamics in FarmDyn, it accounts either for financial cash flows v_finCashFlow (rec-dynamics) or the withdraw of the household v_withdraw (comparative-static). Second, the investment cashflow v_InvCashFlow aggregates all yearly investment costs for investment options farmers face in FarmDyn, this includes different stable sizes for different herds, a wide range of machinery, various sizes of manure silos and other buildings such as potato storages or bunker silos. The operational cashflow v_opCashFlow in the equation captures all sales revenues, premiums, interest gains, and variable costs. In the following, the calculation of sales and variables costs is presented in more detail to facilitate a better understanding.</p> <pre><code>netCashFlow_(t_n(tFull(t),nCur))  ..\n*\n       v_netCashFlow(t,nCur) =e=\n*\n*       --- financial cash flows (including household withdrawals) in rec-dyn version\n*\n$ifi not \"%dynamics%\"==\"comparative-static\"            + v_finCashFlow(t,nCur)\n*\n*       --- household withdrawals as sole financial cash flow in comp-stat version\n*\n$ifi     \"%dynamics%\"==\"comparative-static\"            - v_withDraw(t,nCur)\n*\n*       --- investment cash flows\n*\n        + v_InvCashFlow(t,nCur) $ sum(branches,v_hasBranch.up(branches,t,nCur))\n*\n*       --- operational cash flow\n*\n        +  v_opCashFlow(t,nCur)\n     ;\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/EconomicsAndManagement/household_income_and_cash_flow/#sales-revenues-and-production-levels","title":"Sales Revenues and Production Levels","text":"<p>Sales revenues v_salRev are part of the operational cashflow. Three central equations are distinguished. First, salRev_ calculates the total income considering all on-farm income, i.e. the total revenue from sales. Second, the salRevProds_ returns the revenue generated by each product considering its price and the produced quantity. Third, saleQuant_ ensures that quantities from on-farm products which are used otherwise on-farm, such as in feeding practices, are not added to the sold quantity v_saleQuant.</p> <pre><code>*   --- total revenue from sales, by organic and conventional system\n*\n    salRev_(curSys(sys),t_n(tCur,nCur))   ..\n*\n       v_salRev(sys,tCur,nCur)  =e= sum(  (curProds(prodsYearly)) $ (v_saleQuant.up(prodsYearly,sys,tCur,nCur) ne 0),\n                                                v_salRevProds(curProds,sys,tCur,nCur));\n*\n*   --- revenue from sales of animal and crop products, n each state of nature\n*      (SON specific price times SON specific production quantities)\n*\n    salRevProds_(curProds(prodsYearly),curSys(sys),tCur(t),nCur) $ (t_n(t,nCur) $ (v_saleQuant.up(prodsYearly,sys,t,nCur) ne 0))  ..\n*\n       v_salRevProds(curProds,sys,t,nCur)  =e=\n                                  p_price(prodsYearly,sys,t)\n$iftheni.sp \"%stochProg%\"==\"true\"\n      * ( 1 + (p_randVar(\"priceOutputs\",nCur)-1) $ randProbs(prodsYearly) )\n$endif.sp\n                                   *  v_saleQuant(prodsYearly,sys,t,nCur);\n\n*\n*   --- balances for products, define sold quantities\n*\n    saleQuant_(curProds(prodsYearly),t_n(tCur(t),nCur)) $ (sum(curSys,p_price%l%(prodsYearly,curSys,t)) or sameas(curProds,\"milkfed\"))  ..\n\n       sum(curSys $ p_price%l%(prodsYearly,curSys,t),v_saleQuant(prodsYearly,curSys,t,nCur))\n*\n*      ---- consider on-farm use for feed (competes with selling of produced quantities)\n*\n       $$iftheni.cattle \"%cattle%\"==\"true\"\n          + sum( sameas(prodsYearly,curFeeds(feedsY)), v_feedUseProds(feedsY,t,nCur))\n       $$endif.cattle\n*\n       $$iftheni \"%biogas%\"==\"true\"\n          +  sum( sameas(prodsYearly,crM),\n                     sum( (curBhkw(bhkw),curEeg(eeg),m),\n                             v_feedBiogas(bhkw,eeg,crM,t,nCur,m) ) )\n      $$endif\n*\n      $$iftheni.pig \"%pigherd%\"==\"true\"\n          +  sum(sameas(prodsYearly,feedsPig), v_feedOwnPig(feedspig,t,nCur))\n      $$endif.pig\n\n         =L= v_prods(prodsYearly,t,nCur);\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/EconomicsAndManagement/household_income_and_cash_flow/#annual-production-output","title":"Annual Production Output","text":"<p>The v_prods used in the saleQuant_ equation collect all on-farm products. This comprises both crop (arable and grassland) and animal production (milk, meat, manure). The production of electricity and heat from biogas is calculated separately in the biogas module.</p> <pre><code>prods_(prodsYearly,t_n(tCur(t),nCur)) $ sum(sameas(prodsYearly,curProds),1) ..\n\n       v_prods(prodsYearly,t,nCur)\n\n         =e=\n*\n*        --- crop main output\n*\n         sum( c_p_t_i(curCrops(crops),plot,till,intens), v_cropHa(crops,plot,till,intens,t,nCur)\n             * sum(plot_soil(plot,soil) $ p_OCoeffC%l%(crops,soil,till,intens,prodsYearly,t),p_OCoeffC(crops,soil,till,intens,prodsYearly,t)))\n\n*        --- crop residues such as straw\n*\n      +  sum( c_p_t_i(crops,plot,till,intens) $ cropsResidueRemo(crops),\n               v_residuesRemoval(crops,plot,till,intens,t,nCur)\n                 *  sum(plot_soil(plot,soil), p_OCoeffResidues(crops,soil,till,intens,prodsyearly,t)) )\n\n      $$iftheni.straw %strawManure% == true\n*\n*        --- minus crop residues such as straw used for own Consumption\n*\n         - v_residuesOwnConsum(prodsYearly,t,nCur) $ (sum(sameas (prodsYearly,prodsResidues),1))\n      $$endif.straw\n*\n      $$iftheni.herd %herd% == true\n*\n*        --- animal output\n*\n             +  sum( (possHerds,breeds) $ (sum((feedRegime,m),actherds(possHerds,breeds,feedRegime,t,m))\n                                        $ p_OCoeff(possHerds,prodsYearly,breeds,t)),\n*\n*             -- herd size in different month times output yearly coefficient (milk, young animals ..)\n*\n                           ( sum(actHerds(possHerds,Breeds,feedRegime,t,m),v_herdSize(possHerds,breeds,feedRegime,t,nCur,m))\n                                       * ( [1/min(12,p_prodLength(possHerds,breeds))]\n                                               $ ( ((p_prodLength(possHerds,breeds) gt 1)\n              $$ifi \"%farmBranchSows%\" == \"on\" and  (p_prodLength(possHerds,breeds) gt 2)\n                                                   )\n          $$ifi \"%farmBranchFattners%\" == \"on\" or ((p_prodLength(possHerds,breeds) le 1) $ (sameas(possHerds,\"fattners\") and sameas(prodsYearly,\"pigMeat\")))\n                                        ))\n*\n*              --- cases where herd start counts (that is usucally the case if the production length is one month)\n*\n                              + sum(m $ sum(feedRegime,actherds(possHerds,breeds,feedRegime,t,m)),  v_herdStart(possHerds,breeds,t,nCur,m))\n                                               $ ( (p_prodLength(possHerds,breeds) le 1)\n\n        $$ifi \"%farmBranchFattners%\" == \"on\" and (not (sameas(possHerds,\"fattners\") and sameas(prodsYearly,\"pigMeat\")))\n            $$ifi \"%farmBranchSows%\" == \"on\" or ((p_prodLength(possHerds,breeds) le 2) $ sameas(prodsYearly,\"pigletsSold\"))\n                                            )\n                           )\n\n                 * p_OCoeff(possHerds,prodsYearly,breeds,t)\n           )\n      $$endif.herd\n      ;\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/EconomicsAndManagement/household_income_and_cash_flow/#variable-costs-from-purchasing-levels-machinery-activies-etc","title":"Variable Costs from Purchasing Levels, Machinery, Activies, etc.","text":"<p>The total variable costs summarise variable costs from all production activities on-farm. This includes the variable costs for inputs used in crop and animal production, machinery (e.g. maintenance costs), manure handling, stables (e.g. repair and insurance) and buildings (e.g. repair, insurance and interest). Furhter, it covers variable costs for animal and crop production v_varCostActs not covered by other variable costs, such as machinery operation like taking soil samples, etc..</p> <pre><code>*   --- Total variable costs\n*\n    varCost_(tCur(t),nCur) $ t_n(t,nCur)  ..\n\n       v_varCost(t,nCur) =e=\n*\n*        --- variable costs of buying inputs\n*\n             sum(curSys,v_buyCostTot(curSys,tcur,nCur))\n*\n*        --- variable costs of crop and animal production (as far as not covered by constraints)\n*            and variable machinery costs (KTBL regression)\n*\n             + v_varCostActs(t,nCur)\n\n*        --- variable costs for machinery (per ha, hour or year)\n\n             + v_varCostMach(t,nCur)\n\n$iftheni.man %manure% == true\n*\n*        --- variable cost for manure application / coverage / storage / export  / import\n*\n             + v_varCostMan(t,nCur)\n$endif.man\n\n$iftheni.h %herd% == true\n*\n*        --- repair and insurance costs for stables, calculated as an average from page 516, KTBL 16/17,\n*            fraction of investment cost depending on lifetime\n*\n             + sum( (stables,hor) $ v_stableInv.up(stables,hor,t,nCur),\n                   v_stableUsed(stables,t,nCur) * p_priceStables(stables,hor,t-1)\n                          * (  0.01 $ sameas(hor,\"long\")\n                             + 0.02 $ sameas(hor,\"middle\")\n                             + 0.03 $ sameas(hor,\"short\") ) )\n$endif.h\n*\n*        --- variable costs for buildings\n*\n             + sum( curBuildings(buildings)\n                    $ (     sum(t_n(t1,nCur1) $ isNodeBefore(nCur,nCur1), (v_buyBuildings.up(buildings,t1,nCur1) ne 0))\n                        or  sum(tOld, p_iniBuildings(buildings,tOld))),\n\n                    v_buildingsInv(buildings,t,nCur) * p_varCostBuild(buildings,t) )\n\n$iftheni.bg %biogas%==true\n*\n*       --- variable cost related to biogas production\n*\n             + sum( curBhkw(bhkw) ,  v_varCostBiogas(bhkw,t,nCur))\n$endif.bg\n;\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/EconomicsAndManagement/investment_and_financing/","title":"Investments and Financing","text":"<p>Abstract Investment decisions in machinery, stables and structures (silos, biogas plants, storage) are depicted as binary variables with a yearly resolution. Physical depreciation can be based on lifetime or use. Machinery use can alternatively be re-invested continuously rendering the investment costs variable based on a Euro per hectare threshold. Investments can be financed out of (accumulated) cash flow or by credits of different length and related interest rates. For stables and biogas plants, maintenance investments are reflected as well.</p>"},{"location":"FarmDynDocumentation/ModelDescription/EconomicsAndManagement/investment_and_financing/#general-investments-in-comparative-static-mode","title":"General Investments in Comparative-Static Mode","text":"<p>This section describes the investment procedures for all types of investment in FarmDyn. Calculation of investments and related fixed costs differentiate between the chosen model dynamic. The types of investment include, inter alia, stables, buildings, machinery, and manure silos. In a comparative-static mode, the investment costs are given as the yearly depreciation costs (exl. interest). For buildings in general, the yearly depreciation costs are realised by dividing the original price (e.g. p_priceStables, p_priceMach, p_priceSilo) by the lifetime. In the case of machinery, the calculated depreciation differs from machinery to machinery and is either determined by hectare, lifetime, or other metrics such as cubic metre.  </p> <p>The equation costInv_ captures all investment/ buying decision on-farm given by the variables v_buyMach/Stables/Silos/etc and their related costs.</p> <pre><code>*   --- costs of different types of investment (different stables, buildings, machinery, manure silos)v_\n*\n    costInv_(inv,t_n(tCur(t),nCur)) $ curInv(inv) ..\n\n      v_costInv(inv,t,nCur) =E=\n\n         $$ifthen.stables \"%herd%\"==\"true\"\n*\n*        --- new stables bought\n*\n            sum( (stables,hor) $ ((v_buyStables.up(stables,hor,t,nCur) ne 0) and (v_hasFarm.up(t,nCur) ne 0) and sameas(inv,stables)),\n               v_buyStablesF(stables,hor,t,nCur)*p_priceStables(stables,hor,t)*p_vPriceInv(\"stables\"))\n\n          + sum( (stableTypes,hor) $ ((v_minInvStables.up(stableTypes,hor,t,nCur) ne 0) and (v_hasFarm.up(t,nCur) ne 0) and sameas(inv,stableTypes)),\n                v_minInvStables(stableTypes,hor,t,nCur) * p_minInvStableCost(stableTypes,hor,t))\n\n         $$endif.stables\n*\n*      --- buildings and structures\n*\n      + sum(curBuildings(buildings) $ sameas(inv,buildings), p_priceBuild(buildings,t) * p_vPriceInv(\"buildings\") *\n                                         v_buyBuildingsF(buildings,t,nCur))\n*\n*       --- new machinery bought (integer and continous depreciation solution)\n*\n    +   sum(curMachines(machType) $ sameas(machType,inv),\n                   (v_buyMach(machType,t,nCur)+v_buyMachFlex(machType,t,nCur))*p_priceMach(machType,t)*p_vPriceInv(\"machines\"))\n*\n*        --- new manure silos bought\n*\n       $$ifthen.silos defined v_buySilos.up\n          + sum( (curManChain(manChain),silos) $ ((v_hasFarm.up(t,nCur) ne 0) $ sameas(silos,inv)),\n                 v_buySilosF(manChain,silos,t,nCur)*p_priceSilo(silos,t)*p_vPriceInv(\"silos\"))\n       $$endif.silos\n;\n</code></pre> <p>As can be seen in the equation costInv_ all buildings have a buying decision name ending with an F as v_buyStablesF. F refers to being a fractional number and not a binary variable one would assume in a buying decision. The fractional character of the variables stems from the fact that FarmDyn interpolates between two different size classes of a building on a concave curve with multiple size classes to return a fitting size class for a given desired size. An example: A farmer wants to build a stable with 80 stable places. However, literature only provides information on costs, labour needs, etc. for stables with 50 an 100 places. To provide the farmer with the option to have more than 50 but less than 100 stable places, FarmDyn interpolates between the two size classes on a concave set determined by multiple size classes which are taken from literature. This is shown in the following equation:</p> <pre><code>*   --- only two types of stables can be bought for each type of herd,\n*       in between two points of the concave curve\n*\n    stableConvexComb_(stableTypes,hor,t_n(tFull,nCur)) $ sum(stableTypes_to_stables(stableTypes,stables)\n                                                          $ (v_buyStables.up(stables,hor,tFull,nCur) ne 0),1) ..\n\n         sum(stableTypes_to_stables(stableTypes,stables) $ (v_buyStables.up(stables,hor,tFull,nCur) ne 0),\n                                                                  v_buyStablesF(stables,hor,tFull,nCur)) =E= 1;\n</code></pre> <p>These fractional stables are further restricted by the then binary buying decision of stables v_buyStables, as seen in the following equation.</p> <pre><code>*   --- restrict choice for convex combination to the two points implicitly defined above\n*\n    stableBin_(stables,hor,t_n(tFull,nCur)) $ ((v_buyStablesF.up(stables,hor,tFull,nCur) ne 0) $ (v_hasFarm.up(tFull,nCur) ne 0)) ..\n\n         v_buyStablesF(stables,hor,tFull,nCur) =L= v_buyStables(stables,hor,tFull,nCur);\n</code></pre> <p>Eventually, all investment costs from on-farm buying decision combined with land acquisition and biogas is summed up in the equation sumInv_.</p> <pre><code>sumInv_(t_n(tFull(t),nCur)) ..\n*\n       v_sumInv(t,nCur) =e=\n*\n*        --- new land bought\n*\n$ifi %landBuy% == true  sum( plot, v_buyPlot(plot,t,nCur)*p_buyPlotSize*p_pland(plot,t)) $ tCur(t)\n*\n*        --- stables, silos, buildings and machines\n*\n       + sum(inv $ curInv(inv), v_costinv(inv,t,nCur)) $ tCur(t)\n*\n*        --- new biogas plant bought\n*\n$iftheni %biogas%==true\n\n                  + sum((curBhkw(bhkw), curEeg(eeg)),\n                        v_buyBioGasPlant(bhkw,eeg,\"ih20\",t,nCur) $tCur(t)\n                                                * p_priceBioGasPlant(bhkw,\"ih20\"))\n\n                  + sum((curBhkw(bhkw), ih),\n                        v_buyBioGasPlantParts(bhkw,ih,t,nCur)\n                                                * ( p_priceBioGasPlant(bhkw,ih) $ (not(ih20(ih)))\n*                                                 + p_priceFlexBioGasPlant(bhkw,eeg,ih)$eegDM(eeg) )\n                                                  ))\n$endif\n       ;\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/EconomicsAndManagement/investment_and_financing/#investments-in-fully-dynamic-mode","title":"Investments in Fully Dynamic Mode","text":"<p>The investments in fully dynamic differ from those in comparative static, especially in their financing. Whereas the comparative-static mode assumes yearly depreciation costs, in the fully dynamic mode the model also accounts for available liquidity and equity as well as for the need of credits to make investments.</p> <p>To facilitate the understanding of the structure in the financing of investments in fully dynamic, we start by looking at the equation Liquid_. The equation returns the given liquidity v_liquid in a certain year given the liquidity of last year plus the net cashflow in a given year v_netCashFlow.</p> <pre><code>Liquid_(tFull(t),nCur) $ t_n(t,nCur) ..\n*\n       v_liquid(t,nCur) =e=\n*\n*      --- last years liquidity\n*\n          + sum(t_n(t-1,nCur1) $ anc(nCur,nCur1), v_liquid(t-1,nCur1))\n*\n*      --- total cash flow of the agricultural enterprise\n*\n          + v_netCashFlow(t,nCur)\n        ;\n</code></pre> <p>The available funds to make an investment are then given by the already presented equation netCashFlow_ (section Household income and cash flow). To cover the expenses of investment cash flows, v_InvCashFlow, there has to be some kind of financing for this part which is not covered by the available liquidity from v_liquid. This is given by the variable v_finCashFlow.</p> <pre><code>netCashFlow_(t_n(tFull(t),nCur))  ..\n*\n       v_netCashFlow(t,nCur) =e=\n*\n*       --- financial cash flows (including household withdrawals) in rec-dyn version\n*\n$ifi not \"%dynamics%\"==\"comparative-static\"            + v_finCashFlow(t,nCur)\n*\n*       --- household withdrawals as sole financial cash flow in comp-stat version\n*\n$ifi     \"%dynamics%\"==\"comparative-static\"            - v_withDraw(t,nCur)\n*\n*       --- investment cash flows\n*\n        + v_InvCashFlow(t,nCur) $ sum(branches,v_hasBranch.up(branches,t,nCur))\n*\n*       --- operational cash flow\n*\n        +  v_opCashFlow(t,nCur)\n     ;\n</code></pre> <p>The variable v_finCashFlow is then the part which covers the credit options of a farmer. It captures the re-payment on past credits including repayment itself and the interest and new credits taken up in a certain year to pay for new investments. In contrast to the comparative-static part of FarmDyn, the withdraw from household members are included in the financial cash flow. A further detailed description on differences between credit options follows next.</p> <pre><code>*   --- financial cash flow in current period\n*\n    finCashFlow_(t_n(tFull(t),nCur)) ..\n\n       v_finCashFlow(t,nCur) =E=\n*\n*       --- re-payments on past credits\n*\n         - sum((creditType,t1,nCur1) $ ( (    ((p_year(t1)    + p_payBackTime(creditType))  ge p_year(t))\n                                          $   ( p_year(t1)+1                                le p_year(t)))\n                                           $ tFull(t1)  $ isNodeBefore(nCur,nCur1) $ t_n(t1,nCur1)  ),\n                                                v_credits(creditType,t1,nCur1) * 1/p_payBackTime(creditType))\n*\n*       --- new credits\n*\n         + sum(creditType, v_credits(creditType,t,nCur)) $ (p_year(t) lt p_year(\"%lastYear%\"))\n*\n*      -- profit withdrawals by households\n*\n          - v_withDraw(t,nCur)\n     ;\n</code></pre> <p>The model differentiates credits by repayment period, p_payBackTime, and interest rate. Credits are paid back in equal instalments over the repayment period, hence, annuities decrease over time. The amount of outstanding credits is defined by the following equation:</p> <pre><code>credSum_(creditType,tFull(t),nCur) $ (t_n(t,nCur) $ (v_sumCredits.up(creditType,t,nCur) ne 0))    ..\n*\n       v_sumCredits(creditType,t,nCur) =e=\n*\n            sum( t_n(t1,nCur1) $ (  (((p_year(t1)  + p_payBackTime(creditType))  ge p_year(t))\n                            $     ( p_year(t1)                                  le p_year(t)))\n                            $ tCur(t1) $ isNodeBefore(nCur,nCur1)),\n                                    v_credits(creditType,t1,nCur1)\n                                    * (1-1/p_payBackTime(creditType) * (p_year(t)-p_year(t1))));\n</code></pre> <p>In fully dynamic mode, the model also accounts for revenues from liquidation of investments. However, these are only assumed to take place in the last year of the simulation:</p> <pre><code>liquidation_(nCur) $ t_n(\"%lastYearCalc%\",nCur) ..\n\n       v_liquidation(nCur) =e=\n*\n*           --- assume that past credits\n*               are paid back fully in the last year (to prevent over-investments)\n*\n            - sum(creditType, v_sumCredits(creditType,\"%lastYearCalc%\",nCur))\n*\n*            --- sell machinery (assumption for resell avalue: non-depreciated stock\n*                according to time or load, minus 33%)\n*\n             + [  sum( curMachines(machType) $ sum(machLifeUnit,p_lifeTimeM(machType,machLifeUnit)),\n                      sum(machLifeUnit $ p_lifeTimeM(machType,machLifeUnit),\n                         v_machInv(machType,machLifeUnit,\"%lastYearCalc%\",nCur)\n                                                /p_lifeTimeM(machType,machLifeUnit)\n                            * p_priceMach(machType,\"%lastYearCalc%\") * 2/3)\n                / sum(machLifeUnit $ p_lifeTimeM(machType,machLifeUnit), 1)) ] $ card(curMachines) $ p_liquid\n*\n*            --- sell land (transaction costs set to 4 times the yearly land rent)\n*                (only in case land can be bought or sold - eases the interpretation of the average objective value in each year)\n*\n$iftheni.lb %landBuy% == true\n               + sum( plot, v_totPlotLand(plot,\"%lastYear%\",nCur)\n                            * ( p_pland(plot,\"%lastYear%\") - 4 * p_landRent(plot,\"%lastYear%\")))  $ p_liquid\n$endif.lb\n$iftheni.dh %cowherd%==true\n*\n*              -- cows go for slaughter\n*\n             + sum( actHerds(cows,curBreeds,feedRegime,\"%lastYear%\",\"dec\"),\n                       v_herdSize(cows,curBreeds,feedRegime,\"%lastYear%\",nCur,\"dec\")\n                          * p_OCoeff(cows,\"oldCow\",curBreeds,\"%lastYear%\") * p_price(\"oldCow\",\"conv\",\"%lastYearCalc%\")) $ p_liquid\n*\n*              -- heifers at 30% of value of a young cow\n*\n             + sum( actHerds(heifs,curBreeds,feedRegime,\"%lastYear%\",\"dec\"),\n                       v_herdSize(heifs,curBreeds,feedRegime,\"%lastYear%\",nCur,\"dec\")\n                                * p_price(\"youngCow\",\"conv\",\"%lastYearCalc%\") * 0.3 ) $ p_liquid\n*\n*              -- raising cavles at 10% of value of a young cow\n*\n             + sum( actHerds(\"fCalvsRais\",curBreeds,feedRegime,\"%lastYear%\",\"dec\"),\n                       v_herdSize(\"fCalvsRais\",curBreeds,feedRegime,\"%lastYear%\",nCur,\"dec\")\n                                * p_price(\"youngCow\",\"conv\",\"%lastYearCalc%\") * 0.1 ) $ p_liquid\n$endif.dh\n       ;\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/EconomicsAndManagement/labour/","title":"Labour","text":"<p>Abstract The labour module optimises work use on- and off-farm with a monthly resolution, depicting detailed labour needs for different farm operations, herds and stables, management requirements for each farm branch, and the farm as a whole. Off-farm work distinguishes between half- and full-time work (binaries) and working flexibly for a low wage rate.</p>"},{"location":"FarmDynDocumentation/ModelDescription/EconomicsAndManagement/labour/#general-concept","title":"General Concept","text":"<p>The template differentiates between three types of labour on farm:</p> <ol> <li> <p>General management and further activities for the whole farm, p_labManag(\"farm\",\"const\") - needed as long as the farm is not abandoned;     v_hasFarm = 1 - binary variable and not depending on the level of individual farm activities.</p> </li> <li> <p>Management activities and further activities depending on the size     Of farm branches such as arable cropping, dairying, beef fattening, pig fattening, and piglet production.     The necessary working hours are broken down into a base need, const which is linked to having the respective farm branch, v_hasBranch (integer) and a linear term depending on its size, slope.</p> </li> <li> <p>Labour needs for certain farm operations (aggregated to     v_labTot).</p> </li> </ol> <p>The sum of total labour needs cannot exceed total yearly available labour from on-farm sources plus hired workers (see following equation). It is further assumed that household members which work off-farm require more leisure time than members who work on-farm. As discussed below, there are further restrictions with regard to monthly labour and available field working days.</p> <pre><code>TimeTot_(t_n(tCur(t),nCur)) ..\n*\n*       --- total on- and off-farm labour\n*\n        v_labTot(t,nCur)\n\n         =L=\n*\n*                         ---- max work time if all family members work on the farm\n*\n                          p_yearlyLabH(t)\n*\n*                         ---- Difference between maximal willingness to work on farm and what is required for off-farm work\n*                              Assumes that family members working off-farm want more leisure\n*\n                          - v_labOnFarmLost(t,nCur) $ sum(workOpps(workType), (v_labOff.up(t,nCur,workType) ne 0))\n*\n*                         ---- labour hours of hired farm workers\n*\n                          $$ifi \"%allowHiring%\"==\"true\" + v_hireWorkers(tcur,nCur) * %workHoursHired%\n        ;\n</code></pre> <p>The maximal yearly working hours, p_yearlyLabH are defined in the statement shown below. The maximal labour hours for the first, second and further labour units can be entered via the graphical user interface.  </p> <pre><code>p_yearlyLabH(t)   =  %AkhFirst%   * min(1,%Aks%)\n                      + %AkhSecond%  * min(1,%Aks%-1) $ (%Aks% &gt; 1)\n                      + %AkhFurther% * (%Aks%-2)      $ (%Aks% &gt; 2);\n</code></pre> <p>The maximum work hours per month is defined in the following statement represented by the parameter p_monthlyLabH:</p> <pre><code>p_monthlyLabH(t,m) =  p_yearlyLabH(t) / 365 * p_daysPerMonth(m) * (1+%flexHoursFamily%/100);\n</code></pre> <p>The template considers the sum of labour needs v_labTotM for each month m. On-farm labour needs are related to certain farm activities on field and in stable. Off-farm labour hours distinguish between contracts for full-time or part-time jobs, and off-farm work on an hourly basis. The variables which enter in the equation labTotM_ are explained in the next sub-section starting with the fixed labour requirements related to the farm branches.</p> <pre><code>labTotM_(t_n(tCur(t),nCur),m)  ..\n*\n*        --- sum of work in hours in current month\n*\n       v_LabTotM(t,nCur,m) =e=\n*\n*      --- labour use for crops\n*\n        +  v_labCropSM(t,nCur,m)\n*\n*      --- labour use for herds\n*\n$ifi %herd%==true  + v_labHerdM(t,nCur,m)\n*\n*      --- Management hours (for total farm and the different brenaches)\n*\n       + v_labManag(t,nCur)/card(m)\n*\n*        --- off farm labour - per month: p_workTime are weekly hours,\n*            p_commTime is the commuting time in weekly hours, assumption of\n*            44 weeks work in each year (binary variables)\n*\n       + v_labOffFixed(t,nCur)/card(m)\n*\n*        --- small scale work on a hourly basis (continous)\n*\n       + v_labOffHourly(t,nCur)/card(m)\n*\n*        --- labour use for biogas plant\n*\n$ifi %biogas%== true + sum((curBhkw(bhkw)), v_labBioGas(bhkw,t,nCur,m))\n       ;\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/EconomicsAndManagement/labour/#labour-need-for-the-farm-branches-and-general-management","title":"Labour Need for the Farm Branches and General Management","text":"<p>FarmDyn accounts for labour needs farm branch specific management and general management. This includes organization of purchasing and selling activities, required documentation for administrative bodies etc. The following equation labManag_ shows the calculation of the total labour management on-farm. It accounts for the general management by multiplying the binary variable v_hasFarm and a predefined parameter, irrespective of the size of the farm. In addition, management related to one of the seven farm branches in FarmDyn (arable cropping, dairy, beef fattening, mother cow, fatteners, sows, and biogas) is considered to be linearly dependent on the size of that specific branch v_branchSize, e.g. in the case of dairy cows on the number of cows on farm. The variables v_hasFarm and v_hasBranch are determined by the activities mapped to the branch.</p> <pre><code>labManag_(t_n(tCur(t),nCur)) ..\n\n       v_labManag(t,nCur) =e=\n*\n*       -- hours independent from number of branches or farm size\n*\n        + v_hasFarm(t,nCur) * p_labManag(\"Farm\",\"const\")\n*\n*       --- hours required for branches: block load plus\n*           hours increasing in branch size\n*\n        + sum(branches $ sum(branches_to_acts(branches,acts), 1),\n                v_hasBranch(branches,t,nCur)  * p_labManag(branches,\"const\")\n             +  v_branchSize(branches,t,nCur) * p_labManag(branches,\"slope\"));\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/EconomicsAndManagement/labour/#labour-need-for-herd-cropping-operations-and-off-farm-work","title":"Labour Need for Herd, Cropping, Operations and Off-Farm Work","text":""},{"location":"FarmDynDocumentation/ModelDescription/EconomicsAndManagement/labour/#herd-activities-and-cropping","title":"Herd Activities and Cropping","text":"<p>The labour need for animals, v_herdLabM, is defined by an animal type specific requirement parameter, p_herdLab, in hours per animal and month (see in the next equation, working hours per animal and month) and by the time requirement per stable place, which differs with the stable type. This formulation allows labour saving scale effects related to the stable size:</p> <pre><code>labHerdM_(tCur(t),nCur,m) $ t_n(t,nCur) ..\n       v_labHerdM(t,nCur,m) =e=\n*\n*        --- labour for animal activities, expressed per animal and month\n*            of standing herd\n*\n        sum(actHerds(sumHerds,breeds,feedRegime,t,m),\n              v_herdSize(sumHerds,breeds,feedRegime,t,nCur,m) * p_herdLab(sumHerds,feedRegime,m))\n*\n*        --- labour for animal activities, per starting animal (hours for giving birth and similar)\n*\n      +  sum( (sumHerds,breeds) $ sum(feedRegime, actHerds(sumHerds,breeds,feedRegime,t,m)),\n                v_herdStart(sumHerds,breeds,t,nCur,m)* p_herdLabStart(sumHerds,m))\n*\n*        --- fixed amount of hours for stables (maintenance, cleansing),\n*            captures also labour saving effects of large stables\n*\n     + sum(stables $ (    sum( (t_n(t1,nCur1),hor) $ ((isNodeBefore(nCur,nCur1) or sameas(nCur,nCur1))  and (p_year(t1) le p_year(t))),\n                               (v_buyStables.up(stables,hor,t1,nCur1) ne 0))\n                       or sum( (tOld,hor), p_iniStables(stables,hor,tOld))),\n                                (v_stableUsed(stables,t,nCur)-v_stableNotUsed(stables,t,nCur,m)) * p_stableLab(stables,m) $ (p_stableLab(stables,m) gt eps) );\n</code></pre> <p>A similar equation exists for crops. The parameter p_cropLab defines the labour hours per hectare and month for each crop. In addition, the parameters p_manDistLab and p_syntDistLab multiplied by the N type applied to each crop are added to the overall crop labour demand for the application of synthetic fertiliser and manure:</p> <pre><code>labCropSM_(t_n(tCur(t),nCur),m) ..\n\n       v_labCropSM(t,nCur,m) =e=\n*\n*        --- labour need for crops, expressed per ha of land\n*                                                                                +\n         sum( c_p_t_i(curCrops(crops),plot,till,intens),\n                v_cropHa(crops,plot,till,intens,t,nCur) * p_cropLab(crops,till,intens,m))\n\n\n$iftheni.man %manure% == true\n*\n*        --- labour need for application of manure\n*            (considers all field operations not out-sourced as contract work,\n*             with the exemption of manure and synt fertizer application)\n*\n       + sum((c_p_t_i(curCrops(crops),plot,till,intens),manApplicType_manType(ManApplicType,curManType))\n              $ ((v_cropHa.up(crops,plot,till,intens,t,nCur) ne 0)\n              $ ( v_manDist.up(crops,plot,till,intens,ManApplicType,curManType,t,nCur,m) ne 0)),\n               v_manDist(crops,plot,till,intens,ManApplicType,curManType,t,nCur,m) * p_manDistLab(ManApplicType))\n$endif.man\n*\n*        --- labour need for spreading synthetic fertilizer\n*\n       + sum((c_p_t_i(crops,plot,till,intens),curInputs(syntFertilizer)),\n               v_syntDist(crops,plot,till,intens,syntFertilizer,t,nCur,m) * p_syntDistLab(syntFertilizer));\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/EconomicsAndManagement/labour/#farm-operations","title":"Farm Operations","text":"<p>Field working days define the number of days available in a labour period of half a month, labPeriod, during which soil conditions allow specific types of operations, labReqLevl:</p> <pre><code>fieldWorkHours_(plot,labReqLevl,labPerSum,t_n(tCur(t),nCur)) $ (p_plotSize(plot) $ plot_landType(plot,\"arab\")) ..\n\n       v_fieldWorkHours(plot,labReqLevl,labPerSum,t,nCur)\n\n         =e=\n*\n       sum(labPerSum_ori(labPerSum,LabPeriod),\n*\n*       --- operations requiring a tractor, with the exemption top of\n*           fertilizer dsitribution\n*\n        sum( c_p_t_i(curCrops(crops),plot,till,intens),\n             v_cropHa(crops,plot,till,intens,t,nCur)\n                 * p_fieldWorkHourNeed(crops,till,intens,labPeriod,labReqLevl)\n*\n*       --- distribution of synthetic fertilizer\n\n       +   sum( (curInputs(syntFertilizer),labPeriod_to_month(labPeriod,m)),\n                  v_syntDist(crops,plot,till,intens,syntFertilizer,t,nCur,m)\n                    * p_machNeed(syntFertilizer,till,\"normal\",\"tractor\",\"hour\") ) * sameas(labReqLevl,\"rf3\")\n           )\n        );\n</code></pre> <p>The number of field working hours cannot exceed a limit which is defined by the available field working days, p_fieldWorkingDays. Field working days depend on climate zone, soil type (light, middle, heavy) and distribution of available tractors to the soil type, v_tracDist. It is assumed that farm staff will be willing to work up to 15 hours a day, still with the total work load per month being restricted:</p> <pre><code>tracRestrFieldWorkHours_(plot,labReqLevl,labPerSum,t_n(tCur(t),nCur)) $ (p_plotSize(plot) $ plot_landType(plot,\"arab\")) ..\n\n       v_fieldWorkHours(plot,labReqLevl,labPerSum,t,nCur)\n\n        =L=\n             sum(labPerSum_ori(labPerSum,LabPeriod),\n               sum(plot_soil(plot,soil),\n                      sum(curClimateZone, p_fieldWorkingDays(labReqLevl,labPeriod,curClimateZone,soil)) * 12)\n                              * v_tracDist(plot,labPerSum,t,nCur));\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/EconomicsAndManagement/labour/#off-farm-work","title":"Off-Farm Work","text":"<p>Farm family members can optionally work half- or full-time, v_workoff, or on an hourly basis off-farm, v_workHourly. Half- and full-time work are realised as integer variables. In the normal setting the wage per hour for working half time exceeds the wage of short time hourly work. Moreover, the wage per hour of full time work is higher than of working half time. For half- and full-time work commuting time can be considered:</p> <pre><code>  offFarmHoursPerYearFixed_(t_n(tCur(t),nCur)) $  sum(workOpps(workType), (v_labOff.up(t,nCur,workType) ne 0)) ..\n\n       v_labOffFixed(t,nCur) =e=\n*\n*        --- off farm labour - per month: considers the work time (flexible contracts up to 40 hours a week)\n*                                         plus the commuting time (3 days for contract up to 20 hours, 5 days above)\n\n         + sum( workOpps(workType),\n              v_labOffF(t,nCur,workType) + v_labOff(t,nCur,workType)*p_commTime(workType)*44);\n</code></pre> <p>The set workType lists the possible combinations:</p> <pre><code>p_workTime(workType) =   (p_workT(\"Half\")+p_workT(\"Full\")*floor(workType.pos/2))  $ ( mod(workType.pos,2) eq 1)\n                         +  p_workT(\"Full\")*(workType.pos/2 )                       $ ( mod(workType.pos,2) eq 0);\n</code></pre> <p>It is assumed that decisions about how much to work flexibly on an hourly basis are taken on a yearly basis (i.e. the same number of hours is inputted in each month).</p> <p>The total number of hours worked off-farm is defined as:</p> <pre><code>offFarmWorkTot_(t_n(tCur(t),nCur)) ..\n*\n       v_labOffTot(t,nCur) =e=\n*\n*         --- some hours at a very low wage rate\n*\n          v_labOffHourly(t,nCur)\n*\n*         --- contract between 20 and 40 hours a week, including commuting time\n*\n        + v_labOffFixed(t,nCur) $ sum(workOpps(workType), (v_labOff.up(t,nCur,workType) ne 0));\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/EconomicsAndManagement/objective/","title":"Objective Function","text":"<p>Abstract   FarmDyn's objective function determines the average yearly net present value. It further accounts for different risk and dynamic options. </p> <p>The objective function in FarmDyn accounts for model characteristics such as risk and dynamics. To do so, the objective function is structured in three separate equations. The function objeN_ is the equation directly linked to the farm management program in FarmDyn, whereas the other two equations objeMean_ and OBJE_ are capturing different technical aspects of risk and dynamics. The objeN_ calculates the average yearly net present value (NPV) as the discounted household income v_hhldsIncome plus the value of leisure in money terms v_leisureVal. The equation objeMean_ uses this information to calculate the mean objective based on the probability for each existing node (nCur). This information flows in the uppermost and final objective function OBJE_ which accounts for penalties for negative deviations from the mean NPV (similar to a MOTAD (Minimum of total absolute deviations) approach).</p> <pre><code>*   --- net present value of cash balance in average per year\n*       over the simulation horizon\n*\n*\n    OBJE_           ..\n*\n       v_obje =L=\n                v_objeMean\n*\n*       --- penalty for negative deviation from mean NPV (similar MOTAD) or target MOTAD / ES\n*\n      + [ 0\n\n$ifi %stochProg%==true - v_expNegDevNPV * p_negDevPen  $ (not p_expShortFall)\n$ifi %stochProg%==true - v_expShortFall * p_negDevPen  $ (not p_expShortFall)\n$ifi %stochProg%==true + v_expShortFall * p_negDevPen  $ p_expShortFall\n        ] $ sum(t_n(tCur,nCur) $  (v_hasFarm.up(tCur,nCur) ne 0),1)\n    ;\n*\n*   --- mean of yearly average discount household withdrawals (plus money value of leisure)\n*       (= equal to simulated value for deterministic version)\n*\n    objeMean_ ..\n\n         v_objeMean =E= sum(t_n(\"%lastYearCalc%\",nCur), v_objeN(nCur)*p_probN(nCur));\n*\n*   --- discounted household withdrawals (plus money value of leisure), per average year\n*\n    objeN_(nCur) $ t_n(\"%lastYearCalc%\",nCur) ..\n\n         v_objeN(nCur)  =E=\n*\n                                [  sum(t_n(tFull,nCur1) $ isNodeBefore(nCur,nCur1),\n                                            [    v_hhsldIncome(tFull,nCur1)\n                                              +  v_leisureVal(tFull,nCur1) $ sum(leisLevl,p_leisureVal(LeisLevl))\n                                            ] * 1/(1+p_discountRate/100)**tFull.pos)\n*\n*                                --- minus initial liquidity\n*\n                                 - sum(t_n(\"%lastOldYear%\",n),v_liquid(\"%lastOldYear%\",n))\n                 ]\n*\n*        --- divived by the number of years\n*\n             /card(tFull)         ;\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/EnvironmentalAccounting/environmental_accounting/","title":"Environmental Accounting Module","text":"<p>Abstract The environmental accounting module utilises commonly applied methodology for the quantification of methane (CH4), ammonia (NH3), nitrous dioxide (N2O), nitrogen oxides (NOx) and elemental nitrogen (N2), as well as particulate matter formation (PM10 and PM2.5), as laid down in IPCC (2019) and EMEP (2013, 2016). N and P lost through erosion, run-off and leaching are calculated using methodology from Richner et al. (2014) and Prasuhn (2006). Upstream emissions from the provision of mayor farm inputs and services can be included via the ecoinvent database c. Emissions are characterised at midpoint level using characterisation factors from Huijbregts et al.(2016).</p>"},{"location":"FarmDynDocumentation/ModelDescription/EnvironmentalAccounting/environmental_accounting/#gaseous-emissions","title":"Gaseous emissions","text":"<p>All calculations related to the environmental accounting are listed in model\\env_acc_module_de.gms while the respective emission factors, characterisation factors and other input data are specified in coeffgen\\env_acc_de.gms. An overview of the methodology, data and the respective (primary) sources used are presented in the table below.</p> Source/Sub-source Pollutant Methodology Tier Enteric fermentation CH4 IPCC (2019) 2 Manure management CH4 IPCC (2019) 2 NH3, N2O, NOx, N2 EEA (2016) 2 Particulate matter EEA (2013) 2 Pasture CH4 IPCC (2019) 2 NH3 EEA (2016) 2 N2O, NOx, N2 IPCC (2019) 1 Field &amp; Pasture / Manure application NH3 EEA (2016) 2 N2O, NOx, N2 IPCC (2019) 1 Field &amp; Pasture / Fertilizer application NH3 EEA (2016) 2 N2O, NOx, N2 IPCC (2019) 1 Field / Lime application CO2 IPCC (2019) 1 Field / Crop residues N2O, N2 IPCC (2019) 1 Field Particulate matter EEA (2016) 1 Field &amp; Pasture NO3- Richner et al(2014) P Prasuhn (2006) Indirect N2O N2O IPCC (2019) 1 <p>The considered emissions are listed in the set emissions, the included sources in the set sources. The cross set source_emissions links emissions to relevant sources. The set emCat lists midpoint emission categories according to Huijbregts et al.(2016).</p> <pre><code>set emissions / NO3,NH3,N2O,NOx,N2,N2Oind,CH4,CO2,TSP,PM25,PM10,P\n$iftheni.upstream \"%upstreamEF%\" == \"true\"\n                  m2aA_eq,CO2_eq,oil_eq,FETP_DCB_eq,P_eq,HTP_DCB_eq,\n                  U235_eq,METP_DCB_eq,N_eq,Fe_eq,m2_eq,CFC11_eq,\n                  PM10_eq,NMVOC_eq,SO2_eq,TETP_DCB_eq,m2aU_eq,m3_eq\n$endif.upStream\n               /;\n</code></pre> <pre><code>set source\n   /\n                                             entFerm\n                                             staSto\n                                             past\n                                             manAppl\n                                             minAppl\n                                             field\n                                             input\n    $$iftheni.upStream \"%upstreamEF%\" == \"true\"\n                                             machine\n                                             building\n                                             stable\n                                             silo\n                                             straw\n    $$endif.upStream\n    /;\n</code></pre> <pre><code>set source_emissions(source,emissions) /\n                                           staSto.(NH3,N2O,NOx,N2,N2Oind,CH4,TSP,PM25,PM10)\n                                           past.(NH3,N2O,NOx,N2,N2Oind,CH4)\n                                           manAppl.(NH3,N2O,NOx,N2,N2Oind)\n                                           minAppl.(NH3,N2O,NOx,N2,N2Oind)\n                                           field.(NO3,N2Oind,CO2, N2O,TSP,PM25,PM10,P)\n                                           entFerm.CH4\n\n  $$iftheni.upStream \"%upstreamEF%\" == \"true\"\n                                            input.(m2aA_eq,CO2_eq,oil_eq,FETP_DCB_eq,P_eq,HTP_DCB_eq,\n                                                   U235_eq,METP_DCB_eq,N_eq,Fe_eq,m2_eq,CFC11_eq,\n                                                   PM10_eq,NMVOC_eq,SO2_eq,TETP_DCB_eq,m2aU_eq,m3_eq)\n                                          machine.(m2aA_eq,CO2_eq,oil_eq,FETP_DCB_eq,P_eq,HTP_DCB_eq,\n                                                   U235_eq,METP_DCB_eq,N_eq,Fe_eq,m2_eq,CFC11_eq,\n                                                   PM10_eq,NMVOC_eq,SO2_eq,TETP_DCB_eq,m2aU_eq,m3_eq)\n                                         building.(m2aA_eq,CO2_eq,oil_eq,FETP_DCB_eq,P_eq,HTP_DCB_eq,\n                                                   U235_eq,METP_DCB_eq,N_eq,Fe_eq,m2_eq,CFC11_eq,\n                                                   PM10_eq,NMVOC_eq,SO2_eq,TETP_DCB_eq,m2aU_eq,m3_eq)\n                                           stable.(m2aA_eq,CO2_eq,oil_eq,FETP_DCB_eq,P_eq,HTP_DCB_eq,\n                                                   U235_eq,METP_DCB_eq,N_eq,Fe_eq,m2_eq,CFC11_eq,\n                                                   PM10_eq,NMVOC_eq,SO2_eq,TETP_DCB_eq,m2aU_eq,m3_eq)\n                                             silo.(m2aA_eq,CO2_eq,oil_eq,FETP_DCB_eq,P_eq,HTP_DCB_eq,\n                                                   U235_eq,METP_DCB_eq,N_eq,Fe_eq,m2_eq,CFC11_eq,\n                                                   PM10_eq,NMVOC_eq,SO2_eq,TETP_DCB_eq,m2aU_eq,m3_eq)\n                                            straw.(m2aA_eq,CO2_eq,oil_eq,FETP_DCB_eq,P_eq,HTP_DCB_eq,\n                                                   U235_eq,METP_DCB_eq,N_eq,Fe_eq,m2_eq,CFC11_eq,\n                                                   PM10_eq,NMVOC_eq,SO2_eq,TETP_DCB_eq,m2aU_eq,m3_eq)\n$$endif.upStream\n                                           / ;\n</code></pre> <pre><code>set emCat \"Emission categories according to ReCiPe(2016)\"\n  /\n       ALOP           \"agricultural land occupation\"\n       GWP            \"climate change\"\n       FDP            \"fossil depletion\"\n       FETPinf        \"freshwater ecotoxicity\"\n       FEP            \"freshwater eutrophication\"\n       HTPinf         \"human toxicity\"\n       IRP_HE         \"ionising radiation\"\n       METPinf        \"marine ecotoxicity\"\n       MEP            \"marine eutrophication\"\n       MDP            \"metal depletion\"\n       NLTP           \"natural land transformation\"\n       ODPinf         \"ozone depletion\"\n       PMFP           \"particulate matter formation\"\n       POFP           \"photochemical oxidant formation\"\n       TAP            \"terrestrial acidification\"\n       TETPinf        \"terrestrial ecotoxicity\"\n       ULOP           \"urban land occupation\"\n       WDP            \"water depletion\"\n/;\n</code></pre> <pre><code>* --- all monthly emissions, differentiated by emissions from herds, cropping and not allocatable emissions\n*\n\n  emissions_(chain_source(curChain,source),emissions,t_n(t,nCur)) $ (tCur(t) $ source_emissions(source,emissions)  $ envAcc )  ..\n\n     v_emissions(curChain,source,emissions,t,nCur)\n\n       =E=\n$iftheni.h %herd% == true\n       sum((singleHerds(herds),breeds)$ ( sum(actHerds(herds,breeds,feedRegime,t,m),1) $ source_emiHerd(source,emissions)),\n                                                 v_emiherds(herds,breeds,curChain,source,emissions,t,nCur))\n$endif.h\n           + sum(curCrops $ source_emiCrops(source,emissions), v_emiCrops(curCrops,curChain,source,emissions,t,nCur) )\n\n           + v_emiOther(curChain,source,emissions,t,nCur)\n\n;\n</code></pre> <p>The actual calculation of the emissions is realised in the equation emissions_ presented above. The time resolution allows for reporting of emissions on a monthly basis. In this equation all emissions from different sources (herds, cropping and other emissions) are summed up. The different compartments of the equation represent the order of emission accounting, by emissions and sources, based on IPCC (2019). Using conditional sameas statements, only relevant emissions and sources are activated in the respective equations. Here we present all different equations building up the three compartments of the general equation emissions_.</p>"},{"location":"FarmDynDocumentation/ModelDescription/EnvironmentalAccounting/environmental_accounting/#methane-emissions-from-enteric-fermentation","title":"Methane Emissions from Enteric Fermentation","text":"<p>Among the emissions directly related to the herds v_emiherds, methane emissions from enteric fermentation (in kg of CH4) are calculated based based on Dong et al. (2006, p.10,31). The actual feed  intake of different herds, v_feeduse, measured in gross energy, is used to calculate emissions. CH4 conversion factors, p_Ym, represent animal specific emission rates, for cattle and pig herds, in % of gross energy converted to methane.   </p> <pre><code>* --- emissions directly relateable to herds per herd\n*\n$iftheni.h %herd% == true\n\n emiherds_(singleHerds(herds),breeds,chain_source(curChain,source),emissions,t_n(t,nCur)) $ (tCur(t) $ source_emiHerd(source,emissions)\n                                $ envAcc $ sum(actHerds(herds,breeds,feedRegime,t,m),1)) ..\n\n    v_emiherds(herds,breeds,curChain,source,emissions,t,nCur)\n\n      =E=\n*     --- Calculation of CH4 emissions from enteric fermentation linked to gross energy intake (IPCC, 2006, eq. 10.21)\n*         in kg CH4 per month (yearly emissions averaged for monthly reporting),\n\n        + [  (\n   $$iftheni.ch %cattle% == true\n\n    +  sum(curFeeds(feeds),p_feedContFMton(feeds,\"GE\")\n                 * sum((feedregime,reqsPhase,m) $ (feedRegime_feeds(feedRegime,curFeeds)\n                                                      $ actHerdsf(herds,breeds,feedRegime,reqsphase,m)),\n                            v_feeding(herds,breeds,feedRegime,reqsPhase,m,curfeeds,t,nCur) *\n                                  [     p_Ym(\"dcows\",\"\") $  sum(sameas(herds,dcows),1)\n                                     +  p_Ym(\"mcows\",\"\") $  sum(sameas(herds,mcows),1)\n               $$ifi defined heifs   +  p_Ym(\"heifs\",\"\") $  sum(sameas(herds,heifs),1)\n               $$ifi defined bulls   +  p_Ym(\"bulls\",\"\") $  sum(sameas(herds,bulls),1)\n                                     +  p_Ym(\"calvs\",\"\") $  sum(sameas(herds,calvs),1) ]))\n\n   $$endif.ch\n   $$iftheni.fat \"%farmBranchfattners%\" == \"on\"\n                   +  sum((sameas(herds,fatHerd),feedregime,m) $ (actHerds(fatHerd,breeds,feedRegime,t,m)\n                                    $ p_feedReqPig%l%(fatHerd,feedRegime,\"energ\")),\n                             p_feedReqPig(fatHerd,feedRegime,\"energ\")  * 1000 * v_herdsize(fatHerd,breeds,feedRegime,t,nCur,m) * p_YM(\"fatHerd\",\"\"))\n   $$endif.fat\n   $$iftheni.sows \"%farmBranchSows%\" == \"on\"\n                    +  sum((sameas(herds,\"sows\"),feedregime,m) $  (actHerds(\"sows\",breeds,feedRegime,t,m)\n                                   $ p_feedReqPig%l%(\"sows\",feedRegime,\"energ\")),\n                             p_feedReqPig(\"sows\",feedRegime,\"energ\") * 1000  * v_herdsize(\"sows\",breeds,feedRegime,t,nCur,m) * p_YM(\"sows\",\"\"))\n   $$endif.sows\n                    )/(100 * 55.65)\n\n        ]   $ ( sameas(emissions,\"CH4\") $ sameas(source,\"entFerm\")  )\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/EnvironmentalAccounting/environmental_accounting/#methane-emissions-from-manure-storage","title":"Methane Emissions from Manure Storage","text":"<p>CH4 emissions stemming from manure storage are included among other emissions v_emiOther and they are calculated according to the volume in the different storage systems, v_volInStorageType. The amount of volatile solids in the slurry is estimated based on the stored volume using the average dry matter, p_avDmMan, and the share of volatile solids in the dry matter, p_oTSMan. The effect of different slurry cover types on emissions is incorporated via different methane conversion factors, p_MCF, in percentage of volatile solids. Furthermore, different manure types are considered in the maximum methane producing capacity, p_BO. The emission factor is divided by 12 according to the monthly resolution.</p> <pre><code>emiOther_(curChain,source,emissions,t_n(t,nCur)) $ (tCur(t)  $ envAcc $source_emissions(source,emissions) $chain_source(curChain,source))  ..\n\n   v_emiOther(curChain,source,emissions,t,nCur)\n\n     =E=\n     $$iftheni.man %manureStorage% == true\n\n*  --- Calculation of CH4 from storage according to Haenel et al. (2018) p. 42 No. 3.28 and 3.29 Following IPCC, 2006, eq. 10.23;  in kg CH4 per month\n         +   [  sum( (sameas(curManChain,curChain),manStorage,m),   v_volInStorageType(curManChain,manStorage,t,nCur,m)\n                         *  1000 * p_avDmMan(curManChain) * p_oTSMan(curManChain) * p_BO(curManChain)\n                         * p_densM * p_MCF(Manstorage,curManChain)\n                         /12)\n             ] $ ( sameas(emissions,\"CH4\") $ sameas(source,\"staSto\")  )\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/EnvironmentalAccounting/environmental_accounting/#methane-emissions-from-excreta-on-pastures","title":"Methane emissions from excreta on pastures","text":"<p>Excreta on pastures also emits CH4. The calculation of those emissions is conducted analog to the emissions from storage with a specific methane conversion factor, p_MCFPast and using the volume of manure excreted on pastures. Emissions from excreta on pastures are considered among the emissions directly related to crop production:</p> <pre><code>emicrops_(curCrops,chain_source(curChain,source),emissions,t_n(t,nCur)) $ (tCur(t) $ source_emiCrops(source,emissions)  $ envAcc )  ..\n\n   v_emiCrops(curCrops,curChain,source,emissions,t,nCur)\n\n   =E=\n\n*  --- Calculation of CH4 from storage according to Haenel et al. (2018) p. 42 No. 3.28 and 3.29 Following IPCC, 2006, eq. 10.23;\n*      in kg CH4 per month\n*   Pasture:\n*\n   $$iftheni.ch %cattle% == true\n\n        + [  sum( (c_p_t_i(curCrops,plot,till,\"graz\"),curManChain,m),  v_manQuantPast(curCrops,plot,till,\"graz\",curManChain,t,nCur,m)\n                   *  1000 * p_avDmMan(curManchain) * p_oTSMan(curManChain) * p_BO(curManchain)\n                   * p_densM * p_MCFPast)\n          ] $ ( sameas(emissions,\"CH4\") $ sameas(source,\"past\") $ grasCrops(curCrops))\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/EnvironmentalAccounting/environmental_accounting/#n-emissions-from-stable-and-storage","title":"N Emissions from Stable and Storage","text":"<p>N-emissions are calculated using a mass-flow approach starting with the N excretion by farm animals. Three N-pools are considered, N-TAN, N-Org and total N. The correction of the N pools by previous losses are not part of the env_acc_module but are considered in the manure_module.  The considered N flows and emissions are depicted in the figure below :</p> <p></p> <p>Figure 1: N mass flow approach with considered stages and emissions in FarmDyn</p> <p>NH3 emissions at the stable stage are calculated according to the N-TAN in manure as excreted by the animals, v_nut2ManureM. NH3 emissions from storage are calculated based on the N-TAN pool in storage, v_nutPoolInStorage. The emission factors differentiate between cattle and pig slurry. While NH3 emissions are based only on the N-TAN pool, other N emissions are based on the total N pool as depicted in v_nut2manureM. Considered emissions are N2O and NOx. N2 is generally not considered as an emission. For the completeness of the N-flow model, N losses in the form of N2 are still calculated in the environmental accounting. Indirect N2O emissions (N2Oind) are determined based on prior emissions of reactive N species, namely NH3 and NOx. For the sake of simplicity, the stages stable and storage are summarized in the calculation of emissions. Compared to total N2O and NOx emissions on farm the emissions at this stage are rather small and the generalisation is not expected to distort the results. N emissions from stable and storage are calculated based on IPCC (2019) and EMEP (2016) and included in the emissions directly related to the herds v_emiherds.</p> <pre><code>*     --- Calculation of NH3, N2O, NOx, N2, N2Oind from stable and storage (staSto) Haenel et al. 55\n\n  +    [\n\n\n         sum((sameas(curManChain,curChain),m) $ sum(actherds(herds,breeds,feedregime,t,m),1),\n                  (v_nut2ManureHerds(herds,breeds,curManChain,\"NTAN\",t,nCur,m)  $ (not sameas(curmanchain,\"LiquidBiogas\"))\n                                              * (p_EFSta(\"NH3\",curManChain) + p_EFSto(\"NH3\",curManChain)))) $( sameas(emissions,\"NH3\"))\n\n        + sum((sameas(curManChain,curChain),m) $ sum(actherds(herds,breeds,feedregime,t,m),1),\n                                            (v_nut2ManureHerds(herds,breeds,curManChain,\"NTAN\",t,nCur,m)$ (not sameas(curmanchain,\"LiquidBiogas\"))\n                                          +  v_nut2ManureHerds(herds,breeds,curManChain,\"NOrg\",t,nCur,m)$ (not sameas(curmanchain,\"LiquidBiogas\")))\n                                          *  ( p_EFStaSto(\"N2O\",curManChain)    $ sameas(emissions,\"N2O\")\n                                             + p_EFStaSto(\"NOx\",curManChain)    $ sameas(emissions,\"NOx\")\n                                             + p_EFStaSto(\"N2\",curManChain)     $ sameas(emissions,\"N2\")\n                                             ))\n\n        + (sum(sameas(curManChain,curChain), v_emiHerds(herds,breeds,curChain,\"stasto\",\"NOx\",t,nCur)\n                                            + v_emiHerds(herds,breeds,curChain,\"stasto\",\"NH3\",t,nCur)\n                                            ) * p_EFN2Oind ) $ sameas(emissions,\"N2Oind\")\n      ]  $ sameas(source,\"staSto\")\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/EnvironmentalAccounting/environmental_accounting/#n-emissions-from-pasture","title":"N Emissions from Pasture","text":"<p>The calculation of N emissions from pastures follows the same logic as the calculation of emissions from the stable and storage stage. The emission factors, p_EFpasture, represent the conditions of manure excreted on pastures. The source of the applied methodology can be found in EMEP (2016, p. 20f) and Klein (2006, p.6 f). As for methane emissions nitrogen emissions from pasture are included in v_emiCrops.</p> <pre><code>*     --- Calculation of NH3, N2O, NO and N2 losses from manure excretion on pasture for cattle according to Haenel et al. (2018)p.55 and p.332 and IPCC(2006)-11.6 ff\n*         in kg NH3-N, N2O-N, NO-N and N2 per month\n\n        + [\n              + sum((c_p_t_i(curCrops,plot,till,intens),m)\n                         $ ( (p_grazMonth(curCrops,m)&gt;0) $ sum(actHerds(possHerds,breeds,grazRegime,t,m)\n                          $ sum(nut2,p_nutExcreDueV(possHerds,grazRegime,nut2)),1)),\n\n                     v_nut2ManurePast(curCrops,plot,till,intens,\"NTAN\",t,nCur,m)\n                      * (  p_EFPasture(\"NH3\")       $ sameas(emissions,\"NH3\")  )\n\n                  +  (   v_nut2ManurePast(curCrops,plot,till,intens,\"NTAN\",t,nCur,m)\n                       + v_nut2ManurePast(curCrops,plot,till,intens,\"Norg\",t,nCur,m))\n                      * (  p_EFPasture(\"N2O\")        $ sameas(emissions,\"N2O\")\n                         + p_EFPasture(\"NOx\")        $ sameas(emissions,\"NOx\")\n                         + p_EFPasture(\"N2\")         $ sameas(emissions,\"N2\")\n                         ))\n\n*     --- Calculation of N2Oind from manure excretion on grassCropsure for cattle\n*         in kg N2O-N per month\n                + (( v_emiCrops(curCrops,\" \",\"past\",\"NH3\",t,nCur) + v_emiCrops(curCrops,\" \",\"past\",\"NOx\",t,nCur))\n                     * p_EFN2Oind ) $ sameas(emissions,\"N2Oind\")\n\n          ] $ (sameas(source,\"past\") $ grasCrops(curCrops))\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/EnvironmentalAccounting/environmental_accounting/#n-emissions-from-manure-application","title":"N Emissions from Manure Application","text":"<p>NH3 emissions from the application of manure are calculated based on the N-TAN pool in the slurry leaving the storage stage. The amount is estimated using the total amount of slurry in cubic meter v_manDist and of nutrients in the slurry as determined by p_nut2inMan in kg N-TAN. The emission factors vary between grassland and arable land, different application devices and pig and cattle slurry. N2O, NOx and N2 emissions are calculated based on the total N pool at the application stage, v_nut2manApplied. The emission factor (p_EFAPpplMin ) is equal to the emission factors for the application of synthetic fertilisers, as proposed by IPCC (2019). The calculation of N2O emission follows Klein (2006, p.7ff), the calculation of NOx EMEP (2016) and N2 from Roesemann (2015, p. 317). Indirect N2O emissions are based on prior emissions of NH3 and NOx.</p> <pre><code>*     --- Calculation of NH3, N2O, NOx, N2 from manure application\n*         NH3 losses depending on technology, source EMEP (2016)p.22ff for NH3; IPCC (2006)-11.7 for N2O; EMEP (2016)-3.D-11 for NOx\n*         in kg NH3-N, N2O-N, NO-N and N2 per month:\n\n     + [   sum( (c_p_t_i(curCrops,plot,till,intens),manApplicType_manType(ManApplicType,curManType),m)\n                           $ (sum(sameas(curChain,curManChain) $ manChain_type(curManChain,curManType),1)\n                           $ (not catchcrops(curcrops))),\n              v_manDist(curCrops,plot,till,intens,ManApplicType,curManType,t,nCur,m)\n                      * sum(manChain,p_nut2inMan(\"NTAN\",curManType,manChain))\n                  * p_EFapplMan(curCrops,curManType,manApplicType,\"NTAN\",m)) $ sameas(emissions,\"NH3\")\n\n         + sum((sameas(curManChain,curChain),nut2,m) $ (not sameas(nut2,\"P\")),\n                    v_nut2ManApplied(curCrops,curManChain,nut2,t,nCur,m)\n                         * (    p_EFApplMin(\"N2O\") $ sameas(emissions,\"N2O\")\n                              + p_EFApplMin(\"NOx\") $ sameas(emissions,\"NOx\")\n                              + p_EFApplMin(\"N2\")  $ sameas(emissions,\"N2\")))\n\n         + (sum(sameas(curManChain,curChain) ,  v_emiCrops(curCrops,curChain,\"manAppl\",\"NH3\",t,nCur)\n                                              + v_emiCrops(curCrops,curChain,\"manAppl\",\"NOx\",t,nCur))\n                               * p_EFN2Oind ) $ sameas(emissions,\"N2Oind\")\n\n       ] $ sameas(source,\"manAppl\")\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/EnvironmentalAccounting/environmental_accounting/#n-emissions-from-mineral-fertiliser-application","title":"N Emissions from Mineral Fertiliser Application","text":"<p>N-emissions from the application of mineral fertiliser, except for NH3, follow the same logic as from the application of manure. In synthetic fertiliser all N is present as N-TAN. The emission factor for NH3 emissions distinguishes between different fertiliser types, according to EMEP (2016, p.161). For the calculation of emissions, only the emission factor changes from p_EFApplMinNH3 to p_EFApplMin. The pool of applied N from mineral fertiliser is determined by the total amount of applied fertiliser v_syntDist in kg multiplied by the share of N in the fertiliser, p_nutInSynt</p> <pre><code>*    --- Calculation of NH3, N2O, NOx, N2 from mineral fertilizer application\n*        Based on IPCC (2006)-11.7 for N2O; EMEP (2016)-3.D-11 for NOx, Roesemann et al. 2015, pp. 316-317 for N2\n*         in kg NH3-N, N2O-N, NO-N and N2 per month\n\n     + [sum( (c_p_t_i(curcrops,plot,till,intens),curInputs(syntFertilizer),m),\n                      v_syntDist(curCrops,plot,till,intens,syntFertilizer,t,nCur,m)  * p_nutInSynt(syntFertilizer,\"N\")\n                 * (    p_EFApplMinNH3(syntFertilizer) $ sameas(emissions,\"NH3\")\n                      + p_EFApplMin(\"N2O\") $ sameas(emissions,\"N2O\")\n                      + p_EFApplMin(\"NOx\") $ sameas(emissions,\"NOx\")\n                      + p_EFApplMin(\"N2\")  $ sameas(emissions,\"N2\")))\n\n             + (( v_emiCrops(curCrops,\" \",\"minAppl\",\"NH3\",t,nCur) + v_emiCrops(curCrops,\" \",\"minAppl\",\"NOx\",t,nCur))\n                           * p_EFN2Oind ) $ sameas(emissions,\"N2Oind\")\n       ] $  sameas(source,\"minAppl\")\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/EnvironmentalAccounting/environmental_accounting/#n-emissions-from-crop-residues","title":"N Emissions from Crop Residues","text":"<p>The calculation of N2O emissions from crop residues is divided into three parts: At first the above and below ground N pool from crop residues are determined. Then the removal of N in crop residues through the harvest of straw is deducted. In a last step, the remaining N pool is multiplied with an emission factor. The methodology is adapted from Klein (2006, p.11 ff). The parameter p_cropResi inherits all further information needed for the derivation of the amount of N in crop residues. The different information is controlled through the set resiEle. The parameter includes information about the duration of the cropped system (\u201cduration\u201d), the frequency of harvesting (\u201cfreqHarv\u201d), the dry matter content of the fresh matter yield (\u201cDMyield\u201d), the dry matter content of above ground residues (\u201cDMresi\u201d), the ratio of above ground crop residues to yield (\u201caboveRat\u201d), the nitrogen content of the above-ground crop residues (\u201caboveN\u201d), the ratio of below ground crop residues to above ground biomass (\u201cbelowRat\u201d), and the nitrogen content of below ground crop residues (\u201cbelowN\u201d). At first, the above ground N from organic material is calculated based on the main output, which is determined by the cropped area v_cropHa (in ha), multiplied by the main output of the respective crop p_OCoeffC in t fresh matter per ha of the respective crop:</p> <pre><code>*  --- Calculation of N2O emissions from crop residues on field in kg N2O-N per month; devided by 12 to account for monthly resolution; IPCC(2006)-11.11 ff\n\n    + [(  sum(c_p_t_i(curcrops,plot,till,intens),\n*     --- arable land residues abvove ground\n           + v_cropHa(curCrops,plot,till,intens,t,nCur)\n            * sum( (plot_soil(plot,soil),curProds) $ p_OCoeffC%l%(curCrops,soil,till,intens,curProds,t), p_OCoeffC(curCrops,soil,till,intens,curProds,t) * 1000)\n             * p_cropResi(curCrops,\"duration\") * p_cropResi(curCrops,\"freqHarv\") *  p_cropResi(curCrops,\"aboveRat\") * p_cropResi(curCrops,\"aboveN\")\n\n*     --- arable land residues below ground\n           + v_cropHa(curCrops,plot,till,intens,t,nCur) *  sum( (plot_soil(plot,soil),curProds) $ p_OCoeffC%l%(curCrops,soil,till,intens,curProds,t) ,\n              p_OCoeffC(curCrops,soil,till,intens,curProds,t) * 1000)\n              * p_cropResi(curCrops,\"duration\") * p_cropResi(curCrops,\"freqHarv\")\n              * ( p_cropResi(curCrops,\"DMyield\")$(not sameas(curCrops,\"potatoes\") and not sameas(curCrops,\"sugarBeet\"))\n               + p_cropResi(curCrops,\"aboveRat\") * p_cropResi(curCrops,\"DMresi\"))\n               * p_cropResi(curCrops,\"belowRat\") * p_cropResi(curCrops,\"belowN\")  )\n\n*      --- deduction for straw removal\n            -sum( c_p_t_i(curcrops,plot,till,intens) $ cropsResidueRemo(curCrops),  v_residuesRemoval(curCrops,plot,till,intens,t,nCur)\n                * sum( (plot_soil(plot,soil),prodsResidues), 10 * p_OCoeffResidues(curCrops,soil,till,intens,prodsResidues,t)\n                                                                   * p_nutContent(curCrops,prodsResidues,\"conv\",\"N\")))\n\n      )  * p_EFApplMin(\"N2O\")\n     ] $ ( sameas (emissions,\"N2O\") $ sameas (source,\"field\"))\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/EnvironmentalAccounting/environmental_accounting/#co2-emissions-from-liming","title":"CO2 Emissions from Liming","text":"<p>Lime is commonly used in agriculture to manage soil acidity. CO2 emissions stemming from lime application are introduced in the cropping related section. The amount of applied lime is paired with a simple emission factor p_EFLime,  and it is determined from the bought inputs, v_buy in t.</p> <pre><code>* --- Calculation of CO2 emissions from liming in kg CO2 per month; devided by 12 for monthly resolution; IPCC (2006) 11.27\n\n+  [  sum(c_p_t_i(curcrops,plot,till,intens) $ (p_costQuant(curCrops,till,intens,\"lime\")),\n         v_cropHa(curCrops,plot,till,intens,t,nCur) * p_costQuant(curCrops,till,intens,\"lime\") /\n           (p_inputPrices(\"lime\",\"conv\")  $ (not sameas(till,\"org\"))\n            + p_inputPrices(\"lime\",\"org\") $ (    sameas(till,\"org\"))) * v_costQuant(curCrops,\"lime\")) \n           *  p_EFLime(\"lime\")\n   ] $ ( sameas (emissions,\"CO2\") $ sameas (source,\"field\"))\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/EnvironmentalAccounting/environmental_accounting/#emissions-from-production-of-external-inputs-and-services","title":"Emissions from Production of External Inputs and Services","text":"<p>Up-stream emissions stemming from the production of farm inputs and services are included to gain insides on the environmental outcome of production beyond the farm boundaries. Emissions are considered via the ecoinvent database (Wernet et al. 2016). Due to licensing fees the data base is not part of the main model code but may be forwarded if requested. Therefore, the calculation of emissions is restricted through conditional assignments triggered by a checkbox in the interface.</p> <p>Emissions from production of mineral fertilizers are considered based on the amount of applied fertilizers v_syntDist.</p> <ul> <li> <p>--- Calculation of emissions stemming from synthetic fertilizer production</p> </li> <li> <p>[  sum( (c_p_t_i(curcrops,plot,till,intens),sameas(inputs,syntFertilizer),m),               v_syntDist(curCrops,plot,till,intens,syntFertilizer,t,nCur,m) * p_EFInput(syntFertilizer,emissions))       ] $sameas(source,\"input\")</p> </li> </ul> <p>Other crop specific inputs are estimated based on the bought quantity or costs as specified in p_costQuant.</p> <pre><code>+ [ sum( (c_p_t_i(curCrops,plot,till,intens),inputs) $ p_costQuant(curcrops,till,intens,inputs),\n      v_cropHa(curCrops,plot,till,intens,t,nCur)\n        *( p_costQuant(curCrops,till,intens,inputs) * v_costQuant(curCrops,inputs)) $(not sameas(inputs,\"seed\"))\n          * p_EFInputCrops(curCrops,till,intens,inputs,emissions))\n  ] $sameas(source,\"input\")\n</code></pre> <p>Emissions from field operations include the production, use and transportation of machines as well as diesel and pesticides. They are calculated using p_crop_op_per_till. For manure application emissions are calculated based on the amount of applied manure v_manDist.</p> <pre><code>+  [\n</code></pre> <ul> <li> <p>--- crops times their need for field operations, yield depression effect is missing here         sum((c_p_t_i(curcrops,plot,till,intens),operation),             v_cropHa(curCrops,plot,till,intens,t,nCur)                * sum(labPeriod, p_crop_op_per_till(curCrops,Operation,labPeriod,till,intens)                                     * p_EFoperations(curCrops,plot,till,intens,operation,emissions,t)/12 ))</p> </li> <li> <p>---- machine need for the application of manure            $$iftheni.man %manure% == true</p> <pre><code>    + sum( (c_p_t_i(curCrops,plot,till,intens),manApplicType_manType(ManApplicType,curManType),m)\n             $ (v_manDist.up(curCrops,plot,till,intens,manApplicType,curManType,t,nCur,m) ne 0),\n               v_manDist(curCrops,plot,till,intens,ManApplicType,curManType,t,nCur,m)\n                 * sum(sameas(operation,\"manDist\"), p_EFoperations(curCrops,plot,till,intens,operation,emissions,t)) )\n   $$endif.man\n</code></pre> <p>] $sameas(source,\"machine\")</p> </li> </ul> <p>Emissions from machine use and production in stables is calculated based on the machine need p_machNeed and the herd size v_herdSize </p> <pre><code>  * --- Calculation of emissions from machine provision and use related to herds\n\n       +  [  sum((machtype,machLifeUnit) $ p_lifeTimeM(machType,machLifeUnit),\n\n                sum(actHerds(herds,breeds,feedRegime,t,m) $ p_prodLength(herds,breeds),\n                   v_herdSize(herds,breeds,feedRegime,t,nCur,m)\n                    * p_machNeed(herds,\"plough\",\"normal\",machType,machLifeUnit)\n                                * 1/min(12,p_prodLength(herds,breeds)))\n\n                    * (p_machAttr(machType,\"diesel_h\") * p_EFInput(\"diesel\",emissions) ) $(sameas(machType,\"tractorSmall\") $sameas(machLifeUnit,\"hour\"))\n                    )\n          ] $sameas(source,\"machine\")$((not sum(sameas(sumherds,herds),1)) or sum(sameas(calvsRais,herds),1) )\n</code></pre> <p>Emissions from bought feedstuff and straw for bedding in stables is calculated based on the bought amounts in v_feedusebuy and v_buy</p> <pre><code>   +  [\n                sum(sys$ p_inputPrice%l%(\"straw\",sys,t),     v_buy(\"straw\",sys,t,nCur)  *  p_EFInput(\"straw\",emissions))\n      ]$sameas(source,\"straw\")\n\n   +  [ sum((sameas(feeds,inputs)) $ sum(sys $p_inputPrice%l%(inputs,sys,t),1),\n                      v_feedusebuy(feeds,t,nCur)  *  p_EFInput(inputs,emissions))\n\n      ]$sameas(source,\"input\")\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/EnvironmentalAccounting/environmental_accounting/#particulate-matter-formation","title":"Particulate Matter Formation","text":"<p>Particulate matter emissions are categorised into three compartments depending on the size of the particles: particulate matter smaller than 2.5 \u03bcm (PM2.5), particulate matter smaller than 10 \u03bcm (PM2.5) (PM10) and total suspended particles (TSP) according to EMEP (2016). Although all compartments are calculated in FarmDyn only the smallest particles (PM2.5) enter the later characterization step according to Huijbregts et al. (2016). Indirect emissions can form from prior NH3, NO3 and NOX emissions (WHO 2003).</p> <p>Direct emissions of particulate matter from animal husbandry are calculated according to EMEP (2013) using a tier 2 approach considering different animal types, stable systems and the time animals spend in the stable. As stable systems are considered as an exogenous decision in the model, an emission factor (p_EFpmfHerds) is linked to the variable v_herdsize.</p> <pre><code>* --- Calculation of particulate matter emission from animal husbandry EMEP(2013)\n*     3.3(\u201cTier 2 technology-specific approach\u201c), Haenel et al (2018) p.66\n\n   +  [ sum((actHerds(herds,breeds,feedRegime,t,m),sameas(curmanchain,curChain))\n            $ (p_manQuantMonth(herds,curManChain) $ p_prodLength(herds,breeds)),\n                  v_herdSize(herds,breeds,feedRegime,t,nCur,m)  *  p_EFpmfHerds(herds,feedregime,curmanchain,emissions)/12 )\n      ]   $ sameas(source,\"staSto\")\n</code></pre> <p>Similarly, direct emissions of particulate matter from crop cultivation, harvesting and processing are calculated according to EMEP (2016, p.19) considering the type of crop, the crop specific cultivation operations, harvesting operations and the storage and processing of harvested goods (drying and cleaning). The activity data entering the equation is the cropped area per crop, v_cropHa and the emission factor p_EFpmfCrops.</p> <pre><code>* --- Calculation of particulate matter emission from cropping EMEP(2016) 3D p.19,\n*     if upstream emissions are considered this is included in machine operations\n\n$$iftheni.eco  not \"%upstreamEF%\" == \"true\"\n   +  [  sum(c_p_t_i(curcrops,plot,till,intens),\n            v_cropHa(curCrops,plot,till,intens,t,nCur)\n                  * sum((operation,labperiod), p_crop_op_per_till(curCrops,Operation,labPeriod,till,intens)\n                             * p_EFpmfCrops(curCrops,operation,emissions) ))\n      ]   $ sameas(source,\"field\")\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/EnvironmentalAccounting/environmental_accounting/#nitrate-leaching-losses","title":"Nitrate Leaching Losses","text":"<p>In FarmDyn, an advanced N balance, i.e. the model Salca NO3, is used to calculate N leaching losses based on the methodology of Richner (2014). Conceptually, the underlying assumption of the model is that inputs of N from mineralization of soil-organic-N, fertilisation, or excretion of grazing animals is either taken up by plants or leached. The total loss of N through leaching on farm-level therefore is calculated as the sum of N inputs into the soil after gaseous N losses from fertilisation, from mineralization and from excreta of grazing animals. The inputs are deducted by the amount of N taken up by plants. The remaining N is then the leaching loss which is finally filtered for positive values only (negative emissions not possible):</p> <pre><code>* --- Calculation of leaching on farm level adapted from SALCA NO3 (Richner (2014)) in kg NO3-N per year\n*     (only for crops with a nutrient need, exempts idling land, flowerstripes etc.)\n*\n leachCrops_(curCrops,t_n(tCur(t),nCur)) $( sum((c_p_t_i(curCrops,plot,till,intens),plot_soil(plot,soil)),p_nutNeed(curCrops,soil,till,intens,\"N\",t))\n                                          $ envAcc ) ..\n\n    v_leachCrops(curCrops,t,ncur) =e=\n\n*    --- leached N from applied manure\n    $$iftheni.h %herd% ==true\n        sum( (plot,till,intens,manApplicType_manType(ManApplicType,curManType),m)\n                 $ (manApplicType_manType(ManApplicType,curManType)\n                 $ (v_manDist.up(curCrops,plot,till,intens,manApplicType,curManType,t,nCur,m) ne 0)\n                 $ ( not catchcrops(curcrops) ) $c_p_t_i(curCrops,plot,till,intens)),\n            v_manDist(curCrops,plot,till,intens,ManApplicType,curManType,t,nCur,m)\n                 * sum(curManChain, p_nut2inMan(\"NTAN\",curManType,curManChain))  * p_EfLeachFert(curCrops,m)  )\n\n                 -  sum( (curChain,NiEmissions(Emissions)) $ chain_source(curChain,\"manAppl\"),\n                       v_emiCrops(curCrops,curChain,\"manAppl\",emissions,t,nCur) )\n    $$endif.h\n\n*    --- leached N from applied mineral fertilizer\n      + sum( (plot,till,intens,syntFertilizer,m)$c_p_t_i(curCrops,plot,till,intens),\n            v_syntDist(curCrops,plot,till,intens,syntFertilizer,t,nCur,m) * p_nutInSynt(syntFertilizer,\"N\")  * p_EfLeachFert(curCrops,m) )\n\n            -  sum( (curChain,NiEmissions(Emissions)) $ chain_source(curChain,\"minAppl\"),\n                  v_emiCrops(curCrops,curChain,\"minAppl\",emissions,t,nCur) )\n\n*    --- leached N from mineralization\n\n     +  sum((plot,till,intens,m)$c_p_t_i(curCrops,plot,till,intens), p_LeachNorm(m) * v_cropHa(curCrops,plot,till,intens,t,nCur))\n\n*    ---  correction of mineralisation for longterm effects of organic fertilization (+10% per DGVE per ha; 1DGVE = 110kgN/h and a)\n\n  $$iftheni.h %herd% ==true\n    +  sum( m,p_LeachNorm(m)) * 0.1\n      *  [sum( (plot,till,intens,manApplicType_manType(ManApplicType,curManType),m)\n              $ ( (v_manDist.up(curCrops,plot,till,intens,manApplicType,curManType,t,nCur,m) ne 0)\n                  $( not catchcrops(curcrops) )  $c_p_t_i(curCrops,plot,till,intens)),\n\n                 v_manDist(curCrops,plot,till,intens,ManApplicType,curManType,t,nCur,m)\n                   * (sum(manChain,p_nut2inMan(\"NORG\",curManType,manChain))\n                   +  sum(manChain,p_nut2inMan(\"NTAN\",curManType,manChain)) )   )\n\n                  -  sum( (curChain,NiEmissions(Emissions)) $ chain_source(curChain,\"manAppl\"),\n                        v_emiCrops(curCrops,curChain,\"manAppl\",emissions,t,nCur)) -110  ]/110\n  $$endif.h\n\n*    --- additional mineralization in month with intensive cultivation operation\n\n   +  sum( (plot,till,intens,m)$(c_p_t_i(curCrops,plot,till,intens) $sum(arabCrops(crops)$sameas(crops,arabcrops),1)),\n          p_CfIntensTill(m,curCrops)* p_CfNLeachTill(m) * v_cropHa(curCrops,plot,till,intens,t,nCur) )\n\n*      --- correction for reduced mineralization under grassland\n  -  sum[ (plot,till,intens) $(c_p_t_i(curCrops,plot,till,intens) $ sum(grasCrops(crops)$sameas(crops,grascrops),1)),\n         v_cropHa(curCrops,plot,till,intens,t,nCur) * p_CfNLeachGrass(curCrops) ]\n\n*     --- plant removal deduction\n    -   sum ( (plot_soil(plot,soil),till,intens) $c_p_t_i(curCrops,plot,till,intens),\n                  p_nutNeed(curCrops,soil,till,intens,\"N\",t) * v_cropHa(curCrops,plot,till,intens,t,nCur))\n\n*     --- leaching from grazed pastures\n\n    $$iftheni.ch %cattle% == true\n +\n          sum((plot,till,intens,m)\n                      $ ( (p_grazMonth(curCrops,m)&gt;0) $ sum(actHerds(possHerds,breeds,grazRegime,t,m)\n                      $ sum(nut2,p_nutExcreDueV(possHerds,grazRegime,nut2)),1)\n                      $c_p_t_i(curCrops,plot,till,intens)),\n                (   v_nut2ManurePast(curCrops,plot,till,intens,\"NTAN\",t,nCur,m)\n                  + v_nut2ManurePast(curcrops,plot,till,intens,\"NORG\",t,nCur,m)\n\n                  - sum((curChain,NiEmissions(Emissions)) $ (chain_source(curChain,\"past\")) ,\n                           v_emiCrops(curCrops,curChain,\"past\",emissions,t,nCur))/12\n\n                )*p_leachPast(m)\n            )$sum(grasCrops(crops)$sameas(crops,grascrops),1)\n\n    $$endif.ch\n;\n\n* --- equations to filter for positive values only, negative emissions are not possible in this case\n\nslackLeach_(curCrops,t_n(tCur(t),nCur)) $ (sum((c_p_t_i(curCrops,plot,till,intens),plot_soil(plot,soil)),p_nutNeed(curCrops,soil,till,intens,\"N\",t))\n                                             $ envAcc) ..\n\n  v_leachCrops(curCrops,t,nCur) - v_leachpositive(curCrops,t,nCur)+ v_leachnegative(curCrops,t,nCur) =E= 0;\n\nfinalLeach_(curCrops,t_n(tCur(t),nCur)) $ (sum((c_p_t_i(curCrops,plot,till,intens),plot_soil(plot,soil)),p_nutNeed(curCrops,soil,till,intens,\"N\",t))\n                                             $ envAcc)..\n\n 2* v_leachpositive(curCrops,t,nCur) =e= v_leachCrops(curCrops,t,nCur) + v_leachpositive(curCrops,t,nCur) + v_leachnegative(curCrops,t,nCur) ;\n\nleachTotal_(t_n(t,nCur))  $ (tCur(t) $ envAcc) ..\n\n        v_leach(t,nCur) =e=\n\n      Sum(curCrops $ sum((c_p_t_i(curCrops,plot,till,intens),plot_soil(plot,soil)),p_nutNeed(curCrops,soil,till,intens,\"N\",t)),\n          v_leachpositive(curCrops,t,nCur));\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/EnvironmentalAccounting/environmental_accounting/#phosphorus-losses","title":"Phosphorus Losses","text":"<p>In the model \u201cSALCA Phosphor\u201d from Prasuhn (2006) was utilised to calculate phoshorus losses. The model comprises losses for the mentioned pathways above: erosion, leaching  and runoff. The total loss of P, is determined through the sum of the single compartments. The underlying principle is to apply default loss factors for all pathways that are adapted to local management and pedo-climatic conditions. The advantage of the approach is the possibility to dynamically adjust the level of detail depending on the data availability.</p> <p>P loss through soil erosion, in kg P, is calculated using a default value for the eroded soil, p_erosion, the share of the eroded soil that reaches water pathways,p_lossfactor, the P content of the eroded soil, p_PContSoil, and a factor taking into account the particle size and texture of the eroded soil P, p_PAccuSoil.</p> <p>P lost through leaching, EP,Leaching in kg P, is calculated considering soil properties (included int the parameter p_soilFactLeach), effects of fertilisation with slurry, and the P content of the soil. The default values for P losses, p_PLossLeach, are depending on the land use. The factor p_PSoilClass is based on Walther et al. (2001).</p> <p>The P loss through runoff, is calculated considering a default value, depending on the land use, a soil factor, a slope factor, a factor for the P content of the top soil and a factor considering effects of fertilisation.</p> <pre><code>*  --- Calculation of phosphorus losses through erosion, leaching and runoff according to SALCA P (Prasuhn 2006)\n*\n\nlossPhosCrops_(curCrops(crops),t,nCur) $ (tCur(t) $ t_n(t,nCur) $ envAcc  )  ..\n\n   v_lossPhosCrops(curCrops,t,nCur) =e=\n\n*    --- Loss through erosion\n\n      sum((plot,till,intens)$c_p_t_i(curCrops,plot,till,intens), v_cropHa(curCrops,plot,till,intens,t,nCur) * p_erosion * p_lossfactor * p_PContSoil * p_PAccuSoil  )\n\n*    --- Loss through leaching grassland\n$$iftheni.ch %cattle% == true\n\n      + [sum((plot,till,intens)$c_p_t_i(curCrops,plot,till,intens), p_PLossLeach(\"grass\") * p_soilFactLeach * p_PSoilClass * v_cropHa(curCrops,plot,till,intens,t,nCur))\n\n         + p_PLossLeach(\"grass\") * p_soilFactLeach * p_PSoilClass *\n            sum((plot,till,intens,manApplicType_manType(manApplicType,curMantype),m) $(c_p_t_i(curCrops,plot,till,intens)$(not sameas (ManApplicType,\"applSolidSpread\"))),\n                     p_PLossFert(\"low\") * v_manDist(crops,plot,till,intens,ManApplicType,curManType,t,nCur,m) * sum((manChain),p_nut2inMan(\"P\",curManType,manChain)))\n        ]$sum(grasCrops(crops)$sameas(crops,grascrops),1)\n$$endif.ch\n\n*    --- Loss through leaching arable land\n\n    +[ sum((plot,till,intens)$c_p_t_i(curCrops,plot,till,intens), p_PLossLeach(\"arable\") * p_soilFactLeach * p_PSoilClass * v_cropHa(curCrops,plot,till,intens,t,nCur))\n  $$iftheni.man %manure% == true\n\n      + p_PLossLeach(\"arable\") * p_soilFactLeach * p_PSoilClass * sum((plot,till,intens,manApplicType_manType(manApplicType,curMantype),m) $(c_p_t_i(curCrops,plot,till,intens)$(not sameas (ManApplicType,\"applSolidSpread\"))),\n                        p_PLossFert(\"low\") * v_manDist(crops,plot,till,intens,ManApplicType,curManType,t,nCur,m) * sum((manChain),p_nut2inMan(\"P\",curManType,manChain)))\n\n  $$endif.man\n     ]$sum(arabCrops(crops)$sameas(crops,arabcrops),1)\n\n*    --- loss thorugh runoff grassland\n$$iftheni.ch %cattle% == true\n\n      +[ sum((plot,till,intens)$c_p_t_i(curCrops,plot,till,intens), p_PLossRun(\"grass\") * p_soilFactRun * p_PSoilClass * p_slopeFactor * v_cropHa(curCrops,plot,till,intens,t,nCur) )\n\n            + p_PLossRun(\"grass\") * p_soilFactRun * p_PSoilClass * p_slopeFactor *\n\n                 ( sum((plot,till,intens,manApplicType_manType(manApplicType,curMantype),m) $(c_p_t_i(curCrops,plot,till,intens)$(not sameas (ManApplicType,\"applSolidSpread\"))),\n                     p_PLossFert(\"high\") * v_manDist(crops,plot,till,intens,ManApplicType,curManType,t,nCur,m) * sum((manChain),p_nut2inMan(\"P\",curManType,manChain)))\n\n                 + sum((plot,till,intens,manApplicType_manType(manApplicType,curMantype),m) $(c_p_t_i(curCrops,plot,till,intens)$sameas (ManApplicType,\"applSolidSpread\")),\n                     p_PLossFert(\"medium\") * v_manDist(crops,plot,till,intens,ManApplicType,curManType,t,nCur,m) * sum((manChain),p_nut2inMan(\"P\",curManType,manChain)))\n\n                 + sum((plot,till,intens,curInputs(syntFertilizer),m)$c_p_t_i(curCrops,plot,till,intens),\n                     p_PLossFert(\"low\") * v_syntDist(crops,plot,till,intens,syntFertilizer,t,nCur,m) * p_nutInSynt(syntFertilizer,\"P\"))  )\n      ]$sum(grasCrops(crops)$sameas(crops,grascrops),1)\n$$endif.ch\n*    --- loss through runoff arable land\n\n      +[ sum((plot,till,intens)$c_p_t_i(curCrops,plot,till,intens), p_PLossRun(\"arable\") * p_soilFactRun * p_PSoilClass * p_slopeFactor * v_cropHa(curCrops,plot,till,intens,t,nCur) )\n\n         + p_PLossRun(\"arable\") * p_soilFactRun * p_PSoilClass * p_slopeFactor *  (\n\n            $$iftheni.man %manure% == true\n              sum((plot,till,intens,manApplicType_manType(manApplicType,curMantype),m) $(c_p_t_i(curCrops,plot,till,intens)$(not sameas (ManApplicType,\"applSolidSpread\"))),\n                 p_PLossFert(\"high\") * v_manDist(crops,plot,till,intens,ManApplicType,curManType,t,nCur,m) * sum((manChain),p_nut2inMan(\"P\",curManType,manChain)))\n\n            + sum((plot,till,intens,manApplicType_manType(manApplicType,curMantype),m) $(c_p_t_i(curCrops,plot,till,intens) $sameas (ManApplicType,\"applSolidSpread\")),\n                 p_PLossFert(\"medium\") * v_manDist(crops,plot,till,intens,ManApplicType,curManType,t,nCur,m) * sum((manChain),p_nut2inMan(\"P\",curManType,manChain)))\n            $$endif.man\n            + sum((plot,till,intens,syntFertilizer,m)$c_p_t_i(curCrops,plot,till,intens),\n                 p_PLossFert(\"low\") * v_syntDist(crops,plot,till,intens,syntFertilizer,t,nCur,m) * p_nutInSynt(syntFertilizer,\"P\"))  )\n       ]$sum(arabCrops(crops)$sameas(crops,arabcrops),1)\n  ;\n\n  lossphos_(t_n(t,nCur))  $ (tCur(t) $ envAcc) ..\n\n          v_lossphos(t,nCur) =e= Sum(curCrops$ ( not (sameas(curCrops,\"idle\") or sameas (curCrops,\"idlegras\"))), v_lossphosCrops(curCrops,t,nCur));\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/EnvironmentalAccounting/environmental_accounting/#humus-balance","title":"Humus Balance","text":"<p>Humus balancing is a methodology often applied by practitioners to assess management effects on Soil Organic Matter (SOM). Most tools are designed for farmers in order to maintain SOM levels that sustain high yield levels. As a consequence, these methods, from a methodological point of view, cannot quantify SOM changes but rather assess the relative impact of different management scenarios. To counteract those shortcomings, the inclusion of side specific data, can improve the prediction accuracy (Brock 2016).</p> <p>This module applies the balancing method from Ebertseder et al. (2014). The change in soil carbon, is calculated through the C removal through harvesting of the grown plants,the  C input from humification of incorporated crop residues, the removal of C through the harvest of crop residues, and the C input through organic fertilisation.</p> <pre><code>*   ---   Humus balance according to VDLUFA(2010) only for arable\n*\n\n  humBalCrops_(curCrops(arabCrops),t_n(t,nCur))  $ (tCur(t) $ envAcc) ..\n\n          v_humBalCrops(arabCrops,t,nCur) =e=\n\n*  ---  C removal thorugh harvested products\n\n                        - sum((plot,till,intens)$c_p_t_i(curCrops,plot,till,intens), v_cropHa(arabCrops,plot,till,intens,t,nCur) * p_humCrop(arabCrops) )\n\n*  --- Additional humification if crop residues are incorporated\n\n                        + sum( (plot,till,intens) $c_p_t_i(curCrops,plot,till,intens),  (v_cropHa(arabCrops,plot,till,intens,t,nCur) -v_residuesRemoval(arabCrops,plot,till,intens,t,nCur))\n                               * sum( (plot_soil(plot,soil)),  p_resiCrop(arabCrops,soil,till,intens,t)) * p_resiInc(arabCrops))\n\n*  ---  Deduction for straw removal\n\n                        - sum( (plot,till,intens) $ (cropsResidueRemo(arabCrops)$c_p_t_i(curCrops,plot,till,intens)),  v_residuesRemoval(arabCrops,plot,till,intens,t,nCur)\n                               * sum( (plot_soil(plot,soil),curProds), 10 * p_OCoeffResidues(arabCrops,soil,till,intens,curProds,t)) * p_resiInc(arabCrops))\n\n* --- Addition through organic fertilizer inputs\n\n$$iftheni.man %manure% == true\n   + sum((plot,till,intens,manApplicType_manType(manApplicType,curMantype),m)$c_p_t_i(curCrops,plot,till,intens),\n                                         v_manDist(arabCrops,plot,till,intens,ManApplicType,curManType,t,nCur,m) * p_humfact(ManApplicType) )\n$endif.man\n;\n   humBal_(t_n(t,nCur))  $ (tCur(t) $ envAcc) ..\n\n           v_humBal(t,nCur) =e= Sum(curCrops(arabCrops), v_humBalCrops(arabCrops,t,nCur));\n</code></pre> <p>To ease the calculation of the emissions along the N mass flow N-emissions are calculated according to their N-weight. The equation emissionsMass_ converts the weight into the actual mass of the molecule as a preliminary step for further calculations, characterisations and weightings.</p> <pre><code>*  --- Calculation of actual weight of N-emissions in kg NH3, N2O, NO and N2 per month\n*\n    emissionsMass_(chain_source(curChain,source),emissions,t_n(t,nCur)) $ (tCur(t) $ source_emissions(source,emissions)  $ envAcc  )   ..\n\n         v_emissionsMass(curChain,source,emissions,t,nCur)  =e=\n\n                       v_emissions(curchain,source,emissions,t,nCur) * p_corMass(emissions)\n        ;\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/EnvironmentalAccounting/environmental_accounting/#impact-assessment","title":"Impact Assessment","text":"<p>The impact assessment phase of a LCA typically involves assigning the inventory data to impact categories, the modelling of the inventory data within impact categories and, in specific cases, the aggregation of results. For the impact assessment, we use the ReCiPe method for impact assessment at mid-point level (Huijbregts et al. 2016). The yearly aggregated emissions from the inventory analysis are related to the impact categories via characterization factors that transform the emissions into impact scores. The categorized emissions are summarized in the variable v_emissionsCat. The categorization is conducted using the characterization factors p_emCat and the yearly emissions, v_emissionsYear.</p> <pre><code>* --- Different emissions and sources per year, includes calculation of soil surface balance and N leaching\n*     since monthly values do not make sense\n*\n\n  emissionsYear_(chain_source(curChain,source),emissions,t_n(t,nCur)) $ (tCur(t) $ source_emissions(source,emissions)  $ envAcc  )  ..\n\n    v_emissionsYear(curChain,source,emissions,t,nCur)\n        =e=  v_emissionsMass(curChain,source,emissions,t,nCur)\n\n\n            +   (v_leach(t,nCur) * p_corMass(\"NO3\"))  $ ( sameas(emissions,\"NO3\") $ sameas(source,\"field\") )\n*    --- Calculation of indirect N2O emissions based on leached N based on Haenel et al. (2018) , p. 365 and IPCC (2006) Table 11.24 table 11.3)\n\n            + [ v_leach(t,nCur) * p_EFN2OindLeach * p_corMass(\"N2Oind\")] $ ( sameas(emissions,\"N2Oind\") $ sameas(source,\"field\") )\n\n\n            +   v_lossPhos(t,nCur)   $ ( sameas(emissions,\"P\") $ sameas(source,\"field\") )  ;\n*\n*  --- Characterization of emission via ReCiPe 2016 in kg eq per year\n*\n   emissionsCat_(chain_source(curChain,source),emCat,t_n(t,nCur))$ (tCur(t) $ t_n(t,nCur) $ envAcc )..\n\n       v_emissionsCat(curChain,source,emCat,t,ncur)  =e=\n                     sum(source_emissions(source,emissions),\n                           v_emissionsYear(curChain,source,emissions,t,nCur)  *  p_emCat(emCat,emissions));\n</code></pre> <p>Buendia, Eduardo; Tanabe, Kiyoto; Kranjc, Andrej; Jamsranjav, Baasansuren; Fukuda, Maya; Ngarize, Sekai et al. (2019): 2019 Refinement to the 2006 IPCC Guidelines for National Greenhouse Gas Inventories. Available online at https://www.ipcc-nggip.iges.or.jp/public/2019rf/index.html.</p> <p>Brock, C.; Oltmanns, M.; Leithold, G. (2016): What do humus balances really tell about soil organic matter?. Acta Fytotechnica et Zootechnica, 18(5), 50-52.</p> <p>Dong, H.; Mangino, J.; McAllister, T. A. (2006): EMISSIONS FROM LIVESTOCK AND MANURE MANAGEMENT. In IPCC (Ed.): 2006 IPCC Guidelines for national Greenhouse Gas Inventories, pp. 10.1-10.87.</p> <p>Ebertseder, Engels, Heyn, Reinhold, Brock, F\u00fcrstenfeld, H\u00fclsbergen, Isermann, Kolbe, Leithold, Schmid, Schweitzer, Willms, Zimme (2014). Humusbilanzierung - Eine Methode zur Analyse und Bewertung der Humusversorgung von Ackerland. Bonn: VDLUFA.</p> <p>EEA (2013): EMEP/EEA air pollutant emission inventory guidebook 2013. Technical guidance to prepare national emission inventories Eur. Environ. Agency, Tech. Rep. 12.</p> <p>EEA (2016): EMEP/EEA air pollutant emission inventory guidebook 2016. Technical guidance to prepare national emission inventories Eur. Environ. Agency, Tech. Rep. 21.</p> <p>Haenel, H. D., R\u00f6semann, C., D\u00e4mmgen, U., D\u00f6ring, U., Wulf, S., Eurich-Menden, B., ... &amp; Osterburg, B. (2018). Calculations of gaseous and particulate emissions from German agriculture 1990-2016: Report on methods and data (RMD) Submission 2018 (No. 57). Th\u00fcnen Report.</p> <p>Huijbregts, Mark A. J.; Steinmann, Zoran J. N.; Elshout, Pieter M. F.; Stam, Gea; Verones, Francesca; Vieira, Marisa et al. (2017): ReCiPe2016: a harmonised life cycle impact assessment method at midpoint and endpoint level. In Int J Life Cycle Assess 22 (2), pp. 138\u2013147. DOI: 10.1007/s11367-016-1246-y.</p> <p>Klein, C. de; Novoa, R.S.A.; Ogle, S.; Smith, K. A.; Rochette, P.; Wirth, T. C. (2006): N2O EMISSIONS FROM MANAGED SOILS, AND CO2 EMISSIONS FROM LIME AND UREA APPLICATION. In IPCC (Ed.): 2006 IPCC Guidelines for national Greenhouse Gas Inventories, pp. 11.1-11.54.</p> <p>Prasuhn, Volker (2006): Erfassung der PO4-Austr\u00e4ge f\u00fcr die \u00d6kobilanzierung. In Salca-Phosphor. Agroscope, Switzerland.</p> <p>Richner, W.; Oberholzer, H. R.; Freiermuth Knuchel, R.; Huguenin, O.; Ott, S.; Nemecek, T.; Walther, U. (2014): Modell zur Beurteilung der Nitratauswaschung in \u00d6kobilanzen\u2010SALCA-NO3. Version 2.</p> <p>R\u00f6semann, C.; Haenel, H.-D.; D\u00e4mmgen, U.; Freibauer, A.; Wulf, S.; Eurich-Menden, B. et al. (2015): Berechnung von gas- und partikelf\u00f6rmigen Emissionen aus der deutschen Landwirtschaft 1990 - 2013. Report zu Methoden und Daten (RMD) Berichterstattung 2015. Johann Heinrich von Th\u00fcnen-Institut. Braunschweig (Th\u00fcnen Report, 27).</p> <p>Walther, U., Rieser, J. P.; Fliesch, R. (2001): \"Grundlagen f\u00fcr die D\u00fcngung im Futter-und Ackerbau (GRUDAF).\" FAL Agroscope Reckenholz. Z\u00fcrich.</p> <p>Wernet, Gregor; Bauer, Christian; Steubing, Bernhard; Reinhard, J\u00fcrgen; Moreno-Ruiz, Emilia; Weidema, Bo (2016): The ecoinvent database version 3 (part I): overview and methodology. In: Int J Life Cycle Assess 21 (9), S. 1218-1230. DOI: 10.1007/s11367-016-1087-8.</p> <p>World Health Organization. (2003). Health aspects of air pollution with particulate matter, ozone and nitrogen dioxide: report on a WHO working group, Bonn, Germany 13-15 January 2003 (No. EUR/03/5042688). Copenhagen: WHO Regional Office for Europe.</p>"},{"location":"FarmDynDocumentation/ModelDescription/PolicyMeasures/AES/","title":"Agri-Environmental Schemes","text":"<p>Agri-environmental schemes (AES) are optional measures for farmers under the European Agricultural Fund for Rural Development as part of the Common Agricultural Policy. The specific design of the measures differs by member state or even at regional level. AES are introduced in FarmDyn in a modular structure, allowing the inclusion of case study specific measures and data. In the following, the measures of the German Federal State of North Rhine-Westphalia are presented, reflecting the prolonged funding period 2014 to 2020.</p> <p>Sets and equations can be found in the file model\\aes_module_DE.gms, corresponding parameter values and the definition of specific sets are listed in dat\\aes_de_nrw_2020.gms. The equations are organized in line with existing measures.</p> <p>To receive funding for a diverse crop rotation, minimum number of crops have to be grown on a farm and minimum and maximum crop shares of certain crops must be present. Binary triggers are introduced to capture all requirements, as for example for the obligation that every crop is not allowed to cover more than a maximum share of arable land. The binary trigger, v_triggerAes equals one if the crop share is above maximum allowed share of arable land for a single crop.</p> <pre><code>triggerDivRotMaxcrop_(curCrops(arabCrops),t_n(tCur,nCur)) $ ( (not sameas(arabCrops,\"idle\")) $ (not catchcrops(arabCrops))  )..\n\n        sum( c_p_t_i(arabcrops,plot,till,intens), v_cropHa(arabcrops,plot,till,intens,tCur,nCur))\n          -  v_triggerAes(\"DivRotMaxcrop\",arabcrops,tCur,nCur) * p_nArabLand  =l=  p_nArabLand * p_DivRotMax;\n</code></pre> <p>Following the same concept, equations with binary triggers are needed for other requirements of the diverse crop rotation. Finally, all binary triggers are transferred into a single summary trigger. If one of the triggers is equal one, the summary trigger also has to be one and no payments are realized. This ensures that the payment only takes place if all requirements are fulfilled.</p> <pre><code>sumTriggerDivRot_(t_n(tCur,nCur)) ..\n\n    v_triggerAes(\"SumDivRot\",\"\",tCur,nCur) * 4  =g=   v_triggerAes(\"DivRotMax\",\"\",tCur,nCur)\n                                                    + v_triggerAes(\"DivRotNum\",\"\",tCur,nCur)\n                                                    + v_triggerAes(\"DivRotCropGroupMaxSingleT\",\"\",tCur,nCur)\n                                                    + v_triggerAes(\"DivRotCropGroupMinSingleT\",\"\",tCur,nCur);\n</code></pre> <p>In the following equation, the payment for the diverse crop rotation is calculated. If the summary trigger equals one, the requirements are not fulfilled and the payment is zero.</p> <pre><code>aesPremDivRot_(t_n(tCur,nCur))  ..\n\n    v_aesPremSchemes(\"DivRot\",tCur,nCur)  =e=  p_nArabLand  *  p_aesPayDiVRot  *  ( 1 - v_triggerAes(\"sumDivRot\",\"\",tCur,nCur)) ;\n</code></pre> <p>Flower strips and areas are another common measure of AES. The only restriction is that flower strips are not allowed to exceed a certain share of the arable land.</p> <pre><code>FloStrMaxArabLand_(t_n(tCur,nCur)) ..\n\n    sum(c_p_t_i(curCrops(flowerStrips),plot,till,intens), v_cropHa(flowerStrips,plot,till,intens,tCur,nCur)  )\n                =l= p_maxFloStr * p_nArabLand ;\n</code></pre> <p>In the following equation, the payments for flower strips and areas are summarized. Payments are linked to the size for different flower strips and areas, represented by the variable v_cropha.</p> <pre><code>aesPremFloStr_(t_n(tCur,nCur))  ..\n\n    v_aesPremSchemes(\"FlowerStrips\",tCur,nCur) =e= sum(c_p_t_i(curCrops(flowerStrips),plot,till,intens),\n\n                                                        v_cropHa(flowerStrips,plot,till,intens,tCur,nCur) *  p_aesPayFlowerStrips(flowerStrips)  )   ;\n</code></pre> <p>The catch crop cultivation during winter as another measure is only relevant in areas of the Water Framework Directive. Please note that this voluntary measure is not in place anymore as catch crop cultivation in nitrate polluted areas is obligatory under the Fertilization Ordinance 2020. To receive payments, minimum and maximum shares of catch crops have to be grown. As the equation for the minimum area exemplary illustrates, the binary trigger turns 0 if the required area is not present.</p> <pre><code>CCMinAES_(t_n(tCur,nCur))  ..\n\n    sum(c_p_t_i(curCrops(aesCatchCrops),plot,till,intens), v_cropHa(aesCatchCrops,plot,till,intens,tCur,nCur) )\n\n                 =g=      p_ShareLandWFD *  p_CCMinAES * p_nArabLand   *  v_TriggerAes(\"ShareCC\",\"\",tCur,nCur);\n</code></pre> <p>The payments for catch crops under the AES are then calculated in the following equation.</p> <pre><code>aesPremCC_(t_n(tCur,nCur))  ..\n\n    v_aesPremSchemes(\"CatchCropsAES\",tCur,nCur) =e=  sum(c_p_t_i(curCrops(aesCatchCrops),plot,till,intens),\n\n                                                        v_cropHa(aesCatchCrops,plot,till,intens,tCur,nCur) * p_aesPayCC(curcrops)  )    ;\n</code></pre> <p>In addition, strips along surface waters are supported under AES. The length of boarders between farm land and surface waters has to be defined via the graphical user interface. The strips have to be in a predefined range of width, which is covered in two equations. The following equations exemplary illustrates how the minimum width is ensured.</p> <pre><code>SSWMinAES_(t_n(tCur,nCur))  ..\n\n    sum(c_p_t_i(curcrops(waterStrips),plot,till,intens), v_cropHa(waterStrips,plot,till,intens,tCur,nCur) )\n\n                =g=     ( p_LandAlongSurfaceWaters *  p_SSWMinWidthAES  /10000 )        *  v_triggerAes(\"AreaSSW\",\"\",tCur,nCur)  ;\n</code></pre> <p>The payments for strips along surface waters are the calculated in the following equation.</p> <pre><code>aesPremSSW_(t_n(tCur,nCur))  ..\n\n    v_aesPremSchemes(\"StripsWaterAES\",tCur,nCur) =e= sum(c_p_t_i(curCrops(waterStrips),plot,till,intens),\n\n                                                          v_cropHa(waterStrips,plot,till,intens,tCur,nCur) * p_aesPaySSW(waterStrips) );\n</code></pre> <p>Finally, the payments for the different measures of the AES are summarized.</p> <pre><code>aesPrem_(t_n(tCur,nCur))  ..\n\n    v_aesPrem(tCur,nCur) =e= sum(aesSchemes, v_aesPremSchemes(aesSchemes,tCur,nCur) );\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/PolicyMeasures/CAP_firstPillar/","title":"CAP - First pillar payments","text":"<p>The current implementation of the CAP First Pillar measures in FarmDyn accounts only for the base payment and the payments related to greening, which are presented in the following.</p>"},{"location":"FarmDynDocumentation/ModelDescription/PolicyMeasures/CAP_firstPillar/#base-payments","title":"Base payments","text":"<p>As the de-coupled payments are related to the on-farm land, you can find them under the header \"Land endowment\" in the GUI as seen in the following figure.</p> <p> Figure 1: Decoupled payments in GUI Source: Own illustration</p>"},{"location":"FarmDynDocumentation/ModelDescription/PolicyMeasures/CAP_firstPillar/#greening-programme","title":"Greening Programme","text":"<p>Starting in 2013, subsidies stemming from the Common Agricultural Policy by the European Commission were linked to more environmental friendly farming practices, the so called \"greening\". In this small section, we present shortly the greening measures and their implementation in the model.</p> <p>The greening measures can be summarised in three broad categories:</p> <p>1. Crop diversification</p> <p>2. Preservation of permanent grassland</p> <p>3. Designation of ecological focus areas (EFA)</p> <p>This section covers the crop diversification and designation of EFA measures. The allocation of land to grassland or arable land is exogenous in FarmDyn. Therefore, covering the conversion of grassland to arable land is not possible within the model and will not be further discussed in the documentation.</p>"},{"location":"FarmDynDocumentation/ModelDescription/PolicyMeasures/CAP_firstPillar/#crop-diversification","title":"Crop Diversification","text":"<p>Crop diversification mandates farmers to cultivate multiple crops from different crop groups within a season. The required share of each crop group in the diversification scheme is dependent on the total arable and grassland as well as on their relative share of agricultural land on-farm. The triggering size classes are captured by binary variables in the equation trigger10ha_ and trigger30ha_.</p> <p>The trigger10Ha_ tests if the arable land on farm is less than 10 ha, as it won't trigger any greening measures. Farms with more than 10 ha and less than 30 ha arable land have a crop diversification obligation where the most planted crop group is not allowed to exceed 75% of the arable land. Consequently, they have to cultivate at least 2 crops. This is shown in equation green75_.   </p> <pre><code>trigger10Ha_(t_n(tCur(t),nCur)) ..\n   sum((plot_landType(plot,\"arab\"),sys) $ p_plotSize(plot),v_croppedPlotLand(plot,sys,t,nCur))\n         - (v_triggerGreening(\"10ha\",tCur,nCur) * p_M) =l= 10;\n</code></pre> <pre><code>green75_(cropGroups,t_n(tCur(t),nCur))\n            $ (sum(c_p_t_i(curCrops(crops),plot,till,intens) $ (plot_landType(plot,\"arab\")  $ (not grassCrops(crops))\n                 $ p_cropGroups_to_crops(cropGroups,crops)),1)) ..\n\n  v_haCropGroups(cropGroups,tCur,nCur)\n     =l=    sum((plot_landType(plot,\"arab\"),sys),v_croppedPlotLand(plot,sys,t,nCur)) *0.75\n              + ((1 - v_triggerGreening(\"10ha\",tCur,nCur)) * p_M)\n              + ((1 - v_triggerGreening(\"Idle\",tCur,nCur)) * p_M)\n              + ((1 - v_triggerGreening(\"Gras\",tCur,nCur)) * p_M)\n;\n</code></pre> <p>The trigger30Ha_ tests if the arable land on farm is more than 30 ha. Farms with more than 30 ha arable land have a crop diversification requirement where the sum of the two largest crop group shares is not allowed to exceed 95% of the total arable land, see green95_. This results in at least 3 different crops simultaneously cultivated in a planting season.</p> <pre><code>trigger30Ha_(t_n(tCur(t),nCur)) ..\n   sum((plot_landType(plot,\"arab\"),sys) $ p_plotSize(plot),v_croppedPlotLand(plot,sys,t,nCur))\n    - (v_triggerGreening(\"30ha\",tCur,nCur) * p_M) =l= 30;\n</code></pre> <pre><code>green95_(cropGroups,cropGroups1,t_n(tCur(t),nCur))\n               $ (   sum(c_p_t_i(curCrops(crops),plot,till,intens) $ (plot_landType(plot,\"arab\")  $ (not grassCrops(crops))\n                        $ p_cropGroups_to_crops(cropGroups,crops)),1)\n\n                   $ sum(c_p_t_i(curCrops(crops),plot,till,intens) $ (plot_landType(plot,\"arab\")  $ (not grassCrops(crops))\n                        $ p_cropGroups_to_crops(cropGroups1,crops)),1)\n\n                   $ (not sameas(cropGroups,cropGroups1)) ) ..\n\n     v_haCropGroups(cropGroups,tCur,nCur) +  v_haCropGroups(cropGroups1,tCur,nCur)\n\n        =l= sum((plot_landType(plot,\"arab\"),sys),v_croppedPlotLand(plot,sys,t,nCur))*0.95\n               + ((1 - v_triggerGreening(\"30ha\",tCur,nCur)) * p_M)\n               + ((1 - v_triggerGreening(\"Idle\",tCur,nCur)) * p_M)\n               + ((1 - v_triggerGreening(\"Gras\",tCur,nCur)) * p_M);\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/PolicyMeasures/CAP_firstPillar/#designation-of-ecological-focus-areas","title":"Designation of Ecological Focus Areas","text":"<p>The designation of ecological focus areas (EFA) affects only farmers with more than 15 ha of arable land (v_croppedPlotLand in trigger15Ha_), who have to ensure that a minimum of 5% of their arable land is managed as an EFA (efa_). Each member state offers a list of potential candidates for EFA such as buffer strips, group of trees, fallow land, and catch crops/ nitrogen fixing crops, whereas each type of EFA has a different weighting factor (p_efa) in the calculation of the total EFA area. For example, catch crops and nitrogen fixing crops have a weighting of 0.3, so that for each hectare planted on arable land they account for only 0.3 ha to the required minimum of 5% arable land share.</p> <pre><code>trigger15Ha_(t_n(tCur(t),nCur)) ..\n  sum((plot_landType(plot,\"arab\"),sys) $ p_plotSize(plot),v_croppedPlotLand(plot,sys,t,nCur))\n               - (v_triggerGreening(\"15ha\",tCur,nCur) * p_M) =l= 15;\n</code></pre> <pre><code> efa_(t_n(tCur(t),nCur)) ..\n\n   sum(plot_landType(plot,\"arab\") $ p_plotSize(plot),\n           sum(sys,v_croppedPlotLand(plot,sys,t,nCur))) * 0.05\n         =l=\n\n    sum(c_p_t_i(curCrops(crops),plot,till,intens) $ plot_landType(plot,\"arab\"),\n          v_cropHa(crops,plot,till,intens,tCur,nCur)*p_efa(crops))\n*\n*  --- if one or several of these triggers is active, the EFA condition\n*      cannot be binding\n*\n              + ((1 - v_triggerGreening(\"15ha\",tCur,nCur)) * p_M)\n              + ((1 - v_triggerGreening(\"Idle\",tCur,nCur)) * p_M)\n              + ((1 - v_triggerGreening(\"Gras\",tCur,nCur)) * p_M)\n ;\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/PolicyMeasures/CAP_firstPillar/#grass-land-exemptions","title":"Grass Land Exemptions","text":"<p>The presented requirements for crop diversification and EFA have exemptions for farms with a high share of grass land and/ or fallow lying land as long as the arable land does not exceed 30 ha (triggerRestlandGras_ and triggerRestlandIdle_). If the share of permanent/ rotational grass land or idle land on the total land is more than 75% and consequently the arable land is less than 25% (triggerGras75_, triggerIdle75_), the farm does not have to comply with any of the above measures (crop diversification and EFA) to receive the greening premium.</p> <p>The following equations show this conditional for the case of grass land.</p> <pre><code>triggerGras75_(t_n(tCur(t),nCur)) ..\n   sum((plot,sys) $ p_plotSize(plot),v_croppedPlotLand(plot,sys,t,nCur))\n    - v_triggerGreening(\"Gras\",tCur,nCur) * p_M =l=\n             sum(c_p_t_i(curCrops(grasCrops),plot,till,intens),\n                  v_cropHa(grasCrops,plot,till,intens,tCur,nCur))/0.75;\n</code></pre> <pre><code>triggerRestlandGras_(t_n(tCur(t),nCur)) ..\n    sum((plot,sys) $ p_plotSize(plot),v_croppedPlotLand(plot,sys,t,nCur))\n  - sum(c_p_t_i(curCrops(grasCrops),plot,till,intens), v_cropHa(grasCrops,plot,till,intens,tCur,nCur))\n   - (v_triggerGreening(\"Gras\",tCur,nCur) * p_M) =l= 30\n;\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/PolicyMeasures/abstract_policy_measures/","title":"Abstract Policy Measures","text":"<p>Farmdyn covers a wide variety of agri- and agri-environmental policies. This includes the first pillar of the most recent CAP (currently under construction), agri-environmental schemes, and the German implementation of the Nitrate Directive. It further models country specific policies for non-EU countries such as Switzerland and Norway.</p>"},{"location":"FarmDynDocumentation/ModelDescription/PolicyMeasures/fertilisation_ordinance/","title":"Fertilisation Ordinance","text":"<p>The German Fertilisation Ordinance implements the EU Nitrates Directive in Germany together with other environmental regulations. It consists of numerous measures which prescribe how farmers are allowed to use nutrients from manure and chemical fertiliser along with further management specifications. The most prominent measures of the Fertilisation Ordinance are included in FarmDyn, being (1) nutrient balance restrictions, (2) an organic nitrogen application threshold, (3) binding fertiliser planning, (4) required manure storage capacities, (5) banning periods for fertiliser application, (6) restriction of fertiliser application in autumn, (7) low-emission manure application techniques, (8) obligatory catch crop cultivation.</p> <p>The equations regarding the Fertilisation Ordinance are mainly found in the Fertilisation Ordinance module (gams\\model\\fertord_module_DE.gms). Measures with regard to the storage capacity are partly found in the Manure module (gams\\model\\manure_module.gms). FarmDyn is used to asses the revision of the Fertilisation Ordinance in 2020. Therefore, the Ordinance from 2007, 2017 and 2020 can be directly selected in the Graphical User Interface (GUI) to activate the corresponding measures. In addition thresholds and requirements can be modified separately in the GUI.</p>"},{"location":"FarmDynDocumentation/ModelDescription/PolicyMeasures/fertilisation_ordinance/#nutrient-balance-restrictions","title":"Nutrient Balance Restrictions","text":"<p>The German Fertilisation Ordinance requires that farms calculate a nutrient balance on an annual basis for nitrogen and phosphate (D\u00fcV 2007, D\u00fcV 2017). This balance combines nutrient inputs via manure and synthetic fertiliser with nutrient removal via the harvested crops. The surplus, i.e. the balance, is not allowed to exceed a certain threshold.</p> <p>Nutrient removal via harvested product is calculated depending on its yield level and nutrient content. The main harvested product, as well as straw from cereal production which can be sold in FarmDyn are covered.</p> <pre><code>nutRemovalDuev_(nut,tCur(t),nCur) $ t_n(t,nCur) ..\n\n       v_nutRemovalDuev(nut,t,nCur)\n             =e=\n\n                sum( (c_p_t_i(curCrops,plot,till,intens)), v_cropHa(curCrops,plot,till,intens,t,nCur)\n                            * sum( (plot_soil(plot,soil),curProds) $  p_OCoeffC%l%(curCrops,soil,till,intens,curProds,t),\n                                                        p_OCoeffC(curCrops,soil,till,intens,curProds,t)/p_storageLoss(curCrops)\n                                     * (  p_nutContent(curCrops,curProds,\"conv\",nut) $ (not sameas(till,\"org\"))\n                                        + p_nutContent(curCrops,curProds,\"org\",nut)  $      sameas(till,\"org\"))\n                                     *10 )   )\n\n               +   sum( (c_p_t_i(curCrops,plot,till,intens)) $ cropsResidueRemo(curCrops),  v_residuesRemoval(curCrops,plot,till,intens,t,nCur)\n                          *sum( (plot_soil(plot,soil),curProds),  p_OCoeffResidues(curCrops,soil,till,intens,curProds,t)\n                                     *  (  p_nutContent(curCrops,curProds,\"conv\",nut)$ (not sameas(till,\"org\"))\n                                         + p_nutContent(curCrops,curProds,\"org\",nut) $      sameas(till,\"org\"))\n                                          * 10  )  )\n\n                                                                      ;\n</code></pre> <p>Nutrient input via synthetic fertiliser is calculated.</p> <pre><code>synthAppliedDueV_(nut,tCur(t),nCur)  $ t_n(t,nCur)..\n\n           v_synthAppliedDueV(nut,t,nCur)    =e=\n\n                              sum( (c_p_t_i(curCrops(crops),plot,till,intens),curInputs(syntFertilizer),m),\n                                 v_syntDist(crops,plot,till,intens,syntFertilizer,t,nCur,m)\n                                           * p_nutInSynt(syntFertilizer,nut) )      ;\n</code></pre> <p>Input via animal manure is calculated.</p> <pre><code>nutExcrDueV_(nut,nType,tCur(t),nCur)  $ t_n(t,nCur)..\n\n       v_nutExcrDuev(nut,nType,t,nCur) =e=\n\n           sum((actHerds(possHerds,breeds,feedRegime,t,m)) $ (\n                               $$ifi defined cattle               (cattle(possHerds)  and sameas(nType,\"cattle\")) or\n                               $$ifi defined pigherds             (pigHerds(possHerds) and sameas(nType,\"pig\"))\n                               $$ifi not defined pigherds         ( 1 eq 2)\n                                                               ),\n                v_herdSize(possHerds,breeds,feedRegime,t,nCur,m)\n\n                             * ( 1 - 1   $ sameas(feedRegime,\"fullGraz\")\n                                   - 0.5 $ sameas(feedRegime,\"partGraz\"))\n\n                              * 1/card(m)   *  p_nutExcreDueV(possHerds,feedRegime,nut) );\n</code></pre> <p>Input via digestates from biogas production is calculated (only digestate from plant origin as for instance silage maize).</p> <pre><code>nutBiogasDuev_(nut,tCur(t),nCur)  $ t_n(t,nCur)..\n\n          v_nutBiogasDuev(nut,t,nCur) =e=\n\n                sum( (curmanchain, m,nut2) $ (not sameas (nut2,\"P\")),\n                    v_nutCropBiogasM(curmanchain,nut2,t,nCur,m)   + sum(curmaM, v_nut2ManurePurch(curmanchain,nut2,curmaM,t,nCur,m) ))  $ (sameas (nut,\"N\") $ sum(sameas(manchain,\"LiquidBiogas\"),1))\n\n                     +  sum( (curmanchain,m) , v_nutCropBiogasM(curmanchain,\"P\",t,nCur,m) + sum(curmaM, v_nut2ManurePurch(curmanchain,\"P\",curmaM,t,nCur,m))) $ (sameas (nut,\"P\")  $ sum(sameas(manchain,\"LiquidBiogas\"),1))\n              ;\n</code></pre> <p>In the equation nutBalDuev_, nutrient inputs and outputs are combined. Manure nitrogen is accounted with factors defined by the Fertilisation Ordinance. As a supplement to nutrient inputs and outputs, the import and export of manure nutrients are included into the equation.</p> <pre><code>nutBalDueV_(nut,tCur(t),nCur) $ t_n(t,nCur) ..\n\n   v_surplusDueV(t,nCur,nut)\n\n         =e=\n\n*   --- Nutrients excreted from animals in stable time specific loss factor\n\n    $$ifi %herd% == true      sum(nType,v_nutExcrDuev(nut,nType,t,nCur))  *  p_nutEffectivDueVNv(nut)\n\n*   --- Nutrients excreted during grazing\n\n    $$iftheni.cattle \"%cattle%\" == \"true\"\n\n            +  sum(m $(  sum(grasscrops $(p_grazMonth(grassCrops,m)&gt;0),1)\n                       $ sum(actHerds(possHerds,breeds,grazRegime,t,m),1) ),\n                  v_nutExcrPast(nut,t,nCur,m)    *  p_nutEffectivDueVNv(nut))\n\n    $$endif.cattle\n\n*  --- Nutrients coming from biogas plant (including energy crops and purchased manure)\n\n    $$ifi %biogas% == true + v_nutBiogasDuev(nut,t,nCur)  *  p_nutEffectivDueVNvBiogas(nut)\n\n*  --- Applied synthetic fertilizer\n\n         + v_synthAppliedDueV(nut,t,nCur)\n\n*  --- Nutrient from N fixation from legumes in grassland\n         + sum(  (c_p_t_i(crops,plot,till,intens)) ,\n                   v_cropHa(crops,plot,till,intens,t,nCur) *   (   p_NfromLegumes(Crops,\"org\")   $ sameas(till,\"org\")\n                                                                +  p_NfromLegumes(Crops,\"conv\")  $ (not sameas(till,\"org\"))\n                                                                ))       $ (sameas (nut,\"N\") )\n      $$iftheni.data \"%database%\" == \"KTBL_database\"\n*\n*     --- Nutrient from vegetables\n*\n         + sum(  (c_p_t_i(crops,plot,till,intens)) ,\n                   v_cropHa(crops,plot,till,intens,t,nCur) *   (   p_NfromVegetables(Crops))\n                                                                )       $ (sameas (nut,\"N\") )\n      $$endif.data\n*\n* --- Import of manure\n*\n       $$iftheni.im \"%AllowManureImport%\" == \"true\"\n\n         +   sum ( (nut2_nut(nut2,nut),m),   v_manImport(t,nCur,m) *    p_nut2inMan(nut2,\"manImport\",\"LiquidImport\") )   * (1- (p_nutEffectivDueVAl(\"import\") - p_nutEffectivDueVNv(\"N\") ))   $ sameas (nut,\"N\")\n         +   sum ( (nut2_nut(nut2,nut),m),   v_manImport(t,nCur,m) *    p_nut2inMan(nut2,\"manImport\",\"LiquidImport\") )      $ sameas (nut,\"P\")\n\n       $$endif.im\n\n*  --- Crop output (nutrient removal)\n\n         -   v_NutRemovalDuev(nut,t,nCur)\n\n$iftheni.h %herd% == true\n\n*   --- Nutrients exported from farm\n\n      $$iftheni.ExMan %AllowManureExport%==true\n\n        -  sum( (curManChain,m,nut2) $(not sameas (nut2,\"P\")), v_nut2export(curManChain,nut2,t,nCur,m) )   $ sameas (nut,\"N\")\n        -  sum( (curManChain,m), v_nut2export(curManChain,\"P\",t,nCur,m) )                                 $ sameas (nut,\"P\")\n\n      $$endif.ExMan\n\n      $$iftheni.emissionRight not \"%emissionRight%\"==0\n\n        -  sum( (curManChain,m,nut2) $(not sameas (nut2,\"P\")), v_nut2exportMER(curManChain,nut2,t,nCur,m) )  $ sameas (nut,\"N\")\n        -  sum( (curManChain,m),                               v_nut2exportMER(curManChain,\"P\",t,nCur,m) )   $ sameas (nut,\"P\")\n\n      $$endif.emissionRight\n\n$endif.h\n      ;\n</code></pre> <p>The surplus, v_surplusDueV, is not allowed to exceed a certain threshold, which changes from Fertilisation Ordinance 2007 to 2017. Under the Fertilisation Ordinance 2020, this restriction is not in place anymore.</p> <pre><code>nutSurplusDueVRestr_ (tCur(t),nCur,nut)   $ (p_surPlusDueVMax(t,nut) $ t_n(t,nCur))  ..\n\n       v_surplusDueV(t,nCur,nut)\n\n         =L=  p_surplusDueVMax(t,nut) * v_croplandActive(t,nCur) *  ( 1 - p_soilShareNutEnriched $ sameas (nut,\"P\"));\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/PolicyMeasures/fertilisation_ordinance/#organic-nitrogen-application-threshold","title":"Organic Nitrogen Application Threshold","text":"<p>Farms have to calculate the application of manure N and, under the Fertilisation Ordinance 2017, N from biogas digestate. The derived value is not allowed to exceed a threshold related to farm area in ha.</p> <p>As input for manure N, animal excretion v_nutExcrDuev(nut,t,nCur)_ is included, and the input from biogas is calculated separately in the following equation.</p> <pre><code>nutBiogasDueVAccAL_(tCur(t),nCur)  $ t_n(t,nCur)..\n\n      v_nutBiogasDueVAccAL(t,nCur) =e=\n\n           sum( (curmanchain,m,nut2N), v_nutCropBiogasM(curmanchain,nut2N,t,nCur,m)        * p_nutEffectivDueVAlBiogasPlantDig\n\n                             *  p_NincludeBioDigest )\n\n        +  sum ( (curBhkw(bhkw), curEeg(eeg),curmaM,m,nut2N),\n                                 v_purchManure(bhkw,eeg,curmaM,t,nCur,m) * p_nut2manPurch(\"LiquidBiogas\",nut2N,curmaM)\n                                                                        *  p_nutEffectivDueVAlBiogasPurchMan(curmaM)  ) ;\n</code></pre> <p>The N input from manure and biogas digestate and manure import is summarized in the following equation. The export of manure is substracted. The variable v_DueVOrgN returns the accordance of nitrogen from organic sources at a farm level. The nitrogen has to be accounted with factors defined by the Fertilisation Ordinance.</p> <pre><code>DuevOrgN_(tCur(t),nCur) $ t_n(t,nCur) ..\n\n        v_DueVOrgN (t,nCur)  =E=\n\n*          --- Nutrients excreted in stable\n           $$ifi \"%herd%\" == \"true\"  sum(nType,v_nutExcrDuev(\"N\",nType,t,nCur)*   p_nutEffectivDueVAl(nType))\n\n*          --- Nutrients excreted during grazing\n           $$iftheni.cattle \"%cattle%\" == \"true\"\n\n            +  sum(m $(  sum(grasscrops $(p_grazMonth(grassCrops,m)&gt;0),1)\n                       $ sum(actHerds(possHerds,breeds,grazRegime,t,m),1) ),\n                  v_nutExcrPast(\"N\",t,nCur,m) * p_nutEffectivDueVAlPast)\n            $$endif.cattle\n\n*           --- Nutrients imported to the farm\n\n            $$ifi \"%AllowManureImport%\" == \"true\" +  sum ( (nut2N,m), v_manImport(t,nCur,m) * p_nut2inMan(nut2N,\"manImport\",\"LiquidImport\") )\n\n*           --- Nutrients exported from farm\n\n            $$ifi \"%AllowManureExport%\"==\"true\"  -  sum( (curManChain,m,nut2N), v_nut2export(curManChain,nut2N,t,nCur,m) )\n            $$ifi not \"%emissionRight%\"==0       -  sum( (curManChain,m,nut2N), v_nut2exportMER(curManChain,nut2N,t,nCur,m) )\n\n*           --- Nutrients coming from biogas plant, included depending on FD, calculated in fermenter tech\n\n           $$ifi %biogas% == true +  v_nutBiogasDueVAccAL(t,nCur)\n;\n</code></pre> <p>The N input is not allowed to exceed a target value defined by the Fertilisation Ordinance, being 170 kg N/ha/a in most cases.</p> <pre><code>DuevOrgNLimit_ (tCur(t),nCur) $ t_n(t,nCur) ..\n\n      v_DueVOrgN (t,nCur)\n\n            =L=\n\n             sum(  (c_p_t_i(curCrops(crops),plot,till,intens))  $ ( not catchcrops(crops) )  ,\n                       p_nutManApplLimit(crops,t) * v_cropHa(crops,plot,till,intens,t,nCur)) ;\n</code></pre> <p>Under the Fertilisation Ordinance 2020, the manure application is additionally restricted at crop level in so-called red zones:</p> <pre><code>DuevOrgNLimitCrop_(curCrops(crops),tCur(t),nCur) $ ( t_n(t,nCur) $ ( not catchcrops(crops) )  ) ..\n\n      sum( (c_p_t_i(crops,plotInNO3zone(plot),till,intens),manApplicType_manType(ManApplicType,curManType),m,nut2N)\n               $  ( v_manDist.up(crops,plot,till,intens,manApplicType,curManType,t,nCur,m) ne 0),\n\n                     v_manDist(crops,plotInNO3zone,till,intens,manApplicType,curManType,t,nCur,m)\n                         * sum(manChain_applic(manChain,ManApplicType), p_nut2inMan(nut2N,curManType,manChain)) )\n\n      $$iftheni.dh \"%cattle%\" == \"true\"\n*                --- excretion on pasture\n              +  sum( (c_p_t_i(pastCrops(crops),plotInNO3zone(plot),till,intens),nut2N,m)\n                          $ ((p_grazMonth(Crops,m)&gt;0)\n                                $ sum(actHerds(possHerds,breeds,grazRegime,t,m)  $ p_nutExcreDueV(possHerds,grazRegime,nut2N),1)),\n                                              v_nut2ManurePast(crops,plot,till,intens,nut2N,t,nCur,m) )\n      $$endif.dh\n\n                    =L=\n\n                     sum( (c_p_t_i(crops,plotInNO3zone(plot),till,intens))   ,\n                               p_nutManApplLimit(crops,t)\n                                   * v_cropHa(crops,plotInNO3zone,till,intens,t,nCur) * p_bigNumberFOAppLimCrop  )  ;\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/PolicyMeasures/fertilisation_ordinance/#binding-fertiliser-planning","title":"Binding Fertiliser Planning","text":"<p>Under the Fertilisation Ordinance 2017 and 2020, farms have to do an obligatory fertiliser planning based on the expected yields. The derived nutrient need with regard to nitrogen must not be exceeded. This allows to calculate a nitrogen quota which farms have to meet. The fertiliser quota is always calculated if the Fertilisation Ordinance is switched on. However, it only becomes binding for fertiliser application under the Fertilisation Ordinance 2017 and 2020.</p> <p>The nutrient input is summarised in the equation FertQuotaInput_. Nutrients from chemical fertiliser, manure and mineralisation from the soil are taken into account. Manure N is accounted with mineral fertiliser equivalents defined by the Ordinance.</p> <pre><code>FertQuotaInput_(c_p_t_i(curCrops(crops),plot,till,intens),nut,t_n(tCur(t),nCur))    ..\n\n     v_FertQuotaInput(crops,plot,till,intens,nut,t,nCur)\n\n            =e=\n\n                  sum (  (curInputs(syntFertilizer),m) $ (v_syntDist.up(crops,plot,till,intens,syntFertilizer,t,nCur,m) ne 0),\n                              v_syntDist(crops,plot,till,intens,syntFertilizer,t,nCur,m)     * p_nutInSynt(syntFertilizer,nut) )\n\n*\n*          --- note that the fertilizer ordinance already considers in the crop need (!)\n*              nutrient excreted curing the grazing\n*\n$iftheni.man %manure% == true\n\n               +  sum ( (manApplicType_manType(ManApplicType,curManType),m)\n                                     $ (v_manDist.up(crops,plot,till,intens,manApplicType,curManType,t,nCur,m) ne 0) ,\n\n                          v_manDist(crops,plot,till,intens,ManApplicType,curManType,t,nCur,m)\n                              * sum( (nut2_nut(nut2,nut),manChain_applic(curManChain,ManApplicType)),\n                                      p_nut2inMan(nut2,curManType,curManChain)*p_nutEffFOPlan(curManType,crops,m,nut)))\n$endif.man\n\n     ;\n</code></pre> <p>Furthermore, the plant nutrient need is calculated. It depends on the yield level and is precisely defined by the Fertilisation Ordinance.</p> <pre><code>FertQuotaNeed_(c_p_t_i(curCrops(crops),plot,till,intens),nut,tCur(t),nCur) $ ( card(p_nNeedFerPlan)\n         $ (not (catchCrops(crops) or sameas(crops,\"idle\") or sameas(crops,\"idleGras\")))) ..\n\n     v_FertQuotaNeed(crops,plot,till,intens,nut,t,nCur)\n\n                 =e=\n\n                    v_cropHa(crops,plot,till,intens,t,nCur)\n                          * sum(plot_soil(plot,soil),\n*                           --- N need depending on yield level which is reflected in p_NneedFerPlan\n                                  p_NneedFerPlan(crops,soil,till,intens,nut,t)\n*                           --- Nmin in spring. For grassland, the value is always 30. Nmin of crop is accounted\n*                               for the same crop as crop rotation is not reflected in the standard setting.\n                              -   p_NutFromSoil(crops,soil,till,nut,t))\n                            ;\n</code></pre> <p>The plant nutrient input is not allowed to exceed the estimated nutrient need. The restriction becomes only binding under the Fertilisation Ordinance 2017 and 2020. The parameter p_bigNumberFO is a very large number under Fertiliser Ordinance 2007 which ensures that the nutrient need is extremely high and not binding.</p> <pre><code>FertQuota_(c_p_t_i(curCrops(crops),plot,till,intens),nut,t_n(tCur(t),nCur))\n        $ (sum(plot_soil(plot,soil), p_NneedFerPlan(crops,soil,till,intens,nut,t))\n             $ (not (catchcrops(crops) or sameas(crops,\"idle\") or sameas (crops,\"idleGras\")))) ..\n\n       v_FertQuotaInput(crops,plot,till,intens,nut,t,nCur)  =l=    v_FertQuotaNeed(crops,plot,till,intens,nut,t,nCur)  * p_bigNumberFO  ;\n</code></pre> <p>Under the FO 2020, additional restrictions to the fertilising planning apply in so-called red zones:</p> <pre><code>FertQuotaNZone_(tCur(t),nCur) $ ( t_n(t,nCur)) ..\n\n\n     sum (c_p_t_i(curCrops(crops),plotInNO3zone,till,intens)\n          $ (not (catchcrops(crops) or sameas(crops,\"idle\") or sameas (crops,\"idleGras\"))),\n                  v_FertQuotaInput(crops,plotInNO3zone,till,intens,\"N\",t,nCur))\n\n             =l=\n\n    sum (c_p_t_i(curCrops(crops),plotInNO3zone,till,intens)\n         $ (not (catchcrops(crops) or sameas(crops,\"idle\") or sameas(crops,\"idleGras\"))),\n                 v_FertQuotaNeed(crops,plotInNO3zone,till,intens,\"N\",t,nCur) ) * p_FertQuotaRed ;\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/PolicyMeasures/fertilisation_ordinance/#required-manure-storage-capacities","title":"Required Manure Storage Capacities","text":"<p>Farms are required to hold a minimum storage capacity to bridge the time in autumn and winter when manure application is not allowed. This storage capacity was defined at federal state level under the Fertilisation Ordinance 2007. Under the Fertilisation Ordinance 2017 and 2020, it is defined at federal level in the Fertilisation Ordinance.</p> <p>Generally, farms have to hold a manure storage capacity to gap the amount of manure excretion corresponding to a certain time period, e.g. 6 months. Therefore, the required storage capacity is defined in the manure module. The parameter p_ManureStorageNeed defines the required number of months and is linked to the selected Fertilisation Ordinance.</p> <pre><code>manStorCapNeed_(curManChain(manChain),tCur(t),nCur) $ (t_n(t,nCur) $ p_ManureStorageNeed)   ..\n\n          v_ManStorCapNeed(manChain,t,nCur)\n\n            =e=  p_ManureStorageNeed   * (\n\n\n    $$ifi %herd% == true      v_manQuant(manChain,t,nCur) $ (not sameas (manchain, \"LiquidBiogas\"))\n\n*  --- required silo storage capacity for biogas plant digestate (including energy crops and purchased manure)\n\n    $$ifi %biogas% == true    + sum((crM(biogasfeedM),m), v_voldigCrop(crM,t,nCur,m) + v_volDigMan(t,nCur,m)) $ sameas (\"LiquidBiogas\",manchain)\n\n                                    );\n</code></pre> <p>Under the Fertilisation Ordinance 2017 and 2020, farms exceeding a stocking density of 3 livestock units per ha have to hold additional manure storage capacity. This is implemented with a binary trigger in FarmDyn. The variable v_triggerStorageGVha becomes one when the farm exceeds the livestock unit threshold.</p> <pre><code>triggerStorageGVha_(tCur(t),nCur) $t_n(t,nCur) ..\n\n             (    v_sumGV(t,nCur)   /   sum(plot, p_plotSize(plot))  ) - 3  =l= v_triggerStorageGVha(t,nCur) *  200 ;\n</code></pre> <p>If the variable v_triggerStorageGVha is 1, the restriction in the following equation becomes binding:</p> <pre><code>manStorCapGVDepend_(curManChain(manChain),tCur(t),nCur) $ t_n(t,nCur) ..\n\n            v_TotalManStorCap(manChain,t,nCur)\n                     =g= v_manQuant(manChain,t,nCur) *  p_ManureStorageNeedGV\n                                        - ( (1 -  v_triggerStorageGVha(t,nCur) ) * p_bigNumber ) ;\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/PolicyMeasures/fertilisation_ordinance/#banning-periods-for-fertiliser-application","title":"Banning Periods for Fertiliser Application","text":"<p>During certain months of the year, the application of fertiliser is not allowed as there is no plant nutrient need and the risk of nitrate leaching is very high. This is implemented in FarmDyn by setting the variable v_mandist and v_syntdist to zero for certain months which disables fertiliser application in the model.</p> <p>Depending on the Fertilisation Ordinance selected, sets are defined which include the months in which fertiliser application is forbidden.</p> <pre><code>set monthApplicationForbidden(m)                    /Dec,Jan /  ;\n</code></pre> <pre><code>set monthApplicationForbiddenArab(m)            /Nov,Dec,Jan /  ;\n</code></pre> <pre><code>set monthApplicationForbiddenGrass(m)              / Dec,Jan /  ;\n</code></pre> <pre><code>set  monthApplicationForbidden(m)              /Nov,Dec,Jan / ;\n</code></pre> <pre><code>set  monthApplicationForbiddenArab(m)      /Oct,Nov,Dec,Jan / ;\n</code></pre> <pre><code>set  monthApplicationForbiddenGrass(m)        / Nov,Dec,Jan / ;\n</code></pre> <pre><code>set  monthApplicationForbidden(m)              /Nov,Dec,Jan / ;\n</code></pre> <pre><code>set  monthApplicationForbiddenArab(m)      /Oct,Nov,Dec,Jan / ;\n</code></pre> <pre><code>set  monthApplicationForbiddenGrass(m)        / Nov,Dec,Jan / ;\n</code></pre> <p>For the months which are defined in the described sets, the variables for fertiliser application are set to zero. There are differences between the various fertiliser ordinances. The following part of code is an example of the Fertiliser Ordinance 2017. There are corresponding documents for the other fertiliser ordinances.</p> <pre><code>set  monthApplicationForbidden(m)              /Nov,Dec,Jan / ;\n  set  monthApplicationForbiddenArab(m)      /Oct,Nov,Dec,Jan / ;\n  set  monthApplicationForbiddenGrass(m)        / Nov,Dec,Jan / ;\n\n  v_syntDist.up(arabCrops(crops),plot,till,intens,syntFertilizer,t,nCur,monthApplicationForbiddenArab(m))\n                                                        $ ( t_n(t,nCur) $ c_p_t_i(crops,plot,till,intens) )  = 0 ;\n\n  v_syntDist.up(grassCrops(crops),plot,till,intens,syntFertilizer,t,nCur,monthApplicationForbiddenGrass(m))\n                                                        $ ( t_n(t,nCur) $ c_p_t_i(grassCrops,plot,till,intens) )  = 0 ;\n\n$$iftheni.v_manDist declared v_manDist\n   v_volManApplied.up(manChain,t,nCur,monthApplicationForbidden) $ t_n(t,nCur)  = 0;\n   v_nut2ManApplied.up(crops,manChain,nut2,t,nCur,monthApplicationForbidden) $ t_n(t,nCur) = 0;\n   v_manDist.up(crops,plot,till,intens,manApplicType_manType(manApplicType,curmanType),t,nCur,monthApplicationForbidden)\n            $ (t_n(t,nCur) $  c_p_t_i(crops,plot,till,intens)) = 0;\n\n   v_manDist.up(arabCrops(crops),plot,till,intens,manApplicType_manType(manApplicType,curManType),t,nCur,monthApplicationForbiddenArab)\n        $ (t_n(t,nCur) $ c_p_t_i(crops,plot,till,intens)) = 0;\n\n   v_manDist.up(grassCrops(crops),plot,till,intens,manApplicType_manType(manApplicType,curManType),t,nCur,monthApplicationForbiddenGrass)\n        $ (t_n(t,nCur) $ c_p_t_i(crops,plot,till,intens)) = 0;\n  $$endif.v_manDist\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/PolicyMeasures/fertilisation_ordinance/#restriction-of-fertiliser-application-in-autumn","title":"Restriction of Fertiliser Application in Autumn","text":"<p>In addition to the fixed banning periods, the application of fertiliser in autumn is only legal for some crops and restricted to a defined amount of nitrogen per ha. The parameter p_NLimitInAutumn contains the allowed amount of N and is defined depending on the Fertilisation Ordinance. Catch crops allow additional manure application in autumn.</p> <pre><code>NLimitAutumn_ (c_p_t_i(curCrops(crops),plot,till,intens),t_n(tCur(t),nCur))\n                              $ (v_cropHa.up(crops,plot,till,intens,t,nCur) ne 0) ..\n\n\n$iftheni.man %manure% == true\n\n                     sum( (manChain_type(curManChain,curManType),manApplicType_manType(ManApplicType,curManType),nut2N,m)\n                          $ ((v_manDist.up(crops,plot,till,intens,ManApplicType,curManType,t,nCur,m) ne 0)  $ monthHarvestBlock(crops,m)),\n                                v_manDist(crops,plot,till,intens,ManApplicType,curManType,t,nCur,m)\n                                    *   p_nut2inMan(nut2N,curManType,curManChain) )\n\n$endif.man\n\n                     +    sum( (syntFertilizer,m) $ monthHarvestBlock(crops,m),\n                              v_syntDist(crops,plot,till,intens,syntFertilizer,t,nCur,m)\n                                 *   p_nutInSynt(syntFertilizer,\"N\")  )\n\n                      =l=       v_cropHa(crops,plot,till,intens,t,nCur)  *   p_NLimitInAutumn(crops,plot)\n\n                       ;\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/PolicyMeasures/fertilisation_ordinance/#low-emission-manure-application-techniques","title":"Low-Emission Manure Application Techniques","text":"<p>The Fertilisation Ordinance defines which manure application techniques are legally allowed. Under the Fertilisation Ordinance 2017, broadcast spreading is banned except on fallow land followed by direct incorporation. This measure is introduced in FarmDyn by setting the variable v_mandist to zero for certain months and not allowed application techniques.</p> <pre><code>$$iftheni.v_manDist declared v_manDist\n   v_volManApplied.up(manChain,t,nCur,monthApplicationForbidden) $ t_n(t,nCur)  = 0;\n   v_nut2ManApplied.up(crops,manChain,nut2,t,nCur,monthApplicationForbidden) $ t_n(t,nCur) = 0;\n   v_manDist.up(crops,plot,till,intens,manApplicType_manType(manApplicType,curmanType),t,nCur,monthApplicationForbidden)\n            $ (t_n(t,nCur) $  c_p_t_i(crops,plot,till,intens)) = 0;\n\n   v_manDist.up(arabCrops(crops),plot,till,intens,manApplicType_manType(manApplicType,curManType),t,nCur,monthApplicationForbiddenArab)\n        $ (t_n(t,nCur) $ c_p_t_i(crops,plot,till,intens)) = 0;\n\n   v_manDist.up(grassCrops(crops),plot,till,intens,manApplicType_manType(manApplicType,curManType),t,nCur,monthApplicationForbiddenGrass)\n        $ (t_n(t,nCur) $ c_p_t_i(crops,plot,till,intens)) = 0;\n  $$endif.v_manDist\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/PolicyMeasures/fertilisation_ordinance/#obligatory-catch-crop-cultivation","title":"Obligatory Catch Crop Cultivation","text":"<p>Under the Fertilisation Ordinance 2020, the cultivation of catch crops is obligatory in so-called red zones:</p> <pre><code>CatchCropRequiredFO_(tCur(t),nCur) $t_n(t,nCur) ..\n\n      sum(c_p_t_i(curCrops(Crops),plotInNO3zone,till,intens)\n                 $catchcrops(crops), v_cropHa(crops,plotInNO3zone,till,intens,t,nCur))\n            =g=\n\n         sum( c_p_t_i(curCrops(crops),plotInNO3zone,till,intens) $ summerHarvest(Crops),\n                                           v_cropHa(crops,plotInNO3zone,till,intens,t,nCur) ) * p_CatchCropRequFO ;\n</code></pre>"},{"location":"FarmDynDocumentation/ModelDescription/PolicyMeasures/fertilisation_ordinance/#references","title":"References","text":"<p>D\u00fcV (2007): Verordnung \u00fcber die Anwendung von D\u00fcngemitteln, Bodenhilfsstoffen, Kultursubstraten und Pflanzenhilfsmitteln nach den Grunds\u00e4tzen der guten fachlichen Praxis beim D\u00fcngen. \"D\u00fcngeverordnung in der Fassung der Bekanntmachung vom 27. Februar 2007 (BGBl. I S. 221), die zuletzt durch Artikel 18 des Gesetzes vom 31. Juli 2009 (BGBl. I S. 2585) ge\u00e4ndert worden ist\".</p> <p>D\u00fcV (2017): Verordnung \u00fcber die Anwendung von D\u00fcngemitteln, Bodenhilfsstoffen, Kultursubstraten und Pflanzenhilfsmitteln nach den Grunds\u00e4tzen der guten fachlichen Praxis beim D\u00fcngen. \"D\u00fcngeverordnung vom 26. Mai 2017 (BGBl. I S. 1305), die zuletzt durch Artikel 97 des Gesetzes vom 10. August 2021 (BGBl. I S. 3436) ge\u00e4ndert worden ist\".</p> <p>D\u00fcV (2020): Verordnung \u00fcber die Anwendung von D\u00fcngemitteln, Bodenhilfsstoffen, Kultursubstraten und Pflanzenhilfsmitteln nach den Grunds\u00e4tzen der guten fachlichen Praxis beim D\u00fcngen. \"D\u00fcngeverordnung vom 26. Mai 2017 (BGBl. I S. 1305), die zuletzt durch Artikel 97 des Gesetzes vom 10. August 2021 (BGBl. I S. 3436) ge\u00e4ndert worden ist\".</p>"},{"location":"FarmDynDocumentation/TR/MIP_solution_strategy/","title":"MIP Solution Strategy","text":"<p>In opposition to purely linear problems, Mixed-Integer problem models (MIPs) are harder to solve. To find the optimum, in theory the combinatorial set of all binaries respectively general integer variables would need to be evaluated. Depending on the simulation horizon of FarmDyn, the number of farm branches considered and the time resolution for investment and labour use decisions, a model instance can comprise between a few dozens to more than a thousand binary variables, with often several ten thousand variables and equations in total.</p> <p>There are huge differences in the quality of LP and MIP solvers. Industry solvers such as CPLEX or GUROBI reflect continuous investments into algorithmic improvements over decades. Fortunately, both offer free academic licenses. The code is set-up to work with both solvers to be secured should license conditions change as well as switch in cases one of the solvers outperforms considerably the other. Current tests seem to show a slight advantage for CPLEX. Both solvers can benefit from parallel processing. Model instances should therefore if possible be solved on a multi-core computing server. The option files for the solvers are currently defined such that one core is not used by the program and left free for other processing load.</p> <p>The relaxed version of the model (where binaries and integers are removed and treated as continuous variables) can typically be solved in a few seconds, and once such a starting point is given, slight modifications to the model take very little time to solve despite the model size. However, regardless of tremendous algorithmic improvements in solving MIPs, the MIP version could take quite long to solve without some solution tactic.</p> <p>The model code therefore integrates different strategies to speed up the solution process for the MIP. Some of those are generally applicable to MIP problems, typically offered by GAMS and/or the MIP solvers, others follow tactics proposed to speed up the solution time of MIP problems, but require a specific implementation reflecting the model structure. In the following, these strategies are roughly described, starting first with the model generic.</p> <p>To define a lower bound on the objective which allows the solver to cut-off parts of the tree of solution paths, the model is first solved in a relaxed mode (RMIP) with the farm switched off such that income can only be generated by working off-farm (v_hasFarm is fixed to zero). Solving this variant takes less than a second. The solution is used to define the lower cut-off for the MIP solver. Next, the model is solved as RMIP with only one state of nature (SON), and afterwards, the state contingent variables are copied to all other SONs, before the RMIP is solved again. The main statements are given in the exp_starter.gms file.</p> <p>The relaxed (RMIP) solution defines the upper cut-off. Forcing certain variables to only take on integer values can only reduce the objective function. At the same time, it proves a basis for solving the MIP. However, in many instances it has not proven useful to use the solution of RMIP as MIP start starting point, both CPLEX and GUROBI seem to spend considerable time to construct a feasible integer solution from the RMIP solution.</p> <p>As stated above, solving a MIP problem to its true optimum can be tremendously time consuming. Therefore, MIP problems are typically only solved given an optimality tolerance. The branch-and-cut algorithm used in MIP solvers always provide a safe upper limit for the objective value stemming from a relaxed version of the current tree node. Accordingly, they can quantify the maximal absolute and relative gap to the potentially maximal objective function. Generally, the smaller the desired gap, the larger the number of combination of integer variables the solver needs to test. Forcing the gap to zero requires a test of (almost) all combination, i.e. ten-thousands of solves of a LP version of the model with binaries and integers fixed. In most production runs, a relative gap of 0.5 % has proven as acceptable. The solver will then stop further search for a better solution once a MIP solution has been found which differs by less from the relaxed best node.</p> <p>The problem with this gap is clearly that differences between two simulations can not only stem from different model inputs (prices, policy etc.), but also simply from the fact that the gap at the best solutions returned by the solver for each run differs.</p> <p>MIP solvers can also \"tune\" their options based on one or several given model instance. Tuning is available both with CPLEX and GUROBI, and can be switched on via the interface. This process takes quite long as the model is repeatedly solved with different solver options. The parameters from the tuning step are stored in an option and can be used by subsequent runs.</p>"},{"location":"FarmDynDocumentation/TR/MIP_solution_strategy/#fractional-investments-of-machinery","title":"Fractional investments of machinery","text":"<p>An option to reduce the number of binaries is to treat certain investment decisions as continuous. For machinery, the model allows to replace the binary variable v_buyMach by a fractional replacement v_buyMachFlex. The replacement depends on a threshold for the depreciation costs per ha or hour which can be set in the GUI. The larger the threshold, the lower is the number of integer variables and the higher the (potential) difference to the solution where more indivisibilities in machine investments are taken into account.</p> <p>The relevant code section is defined in \"gams\\solve\\define_starting_bounds.gms\" and shown below:</p> <pre><code>v_buyMach.fx(machType,t_n(t,nCur))\n    $ ( (    (p_machAttr(machType,\"depCost_ha\")     le %buyMachFlexThreshold%) $ p_machAttr(machType,\"depCost_ha\")\n          or (p_machAttr(machType,\"depCost_hour\")   le %buyMachFlexThreshold%) $ p_machAttr(machType,\"depCost_hour\") )\n                                      $ (not p_machAttr(machType,\"years\"))) = 0;\n</code></pre> <pre><code>v_buyMachFlex.fx(machType,t_n(t,nCur))\n    $  (    (p_machAttr(machType,\"depCost_ha\")    gt %buyMachFlexThreshold%)\n         or (p_machAttr(machType,\"depCost_hour\")  gt %buyMachFlexThreshold%)\n         or p_machAttr(machType,\"years\")) = 0;\n</code></pre>"},{"location":"FarmDynDocumentation/TR/MIP_solution_strategy/#heuristic-reduction-of-binaries","title":"Heuristic reduction of binaries","text":"<p>On demand, the RMIP solution can be used in combination with some heuristic rules to reduce the set of endogenous variables. As the RMIP solution will e.g. build a fraction of larger stables and thus save costs compared to the MIP solution, the herd size in the MIP solution can be assumed to be upper bounded by the solution of the MIP. Similarly, as investment costs for machinery will be underestimated by the MIP, it can be assumed that machinery not bought in the RMIP solution will not be found in the optimal solution of the MIP.</p> <p>An example is shown below for investment decisions into stables. The program first defines the maximal amount of stable places used in any year. Investments into stables and their usage which are larger than the maximal size or smaller than 2/3 of the maximal size are removed from the MIP. Equally, investment in stables is set to zero if there was no investment in the RMIP solution.</p> <p>Similar statements are available for investments into manure silos, buildings and machinery. These heuristics are defined in \"gams\\solve\\reduce_vars_for_mip.gms\". It is generally recommended to use these statements as they can considerably reduce solving time. However, especially after structural changes to the code, checks should be done if the rules do not prevent the model from finding the (optimal) MIP solution.</p>"},{"location":"FarmDynDocumentation/TR/MIP_solution_strategy/#binary-fixing-heuristics","title":"Binary fixing heuristics","text":"<p>To speed up the solution, the heuristics discussed above are coupled with repeated RMIP solves where integer variables from the last fractional solution are moved to zero or unity depending on the solution and heuristics rules. To give an example: If parts of machinery are bought over time such that their sum exceeds a threshold, for instance half a tractor, the v_machBuy variable in the first year where the machine is bought is fixed to zero. These pre-solves can lead to start points for the MIP solves where most integer variables are no longer fractional. Thereby, they can speed up the solution.</p>"},{"location":"FarmDynDocumentation/TR/MIP_solution_strategy/#equations-which-support-the-mip-solution-process","title":"Equations which support the MIP solution process","text":"<p>Another tactic to ease the solution of MIPs is to define equations which decrease the solution space for the integer variables based on the level of fractional variables respectively defining logical ordering for the integer decisions. These equations are not necessarily truly restricting the solution space, they only reinforce existing relations between variables. The additional equations often reduce the overall solution time by improving the branching more than by increasing single LP iterations due to the increase in the constraints.</p> <p>One way to improve the branching order is to link binaries with regard to dynamics. There are currently three ordering equations over time. The first two prescribe respectively that if a farm has a cow herd in t+1 this implies that a cow herd in the previous year existed:</p> <pre><code>hasHerdOrderDairy_(tCur(t),nCur) $ (tCur(t-1) $ t_n(t,nCur)) ..\n\n       v_HasBranch(\"dairy\",t,nCur) =L= sum(t_n(t-1,nCur1) $ anc(nCur,nCur1), v_hasBranch(\"dairy\",t-1,nCur1));\n</code></pre> <pre><code>hasFarmOrder_(tCur(t),nCur) $ (tCur(t-1) $ t_n(t,nCur)) ..\n\n       v_hasFarm(t,nCur) =L= sum(t_n(t-1,nCur1) $ anc(nCur,nCur1), v_hasFarm(t-1,nCur1));\n</code></pre> <p>Another tactic is to define logical high level binaries which dominate others. These general binaries are partly already shown above: the v_hasFarm and v_workOffB variables. The later one is linked to the individual off-farm working possibilities:</p> <p>To support the solving process, v_workOff is defined as a SOS1 variable which implies that at most one of the workType options is greater than zero in any year.</p> <p>The v_hasFarm variables dominates the v_hasBranch variables:</p> <pre><code>hasFarmOrder_(tCur(t),nCur) $ (tCur(t-1) $ t_n(t,nCur)) ..\n\n       v_hasFarm(t,nCur) =L= sum(t_n(t-1,nCur1) $ anc(nCur,nCur1), v_hasFarm(t-1,nCur1));\n</code></pre> <p>This equation is additionally linked to the logic of the model as v_hasFarm implies working hours for general farm management.</p> <p>Furthermore, a general binary exists which controls if a herd is present in any year, v_hasAlwaysHerd. If it is switched on, it will imply a dairy herd in any year. This is based on the equation hasAlwaysLast_ together with the order equation hasHerdOrder_ shown below.</p> <p></p> <p>The equations which support the MIP solution process by linking fractional variables to binary ones relate to investment decisions. Firstly, investments in machinery are only possible if there is matching machinery need:</p> <pre><code>machBuyFlex_(curMachines(machType),machLifeUnit,tFull(t),nCur)\n        $ (   (v_machInv.up(machType,machLifeUnit,t,nCur) ne 0)\n            $ v_buyMachFlex.up(machType,t,nCur)  $ p_lifeTimeM(machType,machLifeUnit)\n            $ (not sameas(machLifeUnit,\"years\")) $ p_priceMach(machType,t) $ t_n(t,nCur))  ..\n\n        v_buyMachFlex(machType,t,nCur) * p_lifeTimeM(machType,MachLifeUnit)\n            =L= v_machNeed(machType,machLifeUnit,t,nCur) $ tCur(t)\n\n              + [sum( (t_n(t1,nCur1)) $ ( tCur(t1) $ isNodeBefore(nCur,nCur1)),\n                                 v_machNeed(machType,machLifeUnit,t1,nCur1))/card(tCur)\n                 ]  $ ( (not tCur(t)) and p_prolongCalc);\n</code></pre> <p>Secondly, two equations link the dairy herd to investment decisions into stables and manure storage silos:</p> <pre><code>stableBuy_(stables,hor,t_n(tFull(t),nCur)) $ (v_buyStables.up(stables,hor,t,nCur) gt 0) ..\n\n       v_buyStables(stables,hor,t,nCur) =L= sum(stableTypes_to_branches(stableTypes,branches)\n                                              $ p_stableSize(stables,stableTypes), v_HasBranch(branches,t,nCur));\n</code></pre> <pre><code>stableInv_(stables,hor,tFull(t),nCur)\n       $ (   (p_priceStables(stables,hor,t) gt eps)\n               $ (      sum( (t_n(t1,nCur1),hor1) $ ((isNodeBefore(nCur,nCur1) or sameas(nCur,nCur1)) and (p_year(t1) le p_year(t))),\n                         (v_buyStables.up(stables,hor1,t1,nCur1) ne 0))\n                    or  sum( tOld, p_iniStables(stables,hor,tOld)))\n                     $ (sum(stableTypes,p_stableSize(stables,StableTypes)) gt eps)\n                     $ t_n(t,nCur) ) ..\n\n       v_stableInv(stables,hor,t,nCur)\n\n          =L=\n*\n*         --- old stables according to building date and lifetime\n*             (will drop out of equation if too old)\n*\n          sum( tOld $ (   ((p_year(tOld) + p_lifeTimeS(stables,hor)) gt p_year(t))\n                              $ ( p_year(told)                       le p_year(t))),\n                           p_iniStables(stables,hor,tOld))\n\n*\n*         --- plus (old) investments - de-investments\n*\n       +  sum( t_n(t1,nCur1) $ ( isNodeBefore(nCur,nCur1)\n                                   $  (   ((p_year(t1)  + p_lifeTimeS(stables,hor) ) gt p_year(t))\n                                   $ (      p_year(t1)                               le p_year(t)))),\n                                                    v_buyStablesF(stables,hor,t1,nCur1));\n</code></pre> <p>These supporting restrictions can be switched off from the model via the GUI to check if they unnecessarily restrict the solution domain of the solver. It is generally recommended to use them as they have proven to speed up the solution process.</p>"},{"location":"FarmDynDocumentation/TR/MIP_solution_strategy/#priorities","title":"Priorities","text":"<p>Finally, there are options to help the MIP solver to decide which branches to explore first. The variable field .prior in GAMS allows setting priorities which are passed to the MIP solver; lower priorities are interpreted as having precedence. The file \"gams\\solve\\def_priors.gms\" defines such priorities.</p> <p>The model is instructed to branch first on the decision to have a herd in any year, next on having a farm and the individual branches:</p> <p>^Comment:# (N:/em/work1/Pahmeyer/FarmDyn/FarmDynDoku/FarmDyn_Docu/gams/solve/def_priors.gms GAMS / v_hasAlwaysHerd.prior/ /;/)</p> <pre><code> v_hasAlwaysHerd.prior                           = %priorOperator%  (p_priorMax*20);\n</code></pre> <pre><code> v_hasFarm.prior(t_n(tCur(t),nCur))                   = %priorOperator% ( %timeWeight% * 10000 );\n</code></pre> <pre><code> v_hasBranch.prior(branches,t_n(tCur(t),nCur))        = %priorOperator% ( %timeWeight% * 8000 );\n</code></pre> <pre><code>v_hasBranch.prior(branches,t_n(tCur(t),nCur))        = %priorOperator% ( %timeWeight% * 8000 );\n</code></pre> <p>Generally, early years are given precedence:</p> <pre><code>$setglobal timeWeight [(card(t)-ord(t)+1)/card(t)]**0.5\n</code></pre> <p>The p_priorMax is the maximal priority assigned to stables which is defined by a heuristic rule: large stables are tried before smaller ones, cow stable before young cattle and calves stables, and finally long-term investment in the whole building are done before maintenance investments:</p> <p>^Comment:# (N:/em/work1/Pahmeyer/FarmDyn/FarmDynDoku/FarmDyn_Docu/gams/solve/def_priors.gms GAMS /parameter p_priorStables/ /1;/)</p> <pre><code>parameter p_priorStables(stables);\n\n       p_priorStables(stables) $ sum(stableTypes $ p_stableSize(stables,stableTypes), stableTypes.pos)\n          = sqr(1/sum(stableTypes $ p_stableSize(stables,stableTypes), stableTypes.pos)*10)\n\n                                  * sqrt( sum(stableTypes $ p_stableSize(stables,stableTypes),\n                                                      p_stableSize(stables,stableTypes))\n                                       / smax((stables1,stableTypes) $ p_stableSize(stables,stableTypes),\n                                                 p_stableSize(stables1,stableTypes)));\n\n       p_priorMax              = smax(stables, p_priorStables(stables)) * card(hor);\n       p_priorStables(stables) = p_priorStables(stables)/p_priorMax;\n       p_priorMin              = smin(stables, p_priorStables(stables));\n       p_priorMax              = 1;\n</code></pre> <p>Off-farm work decisions currently receive a lower priority compared to investments into stables:</p> <pre><code>v_buyStables.prior(stables,hor,t_n(tCur(t),nCur))\n          $ sum( (stableTypes,t1,nCur1) $ ( p_buyStables(stableTypes,\"size\",hor,t1,nCur1) $ p_stableSize(stables,stableTypes) $ t_n(t1,nCur1)),1)\n           = %priorOperator% ( hor.pos * %timeWeight%\n                              * ( 10\n                                     $$ifi defined youngStables - 7 $  youngStables(stables)\n                                   ))\n                                 * sum(stableTypes $ p_stableSize(stables,stableTypes), (1/stables.pos)\n                                    * sum(stables1 $ p_stableSize(stables1,stableTypes), 1));\n</code></pre> <p>^Comment:# (N:/em/work1/Pahmeyer/FarmDyn/FarmDynDoku/FarmDyn_Docu/gams/solve/def_priors.gms GAMS /v_stableInv.prior/ /;/)</p> <pre><code>v_stableInv.prior(stables,hor,t,n)  $ t_n(t,n)  = %priorOperator%  [(p_priorStables(stables)*hor.pos + %timeWeight%)*0.95];\n</code></pre> <pre><code>v_labOffB.prior(t_n(tCur(t),nCur))                   = %priorOperator% ( %timeWeight% * 4000 );\n</code></pre> <pre><code>v_laboff.prior(t_n(tCur(t),nCur),workType)    = %priorOperator% ( (card(workType)+1-workType.pos) * %timeWeight%\n                                                                     * [100 + 900 $ v_laboff.l(t,nCur,workType)\n                                                                            + 400 $ v_laboff.l(t,nCur,workType-1)\n                                                                            + 400 $ v_laboff.l(t,nCur,workType+1)] );\n</code></pre> <p>For other investment decisions, the investment sum is used for priority ordering, e.g:</p> <p>^Comment:# (N:/em/work1/Pahmeyer/FarmDyn/FarmDynDoku/FarmDyn_Docu/gams/solve/def_priors.gms GAMS /p_rank(buildings/ /;/)</p> <pre><code>p_rank(buildings) = p_priceBuild(buildings,\"%firstYear%\") / ( p_building(buildings,\"lifeTime\") + 15 $ (not p_building(buildings,\"lifeTime\")));\n</code></pre> <p>The SOS1 variables should have all the same priorities. Therefore, no distinction is introduced for the v_workOff and v_siCovComb variables, with the exemption of the time dimension.</p> <p>Generally, it is recommend using these priorities as they have proven to speed up the solution process.</p>"},{"location":"FarmDynDocumentation/TR/overview_technical_realisation/","title":"Overview of Technical Realisation","text":"<p>Abstract The model uses GAMS for data transformations and model generation and applies the industry LP and MIP solver CPLEX for solution. The code adheres to strict coding guidelines, for instance with regard to naming conventions, code structuring and documentation, including a modular approach. A set of carefully chosen compilation and exploitation tests is used to check the code. The code is steered by a GUI based on GGIG (ref., Java code) which also support result exploitation.</p> <p>The model template and the coefficient generator are realised in GAMS (General Algebraic Modeling System), a widely used modeling language for economic simulation models. GAMS is declarative, i.e. the structure of the model's equation is declared once, and from there different model instances can be generated. GAMS supports scripting for data transformation, extensively used by the coefficient generator and by the post-model reporting. GAMS further provides the option to use embedded code which is used in the model setup to generate data with Python based on tables in the GUI.</p>"},{"location":"FarmDynDocumentation/TR/reporting/","title":"Reporting","text":"<p>FarmDyn's GUI allows the exploitation of model results, also comparing different model runs. For more information, please refer to the section Working with FarmDyn and then Graphical User Interface. The result exploitation via the GUI requires that all results are stored in one multi-dimensional cube. Accordingly, after the model is solved, its variables are copied to a result parameter, as shown in the following example:</p> <pre><code> p_res(%1,%2,\"liquid\",\"sum\",\"\",tCur)         = sum(t_n(tCur,nCur), p_probn(nCur) * v_liquid.l(tCur,nCur));\n</code></pre> <pre><code> p_res(%1,%2,\"liquid\",\"sum\",\"\",\"mean\")       = sum(tCur,p_res(%1,%2,\"liquid\",\"sum\",\"\",tCur)   )/p_cardTCur;\n</code></pre>"},{"location":"Team/collaboration_partners/","title":"Collaboration Partners","text":""},{"location":"Team/collaboration_partners/#wageningen-university-research","title":"Wageningen University &amp; Research","text":"<p>Wageningen Economic Research is involved in the work with FarmDyn via the MIND STEP Project extending FarmDyn to the Dutch agricultural sector. The primary contributors are.</p>"},{"location":"Team/collaboration_partners/#dr-john-helming","title":"Dr. John Helming","text":"<p>John Helming is a senior researcher at the Wageningen Economic Research institution and an expert in applied economic modelling and environmental and agricultural policy analysis.</p>"},{"location":"Team/collaboration_partners/#dr-marc-muller","title":"Dr. Marc M\u00fcller","text":"<p>Marc M\u00fcller is a microeconomicst and model developer at the Wageningen Economic Research institution. He develops farm-scale models to analyse the EU\u2019s common agricultural policies under changing framework conditions.</p>"},{"location":"Team/collaboration_partners/#eth-zurich-agricultural-economics-and-policy","title":"ETH Z\u00fcrich - Agricultural Economics and Policy","text":"<p>The AECP group is involved in the work with FarmDyn for Swiss farms. The results are used in projects on climate change mitigation and biodiversity conservation. The primary contributors are.</p>"},{"location":"Team/collaboration_partners/#dr-robert-huber","title":"Dr. Robert Huber","text":"<p>Robert is a researcher in the AECP group and an expert in agent-based modelling and agricultural policy analysis.</p>"},{"location":"Team/collaboration_partners/#marta-tarruella","title":"Marta Tarruella","text":"<p>Marta is PhD student in the group focusing on climate change mitigation in Swiss agriculture. She applies FarmDyn to assess the cost-efficiency and effectiveness of different economic instruments, such as taxation and market of tradable permits.</p>"},{"location":"Team/collaboration_partners/#cordelia-kreft","title":"Cordelia Kreft","text":"<p>Cordelia is PostDoc in the AECP group. In her PhD, she combined FarmDyn with an agent-based modelling approach to study the behavioral and economic determinants of climate change mitigation in agriculture with a special focus is on farmers' non-cognitive skills, individual preferences and social networks.</p>"},{"location":"Team/projects/","title":"Introduction","text":"<p>From it's development in the DFG project \"The relation between indicators for the crediting of emission rights and abatement costs - a systematic modeling approach for dairy farms\", FarmDyn has constantly progressed in various projects. Initially only simulating a dairy farm model parameterized for the German condition, it is now covering a variety of farm branches with parameterizations for the Netherlands, Norway, Germany and Switzerland. In the following you will find the current and past projects, where FarmDyn was further developed or was used.</p>"},{"location":"Team/projects/#current-projects","title":"Current Projects","text":""},{"location":"Team/projects/#brightspace-2022-2027","title":"BrightSpace (2022-2027)","text":"<p> Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.</p>"},{"location":"Team/projects/#lamasus-land-management-for-sustainability-2022-2026","title":"LAMASUS - Land management for sustainability (2022-2026)","text":"<p> Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.</p>"},{"location":"Team/projects/#phenorob-2020-2024","title":"PhenoRob (2020-2024)","text":"<p> Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.</p>"},{"location":"Team/projects/#mind-step-2019-2023","title":"MIND STEP (2019-2023)","text":"<p> The European Union\u2019s future Common Agricultural Policy (CAP) plays a pivotal role in developing a sustainable agricultural sector. The future CAP will be more flexible and adaptable to the needs of EU Member States and the individual decision making (IDM) units in the sector. To achieve this Member States develop strategic plans for the CAP that should define measurable objectives and means to achieve them. The EU-funded MIND STEP project will make use of agricultural and biophysical data and include individual decision making (IDM) unity in new and existing policy models for impact assessments. Using agricultural statistics and big datasets, the new IDM models will be estimated and calibrated, drawing on established economic and evolving machine learning techniques.</p>"},{"location":"Team/projects/#transform2bio-2019-2022","title":"Transform2Bio (2019-2022)","text":"<p> The phase-out of coal mining initiates major transition processes in the the Rheinische Revier, a lignite mining region, thereby creating a unique opportunity for understanding the socio-technical dynamics and implementation options towards an entire sustainable bioeconomy region. Against this background, Transform2Bio aims to systematically identify transformation trajectories for the implementation of a bioeconomy in the Rheinische Revier that are desirable from a sustainability perspective, feasible from a techno-economic perspective, and acceptable from a stakeholder consensus perspective. In this context FarmDyn is used to identify farm-scale adaptations to bio-economy trajectories by (1) the extension and application of the FarmDyn simulation model to samples of farms and by (2) developing a linkage between FarmDyn and CGEBox (WP3.1c) which provides regional-scale economic simulation for the Rheinische Revier.</p>"},{"location":"Team/projects/#climplement-2020-2023","title":"CLIMPLEMENT (2020-2023)","text":"<p> The project will develop analytic tools based on Norwegian conditions to measure greenhouse gas reducing potentials in various productions and consequences for food production and farm economy. The aim of the project is to advance and disseminate knowledge about how farmers can succeed in implementing emission-reducing operating models, including which system factors are important for such changes. The project results will be used to further develop advisory services and educational programs in terms of disseminating knowledge about more climate-friendly farming.</p>"},{"location":"Team/projects/#past-projects","title":"Past Projects","text":""},{"location":"Team/projects/#lift-2018-2022","title":"LIFT (2018-2022)","text":"<p> FARMDYN was used in the H2020 project LIFT (Low-Input Farming and Territories - Integrating knowledge for improving ecosystem-based farming) by the team in Bonn and a team at INRA, Rennes, to compare different farming systems with regard to sustainability indicators. The overall objective of LIFT was to to identify and understand how socio-economic and policy drivers impact on the development of ecological approaches to farming and assess the performance and sustainability of such approaches, taking into account different farming systems at farm, farm-group and territorial scales.</p>"},{"location":"Team/projects/#sustainbeef-2017-2020","title":"SustainBeef (2017-2020)","text":"<p> The 3-year ERA-NET project SUSTAINBEEF, jointly funded by the EU and the BMEL, links researcher focusing on beef production system with stakeholders to develop and assess innovative ways to improve the sustainability of beef production system. FarmDyn is used for a detailed, quantiative bio-eonomic analysis of beef production systems in Germany based on the application. Further, the core group provided support to partners in applying the model to study regions in their own country.</p>"},{"location":"Team/projects/#usl-project-2016-2019","title":"USL Project (2016-2019)","text":""},{"location":"Team/projects/#modeling-structural-change-and-agricultural-nutrient-flows-across-scales-in-regions-of-north-rhine-westphalia-2016-2019","title":"Modeling structural change and agricultural nutrient flows across scales in regions of North Rhine-Westphalia\", 2016-2019","text":"<p> The project analyzed nutrient exchanges between farms in regions of North Rhine-Westphalia based on the combination of FARMDYN with bio-physical and agent based modeling.</p>"},{"location":"Team/projects/#dfg-project-2015-2018","title":"DFG Project (2015-2018)","text":""},{"location":"Team/projects/#understanding-spatial-interactions-and-structural-change-in-the-dairy-production-chain-with-a-dynamic-regional-agent-based-model-covering-dairy-farms-and-dairy-processing","title":"Understanding spatial interactions and structural change in the dairy production chain with a dynamic regional Agent-Based Model covering dairy farms and dairy processing","text":"<p> Dual profit functions for different farming systems were estimated from FARMDYN simulations to source an Agent Based Model</p>"},{"location":"Team/projects/#dfg-project-2010-2014","title":"DFG Project (2010-2014)","text":""},{"location":"Team/projects/#the-relation-between-indicators-for-the-crediting-of-emission-rights-and-abatement-costs-a-systematic-modeling-approach-for-dairy-farms","title":"The relation between indicators for the crediting of emission rights and abatement costs - a systematic modeling approach for dairy farms","text":"<p> The original model version was developed in the project \"The relation between indicators for the crediting of emission rights and abatement costs - a systematic modeling approach for dairy farms\", financed by the German Science Foundation and carried out by Karin Holm-M\u00fcller, Wolfgang Britz, Bernd Lengers and David Sch\u00e4fer. In the context of the pdh-thesis of Johanna Budde, a first version of the pig module was developed (2012-2013).</p>"},{"location":"Team/team/","title":"Introduction","text":"<p>FarmDyn was initially developed by the Economic Modeling of Agricultural Systems Group of the Institute of Food and Resource Economics at the University of Bonn. The model is under constant development and used for various research projects including external universities and research institutions. In the following the core group of FarmDyn developers is presented below.</p>"},{"location":"Team/team/#core-group","title":"Core group","text":""},{"location":"Team/team/#pd-dr-agr-wolfgang-britz","title":"PD Dr. agr. Wolfgang Britz","text":"<p> Wolfgang Britz is the head of the working group \"Economic Modeling of Agricultural Systems\" and contributes to all research on and around FarmDyn. He developed the model and still contributes significantly to the technical and content development of the model. Latest work in FarmDyn includes the development of the calibration module and extension of the risk module with an estimated utility function.</p> <p> </p> <p> </p> <p> </p> <p> </p>"},{"location":"Team/team/#dr-agr-till-kuhn","title":"Dr. agr. Till Kuhn","text":"<p> Till Kuhn is a post-doc researcher in the working group \"Data Science in Agricultural Economics\" at the University of Bonn specialised in environmental policies such as the Agri-Environmental Schemes and Fertilization Ordinance. Latest work includes the implementation of novel technology (e.g. greenRelease) and agri-envrionmental policies. \u00a0</p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p>"},{"location":"Team/team/#dr-agr-david-schafer","title":"Dr. agr. David Sch\u00e4fer","text":"<p> David Sch\u00e4fer is a post-doc researcher in the working group \"Economics Modeling of Agricultural Systems\" at the University of Bonn. Initially, he developed the pig and biogas modules and is focusing now on the development of FarmDyn as a generic and modular model to improve usability for external researchers. </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p>"},{"location":"Team/team/#dr-agr-christoph-pahmeyer","title":"Dr. agr. Christoph Pahmeyer","text":"<p> Christoph Pahmeyer is a post-doc researcher working in the group \"Data Science in Agricultural Economics\" at the University of Bonn and at the Th\u00fcnen-Institute in Braunschweig contributing to the modelling of production economics and agricultural policies. \u00a0</p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p>"},{"location":"Team/team/#m-sc-julia-heinrichs","title":"M. Sc. Julia Heinrichs","text":"<p> Julia Heinrichs is a PhD Student in the working group \"Economics Modeling of Agricultural Systems\" at the University of Bonn. Her research aims to map systematic changes in production systems in FarmDyn and to capture their impact on the environment. \u00a0</p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p>"},{"location":"Team/team/#m-sc-lennart-kokemohr","title":"M. Sc. Lennart Kokemohr","text":"<p> Lennart Kokemohr is a PhD Student working at the Norwegian institute RURALIS (Institutt for rural og- regionalforskning). His research focuses on the development of environmental accounting schemes in the model in connection to various cattle farming types.</p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p>"},{"location":"WorkingWithFarmDyn/CodeDevelopment/","title":"Developing the Model Code","text":""},{"location":"WorkingWithFarmDyn/CodeDevelopment/#choosing-an-editor-and-making-it-farmdyn-compatible","title":"Choosing an editor and making it FarmDyn compatible","text":"<p>As you already know, FarmDyn is written in the algebraic modeling language GAMS. Since the model is quiet large, the code is split up into several files (called seperation of concerns) within the <code>gams</code> folder of your FarmDyn checkout. A GAMS file is just a plain text file with a <code>.gms</code> suffix, and can therefore be edited by a number of plain text editors.</p> <p>Apparantly, there is no obvious right or wrong choice for such an editor. In the following subsections we will cover some of the most popular options. However, the list is neither complete nor completly objective (I'm sorry). Eventually, you have to decide which one suits your needs by weighing the pros and cons, as all of them are capable of getting the job done the one or the other way.</p>"},{"location":"WorkingWithFarmDyn/CodeDevelopment/#atom","title":"Atom","text":"<p>The Atom editor is an open-source editor created by Github. It has gained a lot of attention among web-developers as it is build using web-technologies (JavaScript, HTML \\&amp; CSS), which makes additional extensions/packages easy to create and maintain (for that target group). Under the hood, Atom uses the same software-stack as Microsoft's Visual Studio Code, which is why these two editors are really similar.</p> <p>Atom's aims to be an editor that is easily approachable (that means you don't need to be a geek in order to use it), yet flexible enough to be a professional coding tool. That said, there are usually two/three ways of achieving what you want to achieve in Atom. Let's say we want to add a Bookmark at a certain line:</p> <ul> <li>Speed: +0: Click on Edit -&gt; Bookmark -&gt; ToggleBookmark. Just like you would in a web-browser that you already know how to use(in fact, Atom IS a Chrome web-browser). No need to learn fancy shortcuts.</li> <li>Speed: +1: Use the powerful <code>ctrl-shift-p</code> shortcut. Then type\"Toggle Bookmark\" and hit enter.</li> <li>Speed: +2: Use an actual shortcut: <code>ctrl-alt-F2</code> for \"ToggleBookmark\"</li> </ul> <p>As the Atom documentation says, if you are willing to remember only one shortcut, make it <code>ctrl-shift-p</code>. You may want to use that shortcut and type \"Install Package\" to open the package installation pane. From there you can install any extension/theme that may sound useful or look good to you.</p> <p>Personally, besides the GAMS packages described later, I enjoy the following setup:</p> <ul> <li>Theme: One Light</li> <li>Minimap Package</li> <li>slickedit-select for block-selection</li> <li>Teletype for collective real-time editing</li> <li>Hydrogen for interactive coding</li> </ul> <p>If you encounter a missing feature, you're bored, or both, then developing your own package may be an option. You don't know how to code Node.JS falvoured JavaScript? No problem, just head over to nodeschool.io and start making some courses. Once you're done, hit your favorite shortcut (<code>ctrl-alt-F2</code>, in case you forgot), type \"Generate Package\", press enter and watch magic happen.</p>"},{"location":"WorkingWithFarmDyn/CodeDevelopment/#gams-studio","title":"GAMS Studio","text":"<p>GAMS Studio is a completely new integrated development environment for GAMS, which is available for Windows, Mac OS X, and Linux. It is based on C++ and Qt. For more information, you can go to GAMS STUDIO</p>"},{"location":"WorkingWithFarmDyn/CodeDevelopment/#gamd-ide-legacy","title":"GAMD IDE (legacy)","text":""},{"location":"WorkingWithFarmDyn/Gui/","title":"The Graphical User Interface (GUI)","text":"<p>The Graphical User Interface (GUI) is based on GGIG (GAMS Graphical Interface Generator, Britz 2014). It serves three main purposes:</p> <p>1. To prepare the data base for the model runs</p> <p>2. To steer model runs</p> <p>3. To exploit results from one or several model runs</p> <p>The creation of a visual user interface is also described as \"visual debugging\" (Grimm, 2002) to allow for an easy adjustment of parameters and quantitative and graphical examinations. With the help of only a few adjustments one can define single or multiple model farm runs for the interesting farm types with their specifications. Thereby, the former described coefficient generator helps to condense the necessary information for farm run definition by adjusting and calculating all production specific parameters to be consistent with the defined farm type (initial arable land, grass land, initial stables, initial manure storages, initial machine endowment...). After simulating the experiments, the GUI enables the user to systematically analyse the simulated model variables and results.</p> <p>A separate user handbook for the general use of the GUI is available at:</p> <p>Britz, W. (2010), GGIG Graphical Interface Generator User Guide, Institute for Food and Resource Economics, University Bonn, 147 pages, http://www.ilr.uni-bonn.de/em/rsrch/ggig/GGIG_user_Guide.pdf</p> <p>In the following, the different tabs of the GUI are shown and shortly described.</p>"},{"location":"WorkingWithFarmDyn/Gui/#work-step-and-task-selection-left-hand-side","title":"Work Step and Task Selection (Left Hand Side)","text":""},{"location":"WorkingWithFarmDyn/Gui/#built-data","title":"Built Data","text":"<p>In the Build data work step, the user can select raw data for the model run. Under the task Build data from user input, standard crops are available or the user can read in own data. Build data from KTBL provides a link to the German agricultural database of the \"Kuratorium f\u00fcr Technik und Bauwesen in der Landwirtschaft\" (KTBL). This task can be used to select KTBL data for various crops for the model run. To finish the \"Build data\" work step, the model must be started by clicking on Start Gams. A GAMS RC 0 indicates that the selection of raw data has worked.</p> <p></p>"},{"location":"WorkingWithFarmDyn/Gui/#single-farm-runs","title":"Single Farm Runs","text":"<p>In the Single farm runs work step, all run specific settings are to be set manually in the GUI. As these settings are very extensive, they will be explained in detail in the next sub-chapter. Again, a single farm run can be started by clicking on Start Gams and a GAMS RC 0 indicates a complete and successful model run.</p> <p></p> <p>The workstop Single farm runs provides also the option to run a farm sample, i.e. that not only one specific and predefined farm is simulated but multiple predefined farms can be run.</p>"},{"location":"WorkingWithFarmDyn/Gui/#experiments","title":"Experiments","text":"<p>In the Experiment work step, the user can define ranges for selected settings which are varied based on stratified random sampling using Design of Experiments for a defined number of experiment. For each experiment, a single farm run is solved. These single farm runs are typically solved in parallel. After they are finalized, their results are combined into one result set. The experiment tasks distinguish different farm branches. Additionally, an experiment to estimate the profit function can be selected. The Run Specific Settings are broadly similar to those of the Single Farm Run. In addition, there is the \"DOE\" and, depending on the selected task, the \"Factor Ranges\" and \"Input prices in experiments\" tab. These three are also explained in the next sub-chapter. An experiment model run is started with the same procedure as the other work steps.</p> <p></p>"},{"location":"WorkingWithFarmDyn/Gui/#run-specific-settings","title":"Run Specific settings","text":"<p>In the following, the run specific settings of all tabs of the GUI are explained. In addition, a subchapter deals with how this information can be stored.</p>"},{"location":"WorkingWithFarmDyn/Gui/#general-settings","title":"General Settings","text":"<p>The general settings are subdivided into five components:</p> <ol> <li> <p>Branches: The model run is named by the scenario description. FarmDyn uses this name to store the results of a model run. Therefore, it is important to change the name for a new model run to ensure that previous results are not overwritten. Additionally, the user can define active farm branches and the herd size definition for the current model run.</p> </li> <li> <p>Data: The user can determine regional data for the calculations in the model.</p> </li> <li> <p>Simulation Control: Additional settings regarding the model stochastics, the use of labour (off-farm work, hiring workers) and  the use of land (selling and leasing land) can be made.</p> </li> <li> <p>Calibration: FarmDyn can be calibrated on case study data if desired. By default, the check mark for calibrate is not set. FarmDyn in this case can either read in results from previous calibrations to use them for different simulations or resort to \u201cfarm_empty\u201d (the standard parameter). To perform a calibration on case study data, a checkmark must be set for calibrate. Additionally, a file with calibration targets must be stored under gams/calibFiles and be selected in the GUI as the \"file with calibration bounds\". The calibration bounds must be manually defined. </p> </li> <li> <p>Time and Investments: The user can define the model dynamics, the simulation period, the construction year of stables and the age of machinery. The model allows choosing between the following four mode to describe dynamics (or not): </p> </li> </ol>"},{"location":"WorkingWithFarmDyn/Gui/#farm-settings","title":"Farm Settings","text":"<p>The farm settings are subdivided into three components:</p> <ol> <li> <p>Land Endowments: The land endowment of the farm is specified. The user can decide in which way this information should be provided, e. g. as Total arab and grass land or Land endowment per animal. The requested information must then simply be filled in.</p> </li> <li> <p>Labour Endowments: This is where labour force available in the simulation is defined.</p> </li> <li> <p>Income and Taxes: The user can determine the tax system.</p> </li> </ol>"},{"location":"WorkingWithFarmDyn/Gui/#animals-pigs-cows-calves-heifers-and-bulls","title":"Animals (Pigs, Cows, Calves, Heifers and Bulls)","text":"<p>Depending on the chosen farm branches different tabs to further specify the simulated farm are activated. For pigs and sows only one tab exists, Pigs. In this tab, the user can specify the initial herd sizes. For cattle there are several tabs (Cows, Calves, Heifers and Bulls). These also allow the definition of the initial herd size. In addition, they allow further settings, which are explained below. Generally, the initial herd sizes are used to determine the stable endowment and manure storage capacities on the farm.</p> <p>In the tab Cows, the cows breed, the milk yield, the herd size, premiums, manure management in the stable, breeding attributes, grazing periods and calving and cow attributes are to be specified by the user. The grazing period is distinguished into grazing (animals outside day and night) and partial grazing (animals in stable over night).</p> <p></p> <p>The other cattle related tabs allow for the specification of the length of different growth periods and the respective start and end-weight, prices and the dress percentage of the potentially slaughtered animals. Similar to the cows, the grazing period and manure management system have to be specified. The tab Heifers is shown below as an example:</p> <p></p>"},{"location":"WorkingWithFarmDyn/Gui/#gras","title":"Gras","text":"<p>The gras tab is subdivided into two components:</p> <ol> <li> <p>Grassland, feed attributes: The user can change the different ingredients of the harvested products. The products are silage gras, grazed gras and hay. The products are further divided by the time of harvest: early, middle and late.</p> </li> <li> <p>Grassland, yield and yield distribution: This table specifies the month of harvest of the respective products, the total yield in dry matter (DM) and the distribution of the yield over the harvest month. Up to 10 different grassland usage options are derivable with differing management, yields and harvested products.</p> </li> </ol>"},{"location":"WorkingWithFarmDyn/Gui/#crops","title":"Crops","text":"<p>The crops tab is subdivided into five components:</p> <ol> <li> <p>Crops: A selection of crops predefined in the Build data work step can be seen. From these, the crops relevant to the present model run must be selected.</p> </li> <li> <p>Yield: This field shows default yields which the user can change manually.</p> </li> <li> <p>Management system, rotation: The user can make further settings concerning the crop intensity, the cultivation system, the technology, the tillage system, the use of crop rotations and the handling of catch crops.  </p> </li> <li> <p>Fertilization: Additional information on fertilizer planning can be provided.</p> </li> <li> <p>Plots and soil: The number of plots, the mechanization level and the climatic zone can be predefined.</p> </li> </ol>"},{"location":"WorkingWithFarmDyn/Gui/#biogas","title":"Biogas","text":"<p>Information:</p> <p>The biogas module has not been tested under the current FarmDyn version, therefore run time errors are very likely to occur when it is used.</p> <p></p> <p>The biogas tab is subdivided into four components:</p> <ol> <li> <p>Investment options/ activated EEGs: The user can specify the underlying Renewable Energy Act (EEG) version and the biogas plant size.</p> </li> <li> <p>Input use: The inputs provided for biogas use can be determined.</p> </li> <li> <p>Existing plant: This tab allows the set up of an existing biogas plant with the options to choose the size, the valid EEG and the construction year. However, to use this function the plant size and EEG has to be activated in the \"Investment options\" panel.</p> </li> <li> <p>Scenario premium setup: Additional settings regarding the scenario premiums can be defined here.</p> </li> </ol>"},{"location":"WorkingWithFarmDyn/Gui/#output-and-input-prices","title":"Output and Input Prices","text":"<p>In these two tabs, standard input and output prices are shown, which the user can adjust if necessary. It is also determined whether roughages may be bought and sold and the conditions for contract work are specified:</p> <p></p> <p></p>"},{"location":"WorkingWithFarmDyn/Gui/#environmental-impacts-and-restrictions","title":"Environmental Impacts and Restrictions","text":"<p>The environmental impact and restrictions tab is subdivided into five components:</p> <ol> <li> <p>Social impact assessment: A social impact assessment can be included in the model run if desired. For this purpose, a data basis must be determined.</p> </li> <li> <p>Compulsory CAP: The compulsory policy measure \"Greening\" of the Common Agricultural Policy (CAP) of the European Union is activated by default. Corresponding data is read into the model.</p> </li> <li> <p>Agri-environmental policy: In addition to the Greening policy, FarmDyn allows the modelling of further agri-environmental policies. By setting the corresponding check marks, new fields open up to read in data for these policies and to make further settings.</p> </li> <li> <p>Environmental impact assessment: In this tab, environmental accounting can be included in the model calculations. To do this, again the corresponding data must be read in. If desired, FarmDyn can also calculate various post-model biodiversity indicators to assess the impact of the modelled farm programme on regional biodiversity. This option must be activated by setting a check mark.</p> </li> </ol> <ol> <li>Fertilizer ordinance: In this tab, the modelled farm can be restricted to different German fertilizer ordinances (2007, 2017 and 2020). The user is able to set limits and thresholds himself.</li> </ol>"},{"location":"WorkingWithFarmDyn/Gui/#gams-and-solver","title":"GAMS and Solver","text":"<p>This tab defines the chosen solver to optimise the fully dynamic MIP problem and further precision adjustments. Furthermore options for the resulting listing files and debug options are offered depending on the user type. In general it is recommended to use CPLEX as the MIP solver.</p> <p></p>"},{"location":"WorkingWithFarmDyn/Gui/#doe-and-factor-ranges","title":"DOE and Factor Ranges","text":"<p>In the design of experiments one can select the number of farms that are supposed to be simulated. Further, other options are available to setup the experiment from a more technical viewpoint such as the number of parallel farm simulations, loading of previous results etc.</p> <p>Based on the selected farm branch on the left hand side under FarmDyn tasks, factor options are presented in a list. They differentiate between general factors (e.g. investment prices invPrice or wage rates wageRateFull), branch specific factors (e.g. number of cows nCows or grassland nGrasLand), and crop specifics price factors (e.g. winterWheat prices WinterWheatPrice, etc.)</p> <p> </p> <p>After the selection of factors for the experiments, one has to define their ranges which are to vary between each simulation. From the predefined factor range a value is chosen based on a stratified random sampling (Latin-Hyper cube) approach.</p> <p></p> <p></p>"},{"location":"WorkingWithFarmDyn/Gui/#saving-run-specific-settings","title":"Saving Run Specific Settings","text":"<p>By default, FarmDyn saves the run specific settings in an .ini file - \"dairydyn.ini\". This can be seen in the main menu of the GUI at the bottom left:</p> <p></p> <p>Via Settings in the toolbar at the top left, the user has the possibility to save the current settings in another .ini file, so that they will not be overwritten by FarmDyn the next time the GUI is used. To do this, the user must click on the field save current settings to ini file:</p> <p></p> <p>The run specific settings from an .ini file can also be read back into the GUI under Settings and then Load settings from ini file:</p> <p></p> <p>In addition, FarmDyn stores the run specific settings after a successful model run in a GAMS include file. By default, this is located under gams/incgen and is called \"runInc.gms\". To be on the safe side, it is recommended to copy and rename the \"runInc.gms\" file in addition to saving the run specific settings in an .ini file so that it is not overwritten in a new model run. If an .ini file is damaged or lost, it is possible to load the run specific settings from the runInc file in the GUI. To do this, the user must click on Add settings from include file under Settings:</p> <p></p>"},{"location":"WorkingWithFarmDyn/Gui/#visualising-and-analysing-results-in-the-gui","title":"Visualising and Analysing Results in the GUI","text":"<p>After a successful simulation (GAMS RC 0, status \"normal completion\") the results are saved in a GDX file under results/expFarms.</p> <p>The results can be viewed with any GDX Viewer. However, the GUI of FarmDyn also offers a result analysis tool with which the user can plot the results in tables or graphs. There are numerous possibilities to adapt the tables and graphs to one's own analysis goals. In addition, the data in the GUI's result analysis tool can also be copied or exported.</p> <p>To be redirected to the result analysis section, one has to press Exploit results to the right of Start Gams. Now, the scenarios for which results should be analysed can be selected. Keep in mind that results are stored with the scenario description given under General Settings - Branches:</p> <p></p> <p>Another click on Show results then opens the actual results analysis section.</p> <p></p> <p>The result analysis is based on a set of pre-defined reports, grouped by themes. Currently, the following themes (and reports) are available:</p> <ul> <li>Farm program - Animal, mean (incl. herd summary, feeding by herds and stable utilization)</li> <li>Farm program - Animal, time series (incl. herd summary, feeding by herds and stable utilization)</li> <li>Farm program - Crops, mean (incl. crop summary and tillage type)</li> <li>Farm program - Crops, time series (incl. crop summary and tillage type)</li> <li>Assets, mean (incl. buildings and machines)</li> <li>Assets, time series (incl. buildings and machines)</li> <li>Work, mean (incl. work and off-farm work)</li> <li>Work, time series (incl. work and off-farm work)</li> <li>Economics, mean (incl. revenues, costs, cash balance, production and related revenues)</li> <li>Economic, time series (incl. revenues, costs, cash balance, production and related revenues)</li> <li>Nitrogen (incl. mean and time series information per ha and as N balance)</li> <li>Phosphate (incl. mean and time series information per ha and as P2O5 balance)</li> <li>Environmental policy (incl. core variables, emissions, N balance and P balance)</li> <li>Biodiversity (incl. SMART, SALCA, SALCA crop perspective and Paracchini)</li> <li>Algorithm (incl. model attributes)</li> </ul> <p>A blue-grey eye can be seen at the top left. This allows you to switch back and forth between the different results tables.</p> <p></p> <p></p> <p>The results analysis section has other useful functions that support the results analysis. A toolbar can be seen at the top right:</p> <p></p> <p>The tools from left to right allow to copy the data, export the data, customize the table view and to pivot the table.</p>"},{"location":"WorkingWithFarmDyn/Gui/#working-with-projects","title":"Working with Projects","text":"<p>When applying FarmDyn to a set of different case studies, keeping track of the individual case study settings in the <code>.ini</code> files may become tedious.</p> <p>In order to ease the handling, you can define so called projects. These projects can be managed from the user interface. The concept of projects is similar for any model using GGIG (FarmDyn, Capri etc.), so one can also refer to the official user guide.</p>"},{"location":"WorkingWithFarmDyn/Gui/#setting-up-a-new-project","title":"Setting up a New Project","text":"<p>To create a new project, the user needs to be logged in with the user type Administrator. The current user type can be seen in the status bar at the bottom left of the GUI window:</p> <p></p> <p>The user type can be changed by clicking on Settings in the menu bar at the top left and then on Edit Settings. A new project can then be created in the user type administrator by clicking on File in the toolbar and then New Project. The following dialog box then opens:</p> <p></p> <p>The dialog comprises four tabs. The first tab \u201cCore info\u201d shown above comprises information on the project itself. The entries \u201cPdf\u201d, \u201cMailto\u201d and \u201cWebpage\u201d generate new items in the top menu bar and provide information on the application context to the user.</p> <p>The second tab \u201cDefaults\u201d comprises a list of GUI controls of the tool with their title and its default setting:</p> <p></p> <p>The left hand side shows the title of the control, the right hand side comprises a text field with the default settings as stored in the XML-definition file for the GUI. This default can be overwritten with a project specific one. Only these differences are stored.</p> <p>Similarly, the two remaining tables show under \u201cSystem settings\u201d the location of system directories, and under \"SVN\" optional project specific SVN settings.</p> <p>Once you press the Generate project button, a new file called <code>project_YourProjectName_default.ini</code>, where \"YourProjectName\" will be replaced by the name you entered for the project, will be created in FarmDyn's GUI directory.</p>"},{"location":"WorkingWithFarmDyn/Gui/#switching-projects","title":"Switching Projects","text":"<p>To switch between projects klick on File -&gt; Set Project -&gt; Project Name in the menu bar at the top left:</p> <p></p> <p>The currently selected project will be displayed in the status bar at the bottom left corner:</p> <p></p>"},{"location":"WorkingWithFarmDyn/Gui/#editing-projects","title":"Editing Projects","text":"<p>This option is also only possible in the user type administrator (see here).</p> <p>An existing project can then be edited by choosing File -&gt; Edit Project -&gt; Project Name. The project dialog as described under Setting up a new Project will then be opened. The necessary changes can be done there.</p> <p>The changes have to be saved by clicking on the Update project button. Notice that the dialog window will not close automatically after the changes were saved.</p>"},{"location":"WorkingWithFarmDyn/Gui/#important-information-on-the-project-workflow","title":"Important Information on the Project Workflow","text":"<p>Please notice that the projects default settings from the GUI tabs cannot be changed. The idea is as follows: In the project settings, the default values displayed in the GUI tabs are stored. However, changing these settings in the GUI will not affect the project defaults. This way sensitivity analysis or tests with certain settings can be done without losing the default project values and without breaking any important project specifics. If the tests turn out to be working fine, you may update the project defaults as described above.</p>"},{"location":"WorkingWithFarmDyn/Gui/#references","title":"References","text":"<p>Britz, W. (2010): GGIG Graphical Interface Generator User Guide, Institute for Food and Resource Economics, University Bonn, 147 pages, http://www.ilr.uni-bonn.de/em/rsrch/ggig/GGIG_user_Guide.pdf.</p> <p>Britz, W. (2014): A New Graphical User Interface Generator for Economic Models and its Comparison to Existing Approaches, German Journal of Agricultural Economics, 63(4): 271-285.</p> <p>(Grimm, 2002)</p>"},{"location":"WorkingWithFarmDyn/Installation/","title":"FarmDyn Installation","text":"<p>To obtain the latest model version from the version control server login credentials (username, password) are required. If you are not a registered user yet please feel free to contact us.</p>"},{"location":"WorkingWithFarmDyn/Installation/#prerequisites","title":"Prerequisites","text":""},{"location":"WorkingWithFarmDyn/Installation/#java","title":"Java","text":"<p>To run the FarmDyn model, a working Java installation with a Version &gt; 8 is required and needs to be in the path variable. It can be acquired free of charge from the official Java website.</p>"},{"location":"WorkingWithFarmDyn/Installation/#svn","title":"SVN","text":"<p>FarmDyn is using the centralized version control system Subversion (short SVN). In order to obtain, be able to update, or eventually commit changes to the model, a so called SVN client needs to be installed on the computer. The client of choice depends on the operating system in use:</p>"},{"location":"WorkingWithFarmDyn/Installation/#windows","title":"Windows","text":"<p>TortoiseSVN is used at our Institute. The following examples are thus conducted using TortoiseSVN. However, other SVN clients (or CLIs) may work as well.</p>"},{"location":"WorkingWithFarmDyn/Installation/#macos","title":"MacOS","text":"<p>SnailSVN is a TortoiseSVN look-alike for MacOS. Most features therefore look and act like their Windows counter-part. The free version offers only one repo to be checked out, which should be sufficient in most use cases.</p>"},{"location":"WorkingWithFarmDyn/Installation/#linux","title":"Linux","text":"<p>RabbitVCS is a graphical SVN-client for Linux. It hasn't been officially tested with FarmDyn yet.</p>"},{"location":"WorkingWithFarmDyn/Installation/#gams-optional","title":"GAMS (optional)","text":"<p>FarmDyn may be operated without an installation of GAMS. However, without a valid GAMS installation, including a valid license file, the model cannot be run (-&gt; only existing results may be inspected). FarmDyn requires a GAMS Version &gt; 25.0 to fully operate. GAMS can be acquired from the official website. Note that degree granting institution may qualify for a free GAMS license.</p>"},{"location":"WorkingWithFarmDyn/Installation/#installation-process","title":"Installation Process","text":"<p>To start the installation, navigate to a directory where you would like to store the FarmDyn main folder, e.g. your <code>Documents</code> folder.</p> <p>In this directory, create a new folder, e.g. <code>FarmDyn</code>.</p> <p>Perform a right click on the folder and select <code>SVN checkout</code></p> <p></p> <p>Enter the SVN URL you received from our institute in the Checkout dialog box which appeared and click the OK button.</p> <p></p> <p>If you did not enter your credentials before, you will be asked to input these before the checkout will proceed.</p> <p>Once the checkout process is finished, close the dialog box by clicking OK again.</p> <p>To finish the installation, we must now open the Graphical User Interface (GUI) of the model.</p>"},{"location":"WorkingWithFarmDyn/Installation/#starting-farmdyn","title":"Starting FarmDyn","text":"<p>To do so, navigate into the <code>GUI</code> folder in the directory where you saved FarmDyn.</p> <p>If you followed the above example with TortoiseSVN, the path will look similar to:</p> <p><code>C:\\Users\\YourUsername\\Documents\\FarmDyn\\GUI</code></p> <p>In the <code>GUI</code> folder, double-click the <code>dairydyn.bat</code> file to open FarmDyn's GUI.</p> <p></p> <p>If everything was set-up correctly, you will see the following loading screen:</p> <p></p> <p>Upon first start, a dialog window will appear asking to enter the path to the GAMS version with which the model is to run in the settings.</p> <p></p> <p>Proceed by clicking the OK button. You will then be presented with the main menu of the program.</p> <p></p>"},{"location":"WorkingWithFarmDyn/Installation/#setting-up-gams","title":"Setting up GAMS","text":"<p>In case you have a valid GAMS installation on your computer, you may finalize the installation by setting up the correct GAMS path. Therefore, select Settings -&gt; Edit Settings in the main menu of FarmDyn.</p> <p></p> <p>A dialog box will open. Select the GAMS and R tab.</p> <p>In the <code>Path to GAMS.exe</code> input field, paste the path to the GAMS executable on your system. In most cases, this will be similar to <code>C:\\GAMS\\win64\\25.x\\gams.exe</code>, where x needs to be substituted by the actual GAMS version number on your system.</p> <p>Once you are done, click the Save in dairydyn.ini button. FarmDyn is now fully operational (as long as a valid GAMS license is present).</p> <p></p>"},{"location":"WorkingWithFarmDyn/Videos/","title":"Training Videos","text":""},{"location":"WorkingWithFarmDyn/Videos/#presentation-of-the-farmdyn-model","title":"Presentation of the FarmDyn Model","text":""},{"location":"WorkingWithFarmDyn/Videos/#part-1-introduction-to-bio-economic-farm-scale-modelling","title":"Part 1: Introduction to Bio-economic Farm-Scale Modelling","text":""},{"location":"WorkingWithFarmDyn/Videos/#part-2-modelling-a-single-farm-run","title":"Part 2: Modelling a Single Farm Run","text":""},{"location":"WorkingWithFarmDyn/Videos/#part-3-simulation-runs-and-result-analysis","title":"Part 3: Simulation Runs and Result Analysis","text":""},{"location":"WorkingWithFarmDyn/Videos/#part-4-coding-insights","title":"Part 4: Coding Insights","text":""},{"location":"WorkingWithFarmDyn/Videos/#running-a-beef-farm-experiment","title":"Running a Beef Farm Experiment","text":""},{"location":"publications/publications/","title":"Publications","text":""},{"location":"publications/publications/#phd-theses","title":"PhD Theses","text":"<p>PAHMEYER, CHRISTOPH (2022): Advances in technology evaluation and decision support studies using bio-economic farm models Dissertation, University of Bonn</p> <p>SCH\u00c4FER, DAVID MATTHIAS (2021): Biogas production in the light of the German Fertilization Ordinance : An economic and environmental assessment at farm and regional scale.</p> <p>KUHN, TILL (2019): The revision of the German Fertilization Ordinance in 2017: Analyzing economic and environmental impacts at farm-level. Dissertation, University of Bonn.</p> <p>GABERT, JOHANNA (2013): \u00d6konomische Auswirkungen von Politiken zur Umsetzung der Wasserrahmenrichtlinie auf die Schweinehaltung im M\u00fcnsterland. Dissertation, University of Bonn.</p> <p>LENGERS, BERND (2013): The relation between indicators for the crediting of emission rights and abatement costs : a systematic modeling approach for dairy farms. Dissertation, University of Bonn.</p>"},{"location":"publications/publications/#journal-publications","title":"Journal publications","text":"<p>HUBER, R., TARRUELLA, M., SCH\u00c4FER, D., FINGER, R., (2023): Marginal climate change abatement costs in Swiss dairy production considering farm heterogeneity and interaction effects, Agricultural Systems (207): 103639</p> <p>KOKEMOHR, L., ESCOBAR, N., MERTENS, A., MOSNIER, C., PIRLO, G., VEYSSET, P., KUHN, T. (2022): Life Cycle Sustainability Assessment of European beef production systems based on a farm-level optimization model, Journal of Cleaner Production 379(1): 134552</p> <p>KUHN, T., M\u00d6HRING, N., T\u00d6PEL, A., JAKOB, F., BRITZ, W., BR\u00d6RING, S., PICH, A., SCHWANEBERG, U., RENNINGS, M. (2022): Using a bio-economic farm model to evaluate the economic potential and pesticide load reduction of the greenRelease technology, Agricultural Systems 201:103454</p> <p>BRITZ, W., CIAIAN, P., GOCHT, A., KANELLOPOULOS, A., KREMMYDAS, D., M\u00dcLLER, M., PETSAKOS, A., REIDSMA, P. (2021): A design for a generic and modular bio-economic farm model, Agricultural Systems 191(June 2021): 103133.</p> <p>HEINRICHS, J., JOUAN, J., PAHMEYER, C., BRITZ, W. (2021): Integrated assessment of legume production challenged by European policy interaction: A case-study approach from French and German dairy farms, QOpen 1(1): 1-19.</p> <p>HEINRICHS, J., KUHN, T., PAHMEYER, C., BRITZ, W. (2021): Economic effects of plot sizes and farm-plot distances in organic and conventional farming systems: A farm-level analysis for Germany, Agricultural Systems 187: 1029922020.</p> <p>KUHN, T., ENDERS, A., GAISER, T., SCH\u00c4FER, D., SRIVASTAVA, A., BRITZ, W. (2020): Coupling crop and bio-economic farm modelling to evaluate the revised fertilization regulations in Germany, Agricultural Systems 127(May 2020): 104656.</p> <p>PAHMEYER, C., BRITZ, W. (2020): Economic opportunities of using crossbreeding and sexing in Holstein dairy herds, Journal of Dairy Science 103(9): 8218-8230.</p> <p>SEIDEL, C., BRITZ, W. (2020): Estimating a Dual Value Function as a Meta-Model of a Detailed Dynamic Mathematical Programming Model, Bio-Based and Applied Economics, 8(1), 75-99.</p> <p>KUHN, T., SCH\u00c4FER, D., HOLM-M\u00dcLLER, K., BRITZ, W. (2019): On-farm compliance costs with the EU-Nitrates Directive: A modelling approach for specialized livestock production in northwest Germany, Agricultural Systems 173: 233-243.</p> <p>SCH\u00c4FER, D., BRITZ, W., KUHN, T. (2017): Flexible Load of Existing Biogas Plants: A Viable Option to Reduce Environmental Externalities and to Provide Demand-driven Electricity?, German Journal of Agricultural Economics 66(2): 109-123.</p> <p>LENGERS, B., BRITZ, W., HOLM-M\u00dcLLER, K. (2014): What drives marginal abatement costs of greenhouse gases on dairy farms? A meta-modeling approach, Journal of Agricultural Economics 65(3): 579\u2013599.</p> <p>LENGERS, B., SCHIEFLER, I. &amp; B\u00dcSCHER,  W. (2013): A comparison of emission calculations using different modeled indicators with 1-year online measurements, Journal of Environmental Monitoring and Assessment, 185:9751-9762.</p> <p>LENGERS, B.,  BRITZ, W., HOLM-M\u00dcLLER, K. (2013): Comparison of GHG-emission indicators for dairy farms with respect to induced abatement costs, accuracy and feasibility, Applied Economic Perspectives and Policy, 35(3):451-475.</p> <p>LENGERS, B.,  BRITZ, W. (2012): The choice of emission indicators in environmental policy design: an analysis of GHG abatement in different dairy farms based on a bio-economic model approach, Review of Agricultural and Environmental Studies, 93(2), 117-144.</p>"},{"location":"publications/publications/#contributions-to-conferences-and-lecture-series","title":"Contributions to conferences and lecture series","text":"<p>HEINRICHS, J., KUHN, T., PAHMEYER, C., BRITZ, W. (2021): The effects of plot sizes and farm-plot distances in organic and conventional farming systems: An economic analysis at farm level. Poster presentation, European Association of Agricultural Economists (EAAE), 16th congress: \u201e Raising the impact of agricultural economics: multidisciplinarity, stakeholder engagement and noval approaches \u201c , Prague, Czech Republic, 20-23th July 2021.</p> <p>HEINRICHS, J., KUHN, T., PAHMEYER, C., BRITZ, W. (2020): The differentiated effects of plot sizes and farm-field distances in organic and conventional farming systems: An economic analysis at farm level. Poster presentation, German Association of Agricultural Economists (GEWISOLA), 60th annual conference: \u201e Herausforderungen f\u00fcr die l\u00e4ndliche Entwicklung - Wirtschafts- und sozialwissenschaftliche Perspektiven\u201c , Halle (Saale), Germany, 23-25th September 2020.</p> <p>KOKEMOHR, L., KUHN, T., ESCOBAR, N., BRITZ, W. (2020): Life Cycle Sustainability Assessment of beef production in Germany based on a farm level optimization model, selected paper presented at the 12th International Conference on Life Cycle Assessment of Food 2020 (LCA Food 2020) \u201cTowards Sustainable Agri-Food Systems\u201d (Virtual Conference).</p> <p>JOUAN, J., HEINRICHS, J., BRITZ, W., PAHMEYER, C. (2019): Legume production challenged by European policy coherence: a case-study approach from French and German dairy farms, selected paper presented at the 172nd EAAE seminar: \u201eAgricultural policy for the environment or envrionmental policy for agriculture\u201c, Brussels (Belgium), 28-29th May 2019.</p> <p>ZENG, W., GAISER, T., ENDERS, A., KUHN, T., SCH\u00c4FER, D., BRITZ, W. (2018): Developing a Crop Model for N Management of Crop Rotations in North Rhine-Westphalia, Germany, Presentation, International Environmental Modelling and Software Society Conference, July 2018, Fort Collins.</p> <p>KUHN, T., SCH\u00c4FER, D., BRITZ, W. (2017): Estimating impacts of the revised German fertilizer ordinance on manure transport flows within North Rhine-Westphalia, poster presented at the EAAE XVth Congress, Parma (Italy).</p> <p>SCH\u00c4FER, D., BRITZ, W. (2017): Estimating impacts of the revised German fertilizer ordinance on manure transport flows within North Rhine-Westphalia, poster presented at the EAAE XVth Congress, Parma (Italy).</p> <p>SEIDEL, C., BRITZ, W. (2017): Can we derive plausible land rents based on Mathematical Programming? A critical assessment of a dual profit function estimation from simulated farm programs, selected paper presented at the EAAE XVth Congress, Parma (Italy).</p> <p>SCH\u00c4FER, D., SEIDEL, C., BRITZ, W. (2016): Estimating Dual Profit Functions to Depict Farmer Behavior in Agent-Based Models \u2013 a Meta-Modeling Approach, poster presented at the 56th Annual Conference of the German Association of Agricultural Economists (GEWISOLA), Bonn, 28-30 September 2016.</p> <p>REMBLE, A., BRITZ, W., KEENEY, R. (2013): Farm Level Tradeoffs in the Regulation of Greenhouse Gas Emissions, selected paper presented at the Agricultural and Applied Economics Association, 2013 Annual Meeting, August 4-6, 2013, Washington, D.C (USA).</p> <p>LENGERS, B., BRITZ, W., HOLM-M\u00dcLLER, K. (2013): What drives marginal abatement costs of greenhouse gases on dairy farms - a meta-modeling approach. Paper presented at the 2012 AUR\u00d6-Workshop, Frankfurt (Oder), Germany, February 18-19.</p> <p>BRITZ, W., LENGERS, B. (2012): Abatement options for GHG emissions in a dynamic bio-economic model for dairy farms - DAIRYDYN. Presentation contributed to the CIDRe lecture series \u201cmodeling across scales and disciplines\u201d. University of Bonn, 09.10.2012.</p> <p>BRITZ, W., LENGERS, B. (2011): Farm specific marginal abatement costs for dairy GHG emissions which base upon different emission indicators - a bio-economic model approach, selected paper presented at the 2011 EAAE PhD Workshop, April 27-29, 2011, Nitra (Slovak Republic)</p>"},{"location":"publications/publications/#discussion-and-technical-papers","title":"Discussion and technical papers","text":"<p>LENGERS, B., BRITZ, W., HOLM-M\u00dcLLER, K. (2013): Trade-off of feasibility against accuracy and cost efficiency in choosing indicators for the abatement of GHG-emissions in dairy farming, Discussion Paper 2013.</p> <p>LENGERS, B.(2012): Construction of different GHG accounting schemes for approximation of dairy farm emissions, Technical Paper referring to DFG-project HO 3780/2-1.</p> <p>LENGERS, B. (2012): Up to date relevant GHG abatement options in German agricultural dairy production systems, Technical Paper referring to DFG-project HO 3780/2-1. Institute for Food and Resource Economics, University of Bonn.</p> <p>LENGERS, B. (2011): GHG survey of German agriculture-specific view on dairy production systems, Technical Paper referring to DFG-project HO 3780/2-1.</p>"},{"location":"publications/publicationsCode/","title":"Special Code Lines of Individual Publications","text":"<p>There are individual FarmDyn extensions which were used exclusively for publications and cannot be found on the head revision of FarmDyn. These code parts are therefore not explained in the model description, but below under the respective authors and year.</p>"},{"location":"publications/publicationsCode/#journal-publications","title":"Journal publications","text":""},{"location":"publications/publicationsCode/#kuhn-t-schafer-d-holm-muller-k-britz-w-2019","title":"KUHN, T., SCH\u00c4FER, D., HOLM-M\u00dcLLER, K., BRITZ, W. (2019):","text":"<p>FarmDyn is loosely connected to the crop modeling framework SIMPLACE. This crop model provides cropping activities consisting of different managements and corresponding yields and externalities. They are provided as a gdx file and loaded into FarmDyn. The parameter p_simres contains all information from the crop model for different crops, crop rotations (represented in the set till) and intensities. Intensities represent a whole range of management, consisting of different amounts of fertiliser, straw removal and catch crop growing. The elements of the set contain the information on yields and externalities for the different cropping activities.</p> <p>The use of the SIMPLACE data is activated in the GUI by selecting the BWA mode. It requires to choose specific farm types and their location in different soil-climate regions. Currently, SIMPLACE data are available for the German Federal State of North Rhine-Westphalia.</p> <p>First, the shares of different crops in FarmDyn have to equal the crop rotation represented in the SIMPLACE data. Crop rotations can be selected at the GUI.</p> <pre><code>SimplaceRot_(c_s_t_i(curCrops(crops),plot,curRotTill(till),intens),tCur(t),nCur)\n                     $ ( (v_cropHa.up(crops,plot,till,intens,t,nCur) ne 0) $ t_n(t,nCur)\n                     $ (not sameas (crops,\"idle\") )\n                     $ (not sameas (crops,\"catchcrop\") )  ) ..\n\n       v_cropHa(crops,plot,till,intens,t,nCur)\n\n           =e=\n\n             sum ( crops1 $  (c_s_t_i(crops1,plot,till,intens) $ (curCrops(crops1)\n                              $ (not sameas(crops1,\"idle\"))\n                              $ (not sameas(crops1,\"catchcrop\")))),\n                     v_cropHa(crops1,plot,till,intens,t,nCur))    *   p_cropShare(till,crops);\n</code></pre> <p>The synthetic fertiliser need linked to cropping activities in the SIMPLACE data has to be provided by synthetic fertiliser distribution in FarmDyn.</p> <pre><code>NMineralSim_(c_s_t_i(curCrops(crops),plot,curRotTill(till),intens),\"N\",tCur(t),nCur)\n                     $ ((v_cropHa.up(crops,plot,till,intens,t,nCur) ne 0) $ t_n(t,nCur)   $   (not sameas (curCrops,\"catchcrop\") ) $ (not sameas (curCrops,\"idle\") )    ) ..\n\n           sum ( (syntFertilizer,m) , v_syntDist(crops,plot,till,intens,syntFertilizer,t,nCur,m)  * p_nutInSynt(syntFertilizer,\"N\")\n                           * (1 - p_EFApplMinNH3(syntFertilizer) -  p_EFApplMin(\"N2O\") - p_EFApplMin(\"NOx\") ) )\n\n           =e=\n\n               v_cropHa(crops,plot,till,intens,t,nCur) *  p_SimRes(till,crops,intens,\"Nchem\")\n;\n</code></pre> <p>The cropping activities in the SIMPLACE data correspond to the month January to June. Accordingly, manure application has to be conducted in those months. Note that other restrictions such as the Fertilisation Ordinance may restrict application in certain months.</p> <pre><code>NOrgSpringSim_(c_s_t_i(curCrops(crops),plot,curRotTill(till),intens),\"N\",tCur(t),nCur)\n                  $ ((v_cropHa.up(crops,plot,till,intens,t,nCur) ne 0) $ t_n(t,nCur)  $ (not sameas (curCrops,\"catchcrop\") ) $ (not sameas (curCrops,\"idle\") )  ) ..\n\n\n*                --- NOrg Applied\n\n                  sum( (manApplicType_manType(ManApplicType,curManType),m_spring(m) )\n                   $ (v_manDist.up(crops,plot,till,intens,manApplicType,curManType,t,nCur,m_spring) ne 0),\n                       v_manDist(crops,plot,till,intens,ManApplicType,curManType,t,nCur,m_spring )\n                          * sum(manChain_applic(manChain,ManApplicType), p_nut2inMan(\"NOrg\",curManType,manChain)) * (1 - ( p_EFApplMin(\"N2O\") + p_EFApplMin(\"NOx\")))  )\n\n*               -- NTAN applied minus losses with application\n\n                + sum( (manApplicType_manType(ManApplicType,curManType),m_spring(m) )\n                    $ (v_manDist.up(crops,plot,till,intens,manApplicType,curManType,t,nCur,m_spring) ne 0),\n                       v_manDist(crops,plot,till,intens,ManApplicType,curManType,t,nCur,m_spring)\n                           * sum(manChain_applic(manChain,ManApplicType), p_nut2inMan(\"NTan\",curManType,manChain))\n                               * (p_nut2UsableShare(crops,curManType,ManApplicType,\"NTAN\",m) - ( p_EFApplMin(\"N2O\") + p_EFApplMin(\"NOx\")) )\n                                   )\n                   =e=\n\n                       v_cropHa(crops,plot,till,intens,t,nCur) *   p_SimRes(till,crops,intens,\"NOrgS\")\n\n                                        ;\n</code></pre> <p>In line with manure application in spring, the manure application in autumn linked to cropping activities in the SIMPLACE data has to be provided by manure application in FarmDyn in the months July to December.</p> <pre><code>NOrgAutumnSim_(c_s_t_i(curCrops(crops),plot,curRotTill(till),intens),\"N\",tCur(t),nCur)\n                  $ ((v_cropHa.up(crops,plot,till,intens,t,nCur) ne 0) $ t_n(t,nCur)\n                   $ (not sameas (crops,\"catchcrop\") ) $ (not sameas (crops,\"idle\") )  ) ..\n\n\n*                --- NOrg Applied\n\n                  sum( ( manApplicType_manType(ManApplicType,curManType),m_autumn(m) )\n                   $ (v_manDist.up(crops,plot,till,intens,manApplicType,curManType,t,nCur,m_autumn) ne 0),\n                       v_manDist(crops,plot,till,intens,ManApplicType,curManType,t,nCur,m_autumn )\n                          * sum(manChain_applic(manChain,ManApplicType), p_nut2inMan(\"NOrg\",curManType,manChain)) * (1 - ( p_EFApplMin(\"N2O\") + p_EFApplMin(\"NOx\")))   )\n\n*               -- NTAN applied minus losses with application\n\n                + sum(  ( manApplicType_manType(ManApplicType,curManType),m_autumn(m) )\n                    $ (v_manDist.up(crops,plot,till,intens,manApplicType,curManType,t,nCur,m_autumn) ne 0),\n                       v_manDist(crops,plot,till,intens,ManApplicType,curManType,t,nCur,m_autumn)\n                           * sum(manChain_applic(manChain,ManApplicType), p_nut2inMan(\"NTan\",curManType,manChain))\n                               * ( p_nut2UsableShare(crops,curManType,ManApplicType,\"NTAN\",m)  - ( p_EFApplMin(\"N2O\") + p_EFApplMin(\"NOx\"))  )\n                                     )\n\n                  =e=\n\n                       v_cropHa(crops,plot,till,intens,t,nCur) *  p_SimRes(till,crops,intens,\"NOrgA\") ;\n</code></pre> <p>The cropping activities provided by SIMPLACE do not contain information on P2O5 fertiliser need. Therefore, the following equation ensures that P2O5 removal with the harvested product has to be meet by P2O5 from manure and chemical fertiliser.</p> <pre><code>PFertilizingSim_(\"P\",tCur(t),nCur)  $ t_n(t,nCur)  ..\n\n                sum( (prods,c_s_t_i(curcrops(crops),plot,till,intens))   $ (  ( not sameas (prods,\"WCresidues\")) $ ( not sameas (prods,\"WBresidues\")) $ (not sameas (prods,\"SCresidues\"))\n                                                                             $ (not sameas (curCrops,\"catchcrop\") )  $ (not sameas (curCrops,\"idle\") )   )\n                            ,  p_SimRes(till,crops,intens,\"yield\")  * p_nutContent(crops,prods,\"P\") * 10/1000\n                                                                            * v_cropHa(crops,plot,till,intens,t,nCur)   )\n\n                     =l=\n\n$iftheni.man %manure% == true\n\n                      sum( (manApplicType_manType(ManApplicType,curManType),m,c_s_t_i(curCrops(crops),plot,till,intens))  $ (  (not sameas (curCrops,\"catchcrop\") )  $ (not sameas (curCrops,\"idle\") )\n                         $ (   v_manDist.up(crops,plot,till,intens,manApplicType,curManType,t,nCur,m) ne 0)     ),\n                            v_manDist(crops,plot,till,intens,ManApplicType,curManType,t,nCur,m)\n                              * sum(manChain_applic(manChain,ManApplicType), p_nut2inMan(\"P\",curManType,manChain))\n\n                             )\n\n                            +\n\n$endif.man\n\n                       sum ( (syntFertilizer,m,c_s_t_i(curcrops(crops),plot,till,intens) ) $(  (not sameas (curCrops,\"catchcrop\") )  $ (not sameas (curCrops,\"idle\") )  )\n                                   , v_syntDist(crops,plot,till,intens,syntFertilizer,t,nCur,m)  * p_nutInSynt(syntFertilizer,\"P\")  )\n                                                           ;\n</code></pre> <p>Some crops require minimum chemical fertiliser doses such as the starter fertilisation of maize. For N, minimum chemical fertiliser needs are reflected in the SIMPLACE results. For P2O5, the following equations ensures that the minimum chemical fertiliser needs is met.</p> <pre><code>MinChemFertSimplace_(tCur(t),nCur)    $ t_n(t,nCur)  ..\n\n                sum( (c_s_t_i(curcrops(crops),plot,till,intens))   $ (  (not sameas (curCrops,\"catchcrop\") )  $ (not sameas (curCrops,\"idle\") )  )\n                            ,   v_cropHa(crops,plot,till,intens,t,nCur) * p_minChemFert(crops,\"P\")\n                                         )\n\n                                    =l=\n\n                 sum ( (syntFertilizer,m,c_s_t_i(curcrops(crops),plot,till,intens) )  $ (  (not sameas (curCrops,\"catchcrop\") )  $ (not sameas (curCrops,\"idle\") )  )\n                                   , v_syntDist(crops,plot,till,intens,syntFertilizer,t,nCur,m)   * p_nutInSynt(syntFertilizer,\"P\")  )\n                                                     ;\n</code></pre> <p>The SIMPLACE results contain scenarios, captured in the set intensities, with and without residue removal. Thereby, it is assumed that straw from cereal production can be sold. The following equation maps the cropping activities on the variable v_residuesRemoval which is used in other parts of FarmDyn to calculate the costs and revenues related to residue removal.</p> <pre><code>ResidRemovalSim_(curCrops(crops),plot,till,intens,tCur(t),nCur)\n                 $ ( t_n(t,nCur) $  c_s_t_i(crops,plot,till,intens)  $ (not sameas (curCrops,\"catchcrop\") )  $ (not sameas (curCrops,\"idle\"))\n                                $ intensResRem(intens)   $ cropsResidueRemo(crops)  ) ..\n\n                     v_residuesRemoval(crops,plot,till,intens,t,nCur)    =e=          v_cropHa(crops,plot,till,intens,t,nCur)  ;\n</code></pre> <p>The SIMPLACE results contain scenarios, captured in the set intensities, with and without catch crops. They are linked to the catch crop growing represented in v_cropHa.</p> <pre><code>CatchCropsSimHa_(plot,curRotTill(till),intens,tCur(t),nCur)\n                $ ( t_n(t,nCur) $ (sum (crops, c_s_t_i(crops,plot,till,intens)))     ) ..\n\n            sum (c_s_t_i(\"catchCrop\",plot,till,intens), v_cropHa(\"catchCrop\",plot,till,intens,t,nCur)    )\n\n                                   =e=\n                                         sum( c_s_t_i(curCrops(crops),plot,till,intens) $ intensCatchCro(intens),\n                                                           v_cropHa(crops,plot,till,intens,t,nCur)\n                                                               *  p_SimRes(till,crops,intens,\"catCroShare\")   )\n                                           ;\n</code></pre> <p>The SIMPLACE results contain nitrate leaching for the different cropping activities. This externality is summarised in the following equation for the environmental accounting in FarmDyn.</p> <pre><code>NleachSim_(curCrops(crops),tCur(t),nCur)\n                 $ ( t_n(t,nCur) $ sum ( (plot,till,intens), c_s_t_i(crops,plot,till,intens)) $ (not sameas (curCrops,\"catchcrop\") )  $ (not sameas (curCrops,\"idle\") )  ) ..\n\n\n                 v_NleachSim(crops,t,nCur)\n\n                       =e=\n\n                          sum( c_s_t_i(curCrops,plot,curRotTill,intens),  v_cropHa(crops,plot,curRotTill,intens,t,nCur)\n                                                                              * p_SimRes(curRotTill,crops,intens,\"Nleach\")  )  ;\n</code></pre> <p>Furthermore, the SIMPLACE results contain a N balance which is summarised in the following equation. Please note that the calculation of this balance differs from the balance calculation under the Fertilisation Ordinance.</p> <pre><code>NSurplusSim_(curCrops(crops),tCur(t),nCur)\n                    $ ( t_n(t,nCur) $ sum ( (plot,till,intens), c_s_t_i(crops,plot,till,intens))  $ (not sameas (curCrops,\"catchcrop\") ) $ (not sameas (curCrops,\"idle\") )  ) ..\n\n\n                 v_NSurplusSim(crops,t,nCur)\n\n                       =e=\n\n                     sum(  c_s_t_i(curCrops,plot,curRotTill,intens),  v_cropHa(crops,plot,curRotTill,intens,t,nCur)\n                                                                             * p_SimRes(curRotTill,crops,intens,\"NSur\") ) ;\n</code></pre>"}]}